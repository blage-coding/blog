<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试问题合集 | Blage&#39;s Coding</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
    <script async="async" src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>
    <meta name="description" content="web后端技术博客,专注学习与总结。spring,redis,git等技术文章。">
    <meta name="keywords" content="后端博客,个人技术博客,后端,spring,redis,springcloud,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.0bbcb3d9.css" as="style"><link rel="preload" href="/assets/js/app.36a8861c.js" as="script"><link rel="preload" href="/assets/js/2.1ba3a2de.js" as="script"><link rel="preload" href="/assets/js/3.6e4df72f.js" as="script"><link rel="preload" href="/assets/js/421.7854bb4d.js" as="script"><link rel="prefetch" href="/assets/js/10.c58057de.js"><link rel="prefetch" href="/assets/js/100.d441dbf0.js"><link rel="prefetch" href="/assets/js/101.78fe1fa4.js"><link rel="prefetch" href="/assets/js/102.647ce353.js"><link rel="prefetch" href="/assets/js/103.d03a8ab2.js"><link rel="prefetch" href="/assets/js/104.1334d321.js"><link rel="prefetch" href="/assets/js/105.cf0e3cc9.js"><link rel="prefetch" href="/assets/js/106.4e9bdd09.js"><link rel="prefetch" href="/assets/js/107.b22d62f5.js"><link rel="prefetch" href="/assets/js/108.50d6a5bd.js"><link rel="prefetch" href="/assets/js/109.3b9acffe.js"><link rel="prefetch" href="/assets/js/11.d315ddaf.js"><link rel="prefetch" href="/assets/js/110.0234ef0b.js"><link rel="prefetch" href="/assets/js/111.b1bff776.js"><link rel="prefetch" href="/assets/js/112.36c74fab.js"><link rel="prefetch" href="/assets/js/113.560334ae.js"><link rel="prefetch" href="/assets/js/114.adc23b99.js"><link rel="prefetch" href="/assets/js/115.d9e71f5c.js"><link rel="prefetch" href="/assets/js/116.32911c0b.js"><link rel="prefetch" href="/assets/js/117.119c7cf8.js"><link rel="prefetch" href="/assets/js/118.f20c6b9e.js"><link rel="prefetch" href="/assets/js/119.ec1eb812.js"><link rel="prefetch" href="/assets/js/12.ae4fc36f.js"><link rel="prefetch" href="/assets/js/120.2559d9c2.js"><link rel="prefetch" href="/assets/js/121.0ea12d60.js"><link rel="prefetch" href="/assets/js/122.18af1954.js"><link rel="prefetch" href="/assets/js/123.1725de72.js"><link rel="prefetch" href="/assets/js/124.56fca314.js"><link rel="prefetch" href="/assets/js/125.bf30dd23.js"><link rel="prefetch" href="/assets/js/126.b113944a.js"><link rel="prefetch" href="/assets/js/127.b3e875c8.js"><link rel="prefetch" href="/assets/js/128.79f2565b.js"><link rel="prefetch" href="/assets/js/129.be36dadc.js"><link rel="prefetch" href="/assets/js/13.90c895cd.js"><link rel="prefetch" href="/assets/js/130.bb4c09ea.js"><link rel="prefetch" href="/assets/js/131.4b78d7b2.js"><link rel="prefetch" href="/assets/js/132.295f777f.js"><link rel="prefetch" href="/assets/js/133.e325508e.js"><link rel="prefetch" href="/assets/js/134.bec1d394.js"><link rel="prefetch" href="/assets/js/135.97742a95.js"><link rel="prefetch" href="/assets/js/136.ec2c8cc6.js"><link rel="prefetch" href="/assets/js/137.88e77cf6.js"><link rel="prefetch" href="/assets/js/138.884c718d.js"><link rel="prefetch" href="/assets/js/139.34be5c25.js"><link rel="prefetch" href="/assets/js/14.04e3cf36.js"><link rel="prefetch" href="/assets/js/140.622c35eb.js"><link rel="prefetch" href="/assets/js/141.79713e4e.js"><link rel="prefetch" href="/assets/js/142.534b8172.js"><link rel="prefetch" href="/assets/js/143.28d59575.js"><link rel="prefetch" href="/assets/js/144.51695ffa.js"><link rel="prefetch" href="/assets/js/145.9d456e08.js"><link rel="prefetch" href="/assets/js/146.5adbeaa3.js"><link rel="prefetch" href="/assets/js/147.349c32df.js"><link rel="prefetch" href="/assets/js/148.a2d1f30a.js"><link rel="prefetch" href="/assets/js/149.6d5375fc.js"><link rel="prefetch" href="/assets/js/15.19b97576.js"><link rel="prefetch" href="/assets/js/150.89d13fd4.js"><link rel="prefetch" href="/assets/js/151.d101e8a6.js"><link rel="prefetch" href="/assets/js/152.82dfb001.js"><link rel="prefetch" href="/assets/js/153.cc88b1e5.js"><link rel="prefetch" href="/assets/js/154.641d5da2.js"><link rel="prefetch" href="/assets/js/155.02185265.js"><link rel="prefetch" href="/assets/js/156.9b846c5d.js"><link rel="prefetch" href="/assets/js/157.ec766749.js"><link rel="prefetch" href="/assets/js/158.85812470.js"><link rel="prefetch" href="/assets/js/159.e2a4d02e.js"><link rel="prefetch" href="/assets/js/16.e71a580e.js"><link rel="prefetch" href="/assets/js/160.232093b0.js"><link rel="prefetch" href="/assets/js/161.bf58a934.js"><link rel="prefetch" href="/assets/js/162.023cd275.js"><link rel="prefetch" href="/assets/js/163.b8b05ef5.js"><link rel="prefetch" href="/assets/js/164.b7d6e1d3.js"><link rel="prefetch" href="/assets/js/165.797e81a7.js"><link rel="prefetch" href="/assets/js/166.7944abe6.js"><link rel="prefetch" href="/assets/js/167.af4a5ead.js"><link rel="prefetch" href="/assets/js/168.35c1d8ee.js"><link rel="prefetch" href="/assets/js/169.448c179e.js"><link rel="prefetch" href="/assets/js/17.e68c492f.js"><link rel="prefetch" href="/assets/js/170.35296827.js"><link rel="prefetch" href="/assets/js/171.11b1cd0a.js"><link rel="prefetch" href="/assets/js/172.e33ff1d7.js"><link rel="prefetch" href="/assets/js/173.a356df93.js"><link rel="prefetch" href="/assets/js/174.b86d39a6.js"><link rel="prefetch" href="/assets/js/175.34d7ca25.js"><link rel="prefetch" href="/assets/js/176.55567c3f.js"><link rel="prefetch" href="/assets/js/177.f19afc0e.js"><link rel="prefetch" href="/assets/js/178.a702d5d3.js"><link rel="prefetch" href="/assets/js/179.d87d300d.js"><link rel="prefetch" href="/assets/js/18.5ad3585a.js"><link rel="prefetch" href="/assets/js/180.efddacb1.js"><link rel="prefetch" href="/assets/js/181.0773dcbe.js"><link rel="prefetch" href="/assets/js/182.922199d1.js"><link rel="prefetch" href="/assets/js/183.bb8bf69d.js"><link rel="prefetch" href="/assets/js/184.96465931.js"><link rel="prefetch" href="/assets/js/185.0c2ff418.js"><link rel="prefetch" href="/assets/js/186.575cead0.js"><link rel="prefetch" href="/assets/js/187.d7267e61.js"><link rel="prefetch" href="/assets/js/188.a830793b.js"><link rel="prefetch" href="/assets/js/189.b1c5d145.js"><link rel="prefetch" href="/assets/js/19.2e88ed9d.js"><link rel="prefetch" href="/assets/js/190.05625483.js"><link rel="prefetch" href="/assets/js/191.cae6fb5c.js"><link rel="prefetch" href="/assets/js/192.866a4f9d.js"><link rel="prefetch" href="/assets/js/193.769e1571.js"><link rel="prefetch" href="/assets/js/194.f89dd1e2.js"><link rel="prefetch" href="/assets/js/195.71d615f2.js"><link rel="prefetch" href="/assets/js/196.9535cbb3.js"><link rel="prefetch" href="/assets/js/197.61c674dd.js"><link rel="prefetch" href="/assets/js/198.7bed473e.js"><link rel="prefetch" href="/assets/js/199.5758239b.js"><link rel="prefetch" href="/assets/js/20.5cf88440.js"><link rel="prefetch" href="/assets/js/200.eb4d48ae.js"><link rel="prefetch" href="/assets/js/201.82c165a6.js"><link rel="prefetch" href="/assets/js/202.5a38dc20.js"><link rel="prefetch" href="/assets/js/203.cb7ca4f9.js"><link rel="prefetch" href="/assets/js/204.9e21b560.js"><link rel="prefetch" href="/assets/js/205.36ca83de.js"><link rel="prefetch" href="/assets/js/206.70bb2865.js"><link rel="prefetch" href="/assets/js/207.39285f7f.js"><link rel="prefetch" href="/assets/js/208.9727449e.js"><link rel="prefetch" href="/assets/js/209.480868c5.js"><link rel="prefetch" href="/assets/js/21.0f587ebb.js"><link rel="prefetch" href="/assets/js/210.8e4c1210.js"><link rel="prefetch" href="/assets/js/211.bc7340f1.js"><link rel="prefetch" href="/assets/js/212.4c04ab90.js"><link rel="prefetch" href="/assets/js/213.3dbe7bec.js"><link rel="prefetch" href="/assets/js/214.72b272b2.js"><link rel="prefetch" href="/assets/js/215.7713d7e1.js"><link rel="prefetch" href="/assets/js/216.9998b17d.js"><link rel="prefetch" href="/assets/js/217.00976274.js"><link rel="prefetch" href="/assets/js/218.69766931.js"><link rel="prefetch" href="/assets/js/219.bdfa4000.js"><link rel="prefetch" href="/assets/js/22.66938927.js"><link rel="prefetch" href="/assets/js/220.50939e62.js"><link rel="prefetch" href="/assets/js/221.a0f45610.js"><link rel="prefetch" href="/assets/js/222.c6ab25f6.js"><link rel="prefetch" href="/assets/js/223.2dd963d3.js"><link rel="prefetch" href="/assets/js/224.69bbd7eb.js"><link rel="prefetch" href="/assets/js/225.0545e5e8.js"><link rel="prefetch" href="/assets/js/226.af45c420.js"><link rel="prefetch" href="/assets/js/227.ccd29bac.js"><link rel="prefetch" href="/assets/js/228.c1ac5069.js"><link rel="prefetch" href="/assets/js/229.fa3e6383.js"><link rel="prefetch" href="/assets/js/23.e1858dde.js"><link rel="prefetch" href="/assets/js/230.3a18d3c5.js"><link rel="prefetch" href="/assets/js/231.7dc7e87a.js"><link rel="prefetch" href="/assets/js/232.573fe260.js"><link rel="prefetch" href="/assets/js/233.c2272e2b.js"><link rel="prefetch" href="/assets/js/234.4e314017.js"><link rel="prefetch" href="/assets/js/235.3174500c.js"><link rel="prefetch" href="/assets/js/236.d95ffa02.js"><link rel="prefetch" href="/assets/js/237.d7dfeea0.js"><link rel="prefetch" href="/assets/js/238.92a9dcb3.js"><link rel="prefetch" href="/assets/js/239.3a4f01eb.js"><link rel="prefetch" href="/assets/js/24.44bdfaed.js"><link rel="prefetch" href="/assets/js/240.876d4f10.js"><link rel="prefetch" href="/assets/js/241.616936d2.js"><link rel="prefetch" href="/assets/js/242.f2f752c3.js"><link rel="prefetch" href="/assets/js/243.4069438d.js"><link rel="prefetch" href="/assets/js/244.86ad4edb.js"><link rel="prefetch" href="/assets/js/245.284662ca.js"><link rel="prefetch" href="/assets/js/246.7ce74ad7.js"><link rel="prefetch" href="/assets/js/247.eb3810ae.js"><link rel="prefetch" href="/assets/js/248.550f457d.js"><link rel="prefetch" href="/assets/js/249.a70de1d1.js"><link rel="prefetch" href="/assets/js/25.6853aa09.js"><link rel="prefetch" href="/assets/js/250.a754c631.js"><link rel="prefetch" href="/assets/js/251.7bf447c9.js"><link rel="prefetch" href="/assets/js/252.799bdf8c.js"><link rel="prefetch" href="/assets/js/253.c8aaba6a.js"><link rel="prefetch" href="/assets/js/254.b121e13e.js"><link rel="prefetch" href="/assets/js/255.b0cfb063.js"><link rel="prefetch" href="/assets/js/256.ed0ed666.js"><link rel="prefetch" href="/assets/js/257.2e062555.js"><link rel="prefetch" href="/assets/js/258.05919381.js"><link rel="prefetch" href="/assets/js/259.44720e3c.js"><link rel="prefetch" href="/assets/js/26.ef6c57c1.js"><link rel="prefetch" href="/assets/js/260.e096a742.js"><link rel="prefetch" href="/assets/js/261.fdbac558.js"><link rel="prefetch" href="/assets/js/262.c9d8c9c5.js"><link rel="prefetch" href="/assets/js/263.08b4de4e.js"><link rel="prefetch" href="/assets/js/264.553602b0.js"><link rel="prefetch" href="/assets/js/265.d3dcefe2.js"><link rel="prefetch" href="/assets/js/266.42a9274f.js"><link rel="prefetch" href="/assets/js/267.e2944502.js"><link rel="prefetch" href="/assets/js/268.aacc7772.js"><link rel="prefetch" href="/assets/js/269.76d03dd9.js"><link rel="prefetch" href="/assets/js/27.e96ead6a.js"><link rel="prefetch" href="/assets/js/270.2f128965.js"><link rel="prefetch" href="/assets/js/271.f994de25.js"><link rel="prefetch" href="/assets/js/272.0cea3b07.js"><link rel="prefetch" href="/assets/js/273.f890dfd0.js"><link rel="prefetch" href="/assets/js/274.bde1c133.js"><link rel="prefetch" href="/assets/js/275.a9694b76.js"><link rel="prefetch" href="/assets/js/276.e7e84972.js"><link rel="prefetch" href="/assets/js/277.56f9472a.js"><link rel="prefetch" href="/assets/js/278.ca08c74d.js"><link rel="prefetch" href="/assets/js/279.6a0c4b12.js"><link rel="prefetch" href="/assets/js/28.412943f9.js"><link rel="prefetch" href="/assets/js/280.c7b9e790.js"><link rel="prefetch" href="/assets/js/281.314e20e4.js"><link rel="prefetch" href="/assets/js/282.be50d936.js"><link rel="prefetch" href="/assets/js/283.9b181761.js"><link rel="prefetch" href="/assets/js/284.0ed9a91c.js"><link rel="prefetch" href="/assets/js/285.81d1433b.js"><link rel="prefetch" href="/assets/js/286.04db9923.js"><link rel="prefetch" href="/assets/js/287.0ef2023a.js"><link rel="prefetch" href="/assets/js/288.84c15ce5.js"><link rel="prefetch" href="/assets/js/289.81aa577f.js"><link rel="prefetch" href="/assets/js/29.a04dbce9.js"><link rel="prefetch" href="/assets/js/290.b67ecb11.js"><link rel="prefetch" href="/assets/js/291.095b30ff.js"><link rel="prefetch" href="/assets/js/292.c747922c.js"><link rel="prefetch" href="/assets/js/293.57b8c98f.js"><link rel="prefetch" href="/assets/js/294.29418f3b.js"><link rel="prefetch" href="/assets/js/295.863b9f10.js"><link rel="prefetch" href="/assets/js/296.b9e0cc9e.js"><link rel="prefetch" href="/assets/js/297.21c59e8e.js"><link rel="prefetch" href="/assets/js/298.5e7a00a0.js"><link rel="prefetch" href="/assets/js/299.3b576148.js"><link rel="prefetch" href="/assets/js/30.be3a4b17.js"><link rel="prefetch" href="/assets/js/300.88314dc9.js"><link rel="prefetch" href="/assets/js/301.837cefed.js"><link rel="prefetch" href="/assets/js/302.e09ac2f9.js"><link rel="prefetch" href="/assets/js/303.8d012a66.js"><link rel="prefetch" href="/assets/js/304.ab5a9b9f.js"><link rel="prefetch" href="/assets/js/305.a6ca89cd.js"><link rel="prefetch" href="/assets/js/306.2d9e8a8c.js"><link rel="prefetch" href="/assets/js/307.669c19f5.js"><link rel="prefetch" href="/assets/js/308.85d2d989.js"><link rel="prefetch" href="/assets/js/309.30258624.js"><link rel="prefetch" href="/assets/js/31.3b4cf92a.js"><link rel="prefetch" href="/assets/js/310.5f1daa31.js"><link rel="prefetch" href="/assets/js/311.b13b848c.js"><link rel="prefetch" href="/assets/js/312.e7ce7706.js"><link rel="prefetch" href="/assets/js/313.7c1448e0.js"><link rel="prefetch" href="/assets/js/314.4a8bcb5a.js"><link rel="prefetch" href="/assets/js/315.4b3b61ae.js"><link rel="prefetch" href="/assets/js/316.851983eb.js"><link rel="prefetch" href="/assets/js/317.65fda1f5.js"><link rel="prefetch" href="/assets/js/318.5b0681ba.js"><link rel="prefetch" href="/assets/js/319.eab916b3.js"><link rel="prefetch" href="/assets/js/32.1009e817.js"><link rel="prefetch" href="/assets/js/320.3964c648.js"><link rel="prefetch" href="/assets/js/321.98892efe.js"><link rel="prefetch" href="/assets/js/322.3e056383.js"><link rel="prefetch" href="/assets/js/323.f5bd5f27.js"><link rel="prefetch" href="/assets/js/324.52b992bd.js"><link rel="prefetch" href="/assets/js/325.3d6ec4cc.js"><link rel="prefetch" href="/assets/js/326.c03333c8.js"><link rel="prefetch" href="/assets/js/327.bf4f3b61.js"><link rel="prefetch" href="/assets/js/328.d91ebcce.js"><link rel="prefetch" href="/assets/js/329.0dff70ac.js"><link rel="prefetch" href="/assets/js/33.a36484ca.js"><link rel="prefetch" href="/assets/js/330.7caf6c7c.js"><link rel="prefetch" href="/assets/js/331.0f6f75e7.js"><link rel="prefetch" href="/assets/js/332.822ffb16.js"><link rel="prefetch" href="/assets/js/333.ecd22088.js"><link rel="prefetch" href="/assets/js/334.13125819.js"><link rel="prefetch" href="/assets/js/335.caa18f52.js"><link rel="prefetch" href="/assets/js/336.e349a6ec.js"><link rel="prefetch" href="/assets/js/337.aae6617f.js"><link rel="prefetch" href="/assets/js/338.29bfe09e.js"><link rel="prefetch" href="/assets/js/339.7f9972a2.js"><link rel="prefetch" href="/assets/js/34.ecb5ee6d.js"><link rel="prefetch" href="/assets/js/340.b234848b.js"><link rel="prefetch" href="/assets/js/341.f2bf78a2.js"><link rel="prefetch" href="/assets/js/342.f272119e.js"><link rel="prefetch" href="/assets/js/343.51038386.js"><link rel="prefetch" href="/assets/js/344.026dad95.js"><link rel="prefetch" href="/assets/js/345.cc52ec50.js"><link rel="prefetch" href="/assets/js/346.49bf455b.js"><link rel="prefetch" href="/assets/js/347.19a34365.js"><link rel="prefetch" href="/assets/js/348.128c9e0f.js"><link rel="prefetch" href="/assets/js/349.9f3daf6b.js"><link rel="prefetch" href="/assets/js/35.c315a737.js"><link rel="prefetch" href="/assets/js/350.b2a2eeaa.js"><link rel="prefetch" href="/assets/js/351.a8d13a5a.js"><link rel="prefetch" href="/assets/js/352.2c7a0e40.js"><link rel="prefetch" href="/assets/js/353.ca0c65e0.js"><link rel="prefetch" href="/assets/js/354.74684d12.js"><link rel="prefetch" href="/assets/js/355.4b4e1ed4.js"><link rel="prefetch" href="/assets/js/356.873f616d.js"><link rel="prefetch" href="/assets/js/357.495b41b7.js"><link rel="prefetch" href="/assets/js/358.9baa2811.js"><link rel="prefetch" href="/assets/js/359.dc1dcb16.js"><link rel="prefetch" href="/assets/js/36.6be141ba.js"><link rel="prefetch" href="/assets/js/360.48933205.js"><link rel="prefetch" href="/assets/js/361.f4ea428e.js"><link rel="prefetch" href="/assets/js/362.422ec9b2.js"><link rel="prefetch" href="/assets/js/363.b829dc7f.js"><link rel="prefetch" href="/assets/js/364.4ec4ee9b.js"><link rel="prefetch" href="/assets/js/365.3ccbfd91.js"><link rel="prefetch" href="/assets/js/366.c1f854bd.js"><link rel="prefetch" href="/assets/js/367.739b54b3.js"><link rel="prefetch" href="/assets/js/368.d6db3651.js"><link rel="prefetch" href="/assets/js/369.411e5e78.js"><link rel="prefetch" href="/assets/js/37.7d8a4488.js"><link rel="prefetch" href="/assets/js/370.9f9b2494.js"><link rel="prefetch" href="/assets/js/371.24693fff.js"><link rel="prefetch" href="/assets/js/372.cd4efc79.js"><link rel="prefetch" href="/assets/js/373.5191c19e.js"><link rel="prefetch" href="/assets/js/374.350a6c41.js"><link rel="prefetch" href="/assets/js/375.0d4f7c5f.js"><link rel="prefetch" href="/assets/js/376.a0ae96ae.js"><link rel="prefetch" href="/assets/js/377.6f112bc0.js"><link rel="prefetch" href="/assets/js/378.b3ad1ecf.js"><link rel="prefetch" href="/assets/js/379.bb251ea3.js"><link rel="prefetch" href="/assets/js/38.2b0ed5fe.js"><link rel="prefetch" href="/assets/js/380.c7100500.js"><link rel="prefetch" href="/assets/js/381.b2f7e7d6.js"><link rel="prefetch" href="/assets/js/382.8e62b8aa.js"><link rel="prefetch" href="/assets/js/383.5ad40cef.js"><link rel="prefetch" href="/assets/js/384.62718694.js"><link rel="prefetch" href="/assets/js/385.7687a101.js"><link rel="prefetch" href="/assets/js/386.3aa2ec6b.js"><link rel="prefetch" href="/assets/js/387.080f5944.js"><link rel="prefetch" href="/assets/js/388.d53bfd0d.js"><link rel="prefetch" href="/assets/js/389.30b59475.js"><link rel="prefetch" href="/assets/js/39.d4be9171.js"><link rel="prefetch" href="/assets/js/390.e20ebf2a.js"><link rel="prefetch" href="/assets/js/391.265d7b4a.js"><link rel="prefetch" href="/assets/js/392.ebdeb0d8.js"><link rel="prefetch" href="/assets/js/393.3112584f.js"><link rel="prefetch" href="/assets/js/394.7c754e70.js"><link rel="prefetch" href="/assets/js/395.51eb51ab.js"><link rel="prefetch" href="/assets/js/396.2ac8fa9a.js"><link rel="prefetch" href="/assets/js/397.73b7e0d0.js"><link rel="prefetch" href="/assets/js/398.bfe9fe1b.js"><link rel="prefetch" href="/assets/js/399.3fbe9247.js"><link rel="prefetch" href="/assets/js/4.2cb195dd.js"><link rel="prefetch" href="/assets/js/40.82187d91.js"><link rel="prefetch" href="/assets/js/400.a65cd6d3.js"><link rel="prefetch" href="/assets/js/401.9dc6f11b.js"><link rel="prefetch" href="/assets/js/402.1c996e16.js"><link rel="prefetch" href="/assets/js/403.c2fc87b4.js"><link rel="prefetch" href="/assets/js/404.f295cb4d.js"><link rel="prefetch" href="/assets/js/405.baf800ce.js"><link rel="prefetch" href="/assets/js/406.dd62b585.js"><link rel="prefetch" href="/assets/js/407.8f99059b.js"><link rel="prefetch" href="/assets/js/408.79c37181.js"><link rel="prefetch" href="/assets/js/409.8b8b3e73.js"><link rel="prefetch" href="/assets/js/41.de15dcd3.js"><link rel="prefetch" href="/assets/js/410.4183d880.js"><link rel="prefetch" href="/assets/js/411.9ef5d6df.js"><link rel="prefetch" href="/assets/js/412.ce37597b.js"><link rel="prefetch" href="/assets/js/413.b3a7d5a6.js"><link rel="prefetch" href="/assets/js/414.591bceb5.js"><link rel="prefetch" href="/assets/js/415.cda694b3.js"><link rel="prefetch" href="/assets/js/416.25640d0c.js"><link rel="prefetch" href="/assets/js/417.51f26447.js"><link rel="prefetch" href="/assets/js/418.dcbcdf97.js"><link rel="prefetch" href="/assets/js/419.1059dcfd.js"><link rel="prefetch" href="/assets/js/42.1d792a1c.js"><link rel="prefetch" href="/assets/js/420.d5d37fab.js"><link rel="prefetch" href="/assets/js/422.70f45269.js"><link rel="prefetch" href="/assets/js/423.f4e6eb9e.js"><link rel="prefetch" href="/assets/js/424.c4bb6e45.js"><link rel="prefetch" href="/assets/js/425.55e47f2d.js"><link rel="prefetch" href="/assets/js/426.97cbd3ca.js"><link rel="prefetch" href="/assets/js/427.b4327262.js"><link rel="prefetch" href="/assets/js/428.feac2880.js"><link rel="prefetch" href="/assets/js/429.ab1f8568.js"><link rel="prefetch" href="/assets/js/43.a77be863.js"><link rel="prefetch" href="/assets/js/430.d0a4ee37.js"><link rel="prefetch" href="/assets/js/431.cdad8279.js"><link rel="prefetch" href="/assets/js/432.fe559595.js"><link rel="prefetch" href="/assets/js/433.122ba82a.js"><link rel="prefetch" href="/assets/js/434.df8d47d0.js"><link rel="prefetch" href="/assets/js/435.332aa966.js"><link rel="prefetch" href="/assets/js/436.db4094b8.js"><link rel="prefetch" href="/assets/js/437.a4c48f1a.js"><link rel="prefetch" href="/assets/js/438.ed08b26c.js"><link rel="prefetch" href="/assets/js/439.c8866503.js"><link rel="prefetch" href="/assets/js/44.504638ff.js"><link rel="prefetch" href="/assets/js/440.188ca2ff.js"><link rel="prefetch" href="/assets/js/441.449266b3.js"><link rel="prefetch" href="/assets/js/442.d3c849d6.js"><link rel="prefetch" href="/assets/js/443.be797f33.js"><link rel="prefetch" href="/assets/js/444.9c5fa2e4.js"><link rel="prefetch" href="/assets/js/445.e862dc31.js"><link rel="prefetch" href="/assets/js/446.41193f53.js"><link rel="prefetch" href="/assets/js/447.97950dae.js"><link rel="prefetch" href="/assets/js/448.28f60263.js"><link rel="prefetch" href="/assets/js/449.3d8e920d.js"><link rel="prefetch" href="/assets/js/45.6bb2fc1e.js"><link rel="prefetch" href="/assets/js/450.b33ac323.js"><link rel="prefetch" href="/assets/js/451.a29bdef5.js"><link rel="prefetch" href="/assets/js/452.e439e622.js"><link rel="prefetch" href="/assets/js/453.6e2532da.js"><link rel="prefetch" href="/assets/js/454.69ccfbd3.js"><link rel="prefetch" href="/assets/js/455.22596db1.js"><link rel="prefetch" href="/assets/js/456.958addb4.js"><link rel="prefetch" href="/assets/js/457.01dfa630.js"><link rel="prefetch" href="/assets/js/458.245cc853.js"><link rel="prefetch" href="/assets/js/459.3a29da9f.js"><link rel="prefetch" href="/assets/js/46.220fcda2.js"><link rel="prefetch" href="/assets/js/460.f68d5211.js"><link rel="prefetch" href="/assets/js/461.1cc4badc.js"><link rel="prefetch" href="/assets/js/462.f56dbed5.js"><link rel="prefetch" href="/assets/js/463.a4fc68b9.js"><link rel="prefetch" href="/assets/js/464.1449aec4.js"><link rel="prefetch" href="/assets/js/465.3bd78a23.js"><link rel="prefetch" href="/assets/js/466.f2cce87d.js"><link rel="prefetch" href="/assets/js/467.20033fda.js"><link rel="prefetch" href="/assets/js/468.6605b6cc.js"><link rel="prefetch" href="/assets/js/469.0c20f0c7.js"><link rel="prefetch" href="/assets/js/47.e63332df.js"><link rel="prefetch" href="/assets/js/470.3ba54d64.js"><link rel="prefetch" href="/assets/js/471.f2cefd99.js"><link rel="prefetch" href="/assets/js/472.bf7f33a2.js"><link rel="prefetch" href="/assets/js/473.56258d40.js"><link rel="prefetch" href="/assets/js/474.eb884e1c.js"><link rel="prefetch" href="/assets/js/48.768a9a93.js"><link rel="prefetch" href="/assets/js/49.1f8a24a8.js"><link rel="prefetch" href="/assets/js/5.40c1dc66.js"><link rel="prefetch" href="/assets/js/50.2a07120e.js"><link rel="prefetch" href="/assets/js/51.2527531c.js"><link rel="prefetch" href="/assets/js/52.fb084bd7.js"><link rel="prefetch" href="/assets/js/53.3541f39a.js"><link rel="prefetch" href="/assets/js/54.4084d4c6.js"><link rel="prefetch" href="/assets/js/55.0b7de523.js"><link rel="prefetch" href="/assets/js/56.a46277bf.js"><link rel="prefetch" href="/assets/js/57.678c9751.js"><link rel="prefetch" href="/assets/js/58.44469be6.js"><link rel="prefetch" href="/assets/js/59.9036b283.js"><link rel="prefetch" href="/assets/js/6.113d94ad.js"><link rel="prefetch" href="/assets/js/60.8ea6e0d1.js"><link rel="prefetch" href="/assets/js/61.b1441bfd.js"><link rel="prefetch" href="/assets/js/62.4055fa88.js"><link rel="prefetch" href="/assets/js/63.343809c3.js"><link rel="prefetch" href="/assets/js/64.6a37684e.js"><link rel="prefetch" href="/assets/js/65.498b3095.js"><link rel="prefetch" href="/assets/js/66.472c3f67.js"><link rel="prefetch" href="/assets/js/67.ffd3512f.js"><link rel="prefetch" href="/assets/js/68.80e6e1e1.js"><link rel="prefetch" href="/assets/js/69.8ee08ad1.js"><link rel="prefetch" href="/assets/js/7.f2a2af84.js"><link rel="prefetch" href="/assets/js/70.9c7b808d.js"><link rel="prefetch" href="/assets/js/71.0abc26fe.js"><link rel="prefetch" href="/assets/js/72.011b472b.js"><link rel="prefetch" href="/assets/js/73.cb725aa1.js"><link rel="prefetch" href="/assets/js/74.537d7d78.js"><link rel="prefetch" href="/assets/js/75.77394ac8.js"><link rel="prefetch" href="/assets/js/76.b8eecb30.js"><link rel="prefetch" href="/assets/js/77.7afc22e0.js"><link rel="prefetch" href="/assets/js/78.eb08bd7e.js"><link rel="prefetch" href="/assets/js/79.3d08d738.js"><link rel="prefetch" href="/assets/js/8.0fe505d0.js"><link rel="prefetch" href="/assets/js/80.c928504a.js"><link rel="prefetch" href="/assets/js/81.998c413a.js"><link rel="prefetch" href="/assets/js/82.174c8592.js"><link rel="prefetch" href="/assets/js/83.67048269.js"><link rel="prefetch" href="/assets/js/84.9beb2214.js"><link rel="prefetch" href="/assets/js/85.d9c794cc.js"><link rel="prefetch" href="/assets/js/86.26221cd0.js"><link rel="prefetch" href="/assets/js/87.dfa56052.js"><link rel="prefetch" href="/assets/js/88.4dc20bd0.js"><link rel="prefetch" href="/assets/js/89.ee73979e.js"><link rel="prefetch" href="/assets/js/9.7f2610de.js"><link rel="prefetch" href="/assets/js/90.bbad017a.js"><link rel="prefetch" href="/assets/js/91.bae1ea17.js"><link rel="prefetch" href="/assets/js/92.1f075317.js"><link rel="prefetch" href="/assets/js/93.167a2544.js"><link rel="prefetch" href="/assets/js/94.9bcde3bb.js"><link rel="prefetch" href="/assets/js/95.41a0e2d6.js"><link rel="prefetch" href="/assets/js/96.d0cb9dae.js"><link rel="prefetch" href="/assets/js/97.510de6ab.js"><link rel="prefetch" href="/assets/js/98.a3772e11.js"><link rel="prefetch" href="/assets/js/99.5f982463.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0bbcb3d9.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Blage's Coding" class="logo"> <span class="site-name can-hide">Blage's Coding</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><a href="/spring/" class="link-title">Spring</a> <span class="title" style="display:none;">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/spring/" class="nav-link">手写Spring</a></li><li class="dropdown-item"><!----> <a href="/cata/ssm/" class="nav-link">SSM</a></li><li class="dropdown-item"><!----> <a href="/cata/springboot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/cata/javaweb/" class="nav-link">JavaWeb</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JAVA基础" class="dropdown-title"><a href="/java/" class="link-title">JAVA基础</a> <span class="title" style="display:none;">JAVA基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/javabasic/" class="nav-link">JAVA基础</a></li><li class="dropdown-item"><!----> <a href="/cata/jihe/" class="nav-link">容器</a></li><li class="dropdown-item"><h4>Netty</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/3e5651/" class="nav-link">IO模型</a></li><li class="dropdown-subitem"><a href="/pages/dc2076/" class="nav-link">Netty初级</a></li><li class="dropdown-subitem"><a href="/pages/9ed934/" class="nav-link">Netty原理</a></li></ul></li><li class="dropdown-item"><!----> <a href="/cata/jvm/" class="nav-link">JVM</a></li><li class="dropdown-item"><!----> <a href="/cata/juc/" class="nav-link">JUC</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Redis" class="dropdown-title"><a href="/redis/" class="link-title">Redis</a> <span class="title" style="display:none;">Redis</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/redisbasic/" class="nav-link">Redis基础</a></li><li class="dropdown-item"><!----> <a href="/cata/redisanalyse/" class="nav-link">源码分析</a></li><li class="dropdown-item"><!----> <a href="/redis/" class="nav-link">实战应用</a></li><li class="dropdown-item"><!----> <a href="/redis/" class="nav-link">单机缓存</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/mysql/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>MySQL</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mysql/" class="nav-link">基础部分</a></li><li class="dropdown-subitem"><a href="/mysql/" class="nav-link">实战与处理方案</a></li><li class="dropdown-subitem"><a href="/mysql/" class="nav-link">面试</a></li></ul></li><li class="dropdown-item"><h4>ORM框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/41f194/" class="nav-link">Mybatis</a></li><li class="dropdown-subitem"><a href="/pages/b188b3/" class="nav-link">Mybatis_Plus</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/cloud/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/alibaba/" class="nav-link">SpringCloudAlibaba</a></li><li class="dropdown-item"><!----> <a href="/cata/mq/" class="nav-link">MQ消息队列</a></li><li class="dropdown-item"><!----> <a href="/cata/nginx/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/cata/es/" class="nav-link">Elasticsearch</a></li><li class="dropdown-item"><!----> <a href="/pages/b8c685/" class="nav-link">Gateway</a></li><li class="dropdown-item"><!----> <a href="/pages/72792a/" class="nav-link">Xxl-job</a></li><li class="dropdown-item"><!----> <a href="/pages/8bf560/" class="nav-link">Feign</a></li><li class="dropdown-item"><!----> <a href="/pages/d80289/" class="nav-link">Eureka</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/mianshi/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/cata/gongju/" class="nav-link">工具</a></li><li class="dropdown-item"><!----> <a href="/cata/pro/" class="nav-link">项目</a></li><li class="dropdown-item"><!----> <a href="/pages/f2e63f/" class="nav-link">关于</a></li></ul></div></div><div class="nav-item"><a href="/cata/benzhan/" class="nav-link">🌏本站</a></div> <a href="https://github.com/blage-coding/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    🧸GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Spring" class="dropdown-title"><a href="/spring/" class="link-title">Spring</a> <span class="title" style="display:none;">Spring</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/spring/" class="nav-link">手写Spring</a></li><li class="dropdown-item"><!----> <a href="/cata/ssm/" class="nav-link">SSM</a></li><li class="dropdown-item"><!----> <a href="/cata/springboot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/cata/javaweb/" class="nav-link">JavaWeb</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JAVA基础" class="dropdown-title"><a href="/java/" class="link-title">JAVA基础</a> <span class="title" style="display:none;">JAVA基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/javabasic/" class="nav-link">JAVA基础</a></li><li class="dropdown-item"><!----> <a href="/cata/jihe/" class="nav-link">容器</a></li><li class="dropdown-item"><h4>Netty</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/3e5651/" class="nav-link">IO模型</a></li><li class="dropdown-subitem"><a href="/pages/dc2076/" class="nav-link">Netty初级</a></li><li class="dropdown-subitem"><a href="/pages/9ed934/" class="nav-link">Netty原理</a></li></ul></li><li class="dropdown-item"><!----> <a href="/cata/jvm/" class="nav-link">JVM</a></li><li class="dropdown-item"><!----> <a href="/cata/juc/" class="nav-link">JUC</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Redis" class="dropdown-title"><a href="/redis/" class="link-title">Redis</a> <span class="title" style="display:none;">Redis</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/redisbasic/" class="nav-link">Redis基础</a></li><li class="dropdown-item"><!----> <a href="/cata/redisanalyse/" class="nav-link">源码分析</a></li><li class="dropdown-item"><!----> <a href="/redis/" class="nav-link">实战应用</a></li><li class="dropdown-item"><!----> <a href="/redis/" class="nav-link">单机缓存</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/mysql/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>MySQL</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/mysql/" class="nav-link">基础部分</a></li><li class="dropdown-subitem"><a href="/mysql/" class="nav-link">实战与处理方案</a></li><li class="dropdown-subitem"><a href="/mysql/" class="nav-link">面试</a></li></ul></li><li class="dropdown-item"><h4>ORM框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/41f194/" class="nav-link">Mybatis</a></li><li class="dropdown-subitem"><a href="/pages/b188b3/" class="nav-link">Mybatis_Plus</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><a href="/cloud/" class="link-title">中间件</a> <span class="title" style="display:none;">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/alibaba/" class="nav-link">SpringCloudAlibaba</a></li><li class="dropdown-item"><!----> <a href="/cata/mq/" class="nav-link">MQ消息队列</a></li><li class="dropdown-item"><!----> <a href="/cata/nginx/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/cata/es/" class="nav-link">Elasticsearch</a></li><li class="dropdown-item"><!----> <a href="/pages/b8c685/" class="nav-link">Gateway</a></li><li class="dropdown-item"><!----> <a href="/pages/72792a/" class="nav-link">Xxl-job</a></li><li class="dropdown-item"><!----> <a href="/pages/8bf560/" class="nav-link">Feign</a></li><li class="dropdown-item"><!----> <a href="/pages/d80289/" class="nav-link">Eureka</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cata/mianshi/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/cata/gongju/" class="nav-link">工具</a></li><li class="dropdown-item"><!----> <a href="/cata/pro/" class="nav-link">项目</a></li><li class="dropdown-item"><!----> <a href="/pages/f2e63f/" class="nav-link">关于</a></li></ul></div></div><div class="nav-item"><a href="/cata/benzhan/" class="nav-link">🌏本站</a></div> <a href="https://github.com/blage-coding/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    🧸GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/14a163/" class="sidebar-link">个人向面试问题</a></li><li><a href="/pages/b5e3a0/" class="sidebar-link">分散的面试问题</a></li><li><a href="/pages/621a20/" aria-current="page" class="active sidebar-link">面试问题合集</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/621a20/#网络" class="sidebar-link">网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、tcp三次握手和四次挥手" class="sidebar-link">1、TCP三次握手和四次挥手</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#为什么三次-为什么四次" class="sidebar-link">为什么三次？？为什么四次？？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、time-wait状态延迟关闭连接的必要性" class="sidebar-link">2、TIME_WAIT状态延迟关闭连接的必要性</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、time-wait的连接数量过多" class="sidebar-link">3、TIME_WAIT的连接数量过多</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、osi、http、url解析" class="sidebar-link">4、OSI、HTTP、URL解析</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、重定向和转发" class="sidebar-link">5、重定向和转发</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、cookie和session区别" class="sidebar-link">6、cookie和session区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、dns解析的过程" class="sidebar-link">7、DNS解析的过程？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、tcp拆包沾包半包问题" class="sidebar-link">8、TCP拆包沾包半包问题</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_9、tcp拥塞控制算法-tcp为什么是可靠的" class="sidebar-link">9、TCP拥塞控制算法？TCP为什么是可靠的？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#操作系统" class="sidebar-link">操作系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、分页置换算法以及代码实现" class="sidebar-link">1、分页置换算法以及代码实现</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、死锁解决方法" class="sidebar-link">2、死锁解决方法</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、进程之间的通信方式" class="sidebar-link">3、进程之间的通信方式？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、内核态和用户态之间的区别-为什么区分两个" class="sidebar-link">4、内核态和用户态之间的区别？为什么区分两个？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、操作系统内存管理" class="sidebar-link">5、操作系统内存管理</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、进程调度" class="sidebar-link">6、进程调度</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、死锁的必要条件" class="sidebar-link">7、死锁的必要条件？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、页表-tlb-cache的访问次数" class="sidebar-link">8、页表+TLB+Cache的访问次数</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#java基础" class="sidebar-link">JAVA基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、三大特性-重写和重载" class="sidebar-link">1、三大特性？重写和重载</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、static和final" class="sidebar-link">2、static和final</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、hashmap的put操作-容量为什么是2的整数次幂-哈希扰动函数-红黑树的优势-死循环问题" class="sidebar-link">3、HashMap的put操作？容量为什么是2的整数次幂？哈希扰动函数？红黑树的优势？死循环问题？</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#容量2的n次方" class="sidebar-link">容量2的N次方？</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#哈希值如何计算" class="sidebar-link">哈希值如何计算？</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#说说红黑树相比其他树优势" class="sidebar-link">说说红黑树相比其他树优势？</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#死循环问题" class="sidebar-link">死循环问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、concurrenthashmap底层如何实现线程安全-get方法是否上锁" class="sidebar-link">4、ConcurrentHashMap底层如何实现线程安全？get方法是否上锁？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、stringbuilder和stringbuffer区分" class="sidebar-link">5、StringBuilder和StringBuffer区分</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、说说类内的静态初始化块执行顺序" class="sidebar-link">6、说说类内的静态初始化块执行顺序</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、equals和hashcode的重写问题" class="sidebar-link">7、equals和hashcode的重写问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、java异常-throw和throws" class="sidebar-link">8、Java异常？throw和throws</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_9、threadlocal介绍-内存泄露的问题" class="sidebar-link">9、ThreadLocal介绍？内存泄露的问题？</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#threadlocal的内存泄露问题" class="sidebar-link">ThreadLocal的内存泄露问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_10、arraylist的grow扩容过程" class="sidebar-link">10、ArrayList的grow扩容过程？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_11、hashmap链表插入方式" class="sidebar-link">11、Hashmap链表插入方式</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_12、注解的底层原理" class="sidebar-link">12、注解的底层原理？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_13、反射的底层机制" class="sidebar-link">13、反射的底层机制</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#mysql" class="sidebar-link">MySQL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、mysql四个特点-隔离级别-脏读、不可重复读、幻读" class="sidebar-link">1、MySQL四个特点？隔离级别？脏读、不可重复读、幻读？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、mysql为什么使用b-树" class="sidebar-link">2、MySQL为什么使用B+树？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、如何建立索引-如何查看是否使用索引-最左匹配原则" class="sidebar-link">3、如何建立索引？如何查看是否使用索引？最左匹配原则？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、聚簇索引和非聚簇索引" class="sidebar-link">4、聚簇索引和非聚簇索引</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、索引什么时候会失效" class="sidebar-link">5、索引什么时候会失效</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、truncate、delete、drop之间的区别" class="sidebar-link">6、truncate、delete、drop之间的区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、join语句" class="sidebar-link">7、join语句</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、sql优化方案" class="sidebar-link">8、SQL优化方案</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_9、慢sql语句如何排查" class="sidebar-link">9、慢SQL语句如何排查？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_10、mysql数据类型和选用的场景" class="sidebar-link">10、MySQL数据类型和选用的场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_11、执行一条语句的过程" class="sidebar-link">11、执行一条语句的过程</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_12、mysql不使用跳表、b树的原因" class="sidebar-link">12、Mysql不使用跳表、B树的原因？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_13、redolog与binlog区别-两阶段提交是什么" class="sidebar-link">13、redolog与binlog区别？两阶段提交是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_14、mysql的刷盘机制" class="sidebar-link">14、MySQL的刷盘机制？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#juc并发" class="sidebar-link">JUC并发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、volatile保持内存可见性" class="sidebar-link">1、volatile保持内存可见性</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、synchronized底层实现-如何获取锁-锁升级" class="sidebar-link">2、synchronized底层实现？如何获取锁？锁升级</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、谈谈reentrantlock-和synchronized对比" class="sidebar-link">3、谈谈ReentrantLock？和Synchronized对比？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、线程池参数-核心线程数设置" class="sidebar-link">4、线程池参数？核心线程数设置？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、创建线程的方法" class="sidebar-link">5、创建线程的方法？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、obj-wait、thread-join、thread-sleep的区别" class="sidebar-link">6、obj.wait、thread.join、thread.sleep的区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、说说cas思想-缺点是什么-如何解决" class="sidebar-link">7、说说CAS思想？缺点是什么？如何解决？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、什么时候使用cas和悲观锁" class="sidebar-link">8、什么时候使用CAS和悲观锁？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#jvm内存" class="sidebar-link">JVM内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、jvm内存分配-一个对象从创建到gc的整个过程" class="sidebar-link">1、JVM内存分配？一个对象从创建到GC的整个过程？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、双亲委派机制-如何破坏" class="sidebar-link">2、双亲委派机制？如何破坏？</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#双亲委派机制破坏" class="sidebar-link">双亲委派机制破坏？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、如何判断一个对象是不是垃圾" class="sidebar-link">3、如何判断一个对象是不是垃圾？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、垃圾回收算法有哪些" class="sidebar-link">4、垃圾回收算法有哪些？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、垃圾回收器有哪些" class="sidebar-link">5、垃圾回收器有哪些？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、什么是三色标记法-如何解决错标和漏标" class="sidebar-link">6、什么是三色标记法？如何解决错标和漏标？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、minor-gc" class="sidebar-link">7、minor GC</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、类加载流程" class="sidebar-link">8、类加载流程</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_9、对象什么时候跑到堆外面" class="sidebar-link">9、对象什么时候跑到堆外面？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_10、cms垃圾回收器-g1垃圾回收器-zgc垃圾回收器-使用场景" class="sidebar-link">10、CMS垃圾回收器？G1垃圾回收器？ZGC垃圾回收器？使用场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_11、jdk1-8默认使用什么垃圾回收器" class="sidebar-link">11、jdk1.8默认使用什么垃圾回收器？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#redis" class="sidebar-link">Redis</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、说说redis、memcache、guava-caffeine" class="sidebar-link">1、说说Redis、Memcache、Guava/Caffeine</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、redis数据类型有哪些-sds和跳表" class="sidebar-link">2、Redis数据类型有哪些？SDS和跳表？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、redis持久化机制" class="sidebar-link">3、Redis持久化机制？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、redis内存淘汰策略-过期策略" class="sidebar-link">4、Redis内存淘汰策略?过期策略？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、缓存穿透、缓存击穿、缓存雪崩-对应解决方法" class="sidebar-link">5、缓存穿透、缓存击穿、缓存雪崩？对应解决方法？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、热点key问题" class="sidebar-link">6、热点key问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、大key问题" class="sidebar-link">7、大key问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、如何保证数据库和缓存一致性" class="sidebar-link">8、如何保证数据库和缓存一致性？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_9、redis的主从模式、哨兵模式" class="sidebar-link">9、Redis的主从模式、哨兵模式？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_10、基于redis能够做什么" class="sidebar-link">10、基于Redis能够做什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_11、谈谈redis的单线程模型" class="sidebar-link">11、谈谈Redis的单线程模型？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_12、redis如何设置持久化模式" class="sidebar-link">12、redis如何设置持久化模式</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_13、redis刷新策略" class="sidebar-link">13、redis刷新策略</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_14、redisson如何加锁保证原子性" class="sidebar-link">14、redisson如何加锁保证原子性？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_15、setnx有哪些风险" class="sidebar-link">15、setnx有哪些风险</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_16、redis一致性hash" class="sidebar-link">16、redis一致性hash</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#消息队列" class="sidebar-link">消息队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、介绍kafka中的topic、partition、replica" class="sidebar-link">1、介绍kafka中的topic、partition、replica？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、kafka与zookeeper之间的关系" class="sidebar-link">2、kafka与zookeeper之间的关系</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、kafka如何保证消息的顺序消费" class="sidebar-link">3、kafka如何保证消息的顺序消费？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、kafka如何保证消息不会丢失" class="sidebar-link">4、kafka如何保证消息不会丢失？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、kafka如何保证消息的幂等性消费" class="sidebar-link">5、kafka如何保证消息的幂等性消费？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、谈谈死信队列" class="sidebar-link">6、谈谈死信队列</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、如何处理消息积压问题" class="sidebar-link">7、如何处理消息积压问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、kafka为什么这么快" class="sidebar-link">8、kafka为什么这么快？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#spring" class="sidebar-link">Spring</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、spring说说ioc-整个bean的生命周期" class="sidebar-link">1、Spring说说IOC，整个Bean的生命周期？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、spring的aware依赖倒置" class="sidebar-link">2、Spring的Aware依赖倒置？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、spring的aop切面实现" class="sidebar-link">3、Spring的AOP切面实现？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、spring-如何解决循环依赖问题" class="sidebar-link">4、Spring 如何解决循环依赖问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、spring的-event事件机制-观察者模式" class="sidebar-link">5、Spring的 Event事件机制—观察者模式？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、spring的自动扫描-component-那么-autowired呢" class="sidebar-link">6、Spring的自动扫描@component？那么@Autowired呢？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、spring当中的factorybean和beanfactory有什么区别" class="sidebar-link">7、Spring当中的FactoryBean和BeanFactory有什么区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、spring的设计模式有哪些" class="sidebar-link">8、Spring的设计模式有哪些</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#netty" class="sidebar-link">Netty</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、谈谈bio、nio、aio" class="sidebar-link">1、谈谈BIO、NIO、AIO</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、reactor模型" class="sidebar-link">2、Reactor模型</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、netty和nio之间的区别" class="sidebar-link">3、Netty和NIO之间的区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、半包和粘包问题-如何解决" class="sidebar-link">4、半包和粘包问题，如何解决？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、netty零拷贝" class="sidebar-link">5、Netty零拷贝</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、netty为什么快" class="sidebar-link">6、Netty为什么快</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#项目一" class="sidebar-link">项目一</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、抽奖项目设计模式" class="sidebar-link">1、抽奖项目设计模式</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、数据库路由组件" class="sidebar-link">2、数据库路由组件</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、谈谈规则引擎设计的意义是什么-如何实现的" class="sidebar-link">3、谈谈规则引擎设计的意义是什么？如何实现的？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、介绍一下整个抽奖活动的主链路" class="sidebar-link">4、介绍一下整个抽奖活动的主链路？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、说说抽奖活动的秒杀场景" class="sidebar-link">5、说说抽奖活动的秒杀场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、动态路由导致事务失效如何解决" class="sidebar-link">6、动态路由导致事务失效如何解决？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、如何防止超领和超发" class="sidebar-link">7、如何防止超领和超发？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、谈谈两个kafka异步流程" class="sidebar-link">8、谈谈两个kafka异步流程？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_9、项目中遇到什么问题" class="sidebar-link">9、项目中遇到什么问题？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_10、抽奖项目调优经验" class="sidebar-link">10、抽奖项目调优经验</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_11、抽奖项目数据库表设计" class="sidebar-link">11、抽奖项目数据库表设计</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_12、项目ddd划分成几个领域" class="sidebar-link">12、项目DDD划分成几个领域？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_13、组合模式" class="sidebar-link">13、组合模式</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_14、递增分布式id的方案" class="sidebar-link">14、递增分布式ID的方案</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#项目二" class="sidebar-link">项目二</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、项目包含哪几个功能模块-简要每个模块的功能和作用" class="sidebar-link">1、项目包含哪几个功能模块？简要每个模块的功能和作用？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、网关通信会话流程如何进行编排" class="sidebar-link">2、网关通信会话流程如何进行编排</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、说明算力注册和服务发现starter的设计" class="sidebar-link">3、说明算力注册和服务发现starter的设计？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、redis服务发布订阅使用场景" class="sidebar-link">4、Redis服务发布订阅使用场景？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、编程式docker如何实现-应用场景是什么" class="sidebar-link">5、编程式Docker如何实现？应用场景是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、谈谈注册中心数据库表的设计" class="sidebar-link">6、谈谈注册中心数据库表的设计</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、如何利用spi-spring如何利用拓展点" class="sidebar-link">7、如何利用SPI？Spring如何利用拓展点？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、项目遇到的问题" class="sidebar-link">8、项目遇到的问题</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#问题一-关于netty服务端绑定的问题" class="sidebar-link">问题一：关于Netty服务端绑定的问题</a></li><li class="sidebar-sub-header level4"><a href="/pages/621a20/#问题二-服务上报的问题" class="sidebar-link">问题二：服务上报的问题</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_9、系统的性能瓶颈在哪儿" class="sidebar-link">9、系统的性能瓶颈在哪儿？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_10、netty如何实现断线重连" class="sidebar-link">10、Netty如何实现断线重连？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_11、网关高可用可以做哪些处理" class="sidebar-link">11、网关高可用可以做哪些处理？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_12、该网关与springcloud网关有什么区别" class="sidebar-link">12、该网关与springcloud网关有什么区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_13、其它系统想要接入你的网关-需要哪些步骤" class="sidebar-link">13、其它系统想要接入你的网关，需要哪些步骤?</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_14、网关为什么自研-和市面上的产品区别在哪儿" class="sidebar-link">14、网关为什么自研？和市面上的产品区别在哪儿？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_15、网关如何进行区分" class="sidebar-link">15、网关如何进行区分？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_16、rpc服务上报后协议变了-网关如何进行处理" class="sidebar-link">16、RPC服务上报后协议变了，网关如何进行处理？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_17、服务降级方案怎么进行设计" class="sidebar-link">17、服务降级方案怎么进行设计？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#其它" class="sidebar-link">其它</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、说说jwt安全认证" class="sidebar-link">1、说说JWT安全认证？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、说说github-actions如何工作" class="sidebar-link">2、说说Github Actions如何工作？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、操作系统内核的工作" class="sidebar-link">3、操作系统内核的工作</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、top指令" class="sidebar-link">4、top指令</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、lsof指令全称是什么" class="sidebar-link">5、lsof指令全称是什么</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、乐观锁悲观锁使用场景" class="sidebar-link">6、乐观锁悲观锁使用场景</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、反射违背面向对象的封装性吗" class="sidebar-link">7、反射违背面向对象的封装性吗？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_8、mybatis和mybatis-plus的区别" class="sidebar-link">8、Mybatis和Mybatis-plus的区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_9、跨域问题" class="sidebar-link">9、跨域问题</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_10、cpu中断之后进程的处理流程" class="sidebar-link">10、CPU中断之后进程的处理流程?</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_11、cas算法" class="sidebar-link">11、CAS算法？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_12、nginx负载策略" class="sidebar-link">12、Nginx负载策略</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_13、两个线程交替打印奇数偶数" class="sidebar-link">13、两个线程交替打印奇数偶数</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_14、协程" class="sidebar-link">14、协程</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_15、docker容器虚拟化技术" class="sidebar-link">15、Docker容器虚拟化技术</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_16、数组和链表在内存存储上的区别" class="sidebar-link">16、数组和链表在内存存储上的区别？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#备战" class="sidebar-link">备战</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#技术选型问题-kafka和rocketmq-网关使用netty-注册中心数据存储" class="sidebar-link">技术选型问题？kafka和RocketMQ？网关使用Netty?注册中心数据存储？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#mysql锁分类-死锁问题-事务的锁的关系" class="sidebar-link">MySQL锁分类？死锁问题？事务的锁的关系？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#spring事务-事务传播" class="sidebar-link">Spring事务？事务传播？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#设计高性能接口" class="sidebar-link">设计高性能接口</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#dubbo协议与http协议" class="sidebar-link">Dubbo协议与HTTP协议</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#孤儿进程-僵尸进程" class="sidebar-link">孤儿进程？僵尸进程？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#硬中断-软中断" class="sidebar-link">硬中断？软中断？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#jvm栈帧对象释放" class="sidebar-link">JVM栈帧对象释放</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#kafka消息到消费者是推还是拉模式" class="sidebar-link">kafka消息到消费者是推还是拉模式？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#为什么要分库-分表-如何分" class="sidebar-link">为什么要分库，分表？如何分？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#分库和分表存在的问题" class="sidebar-link">分库和分表存在的问题？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#备战2" class="sidebar-link">备战2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#什么是泛型擦除" class="sidebar-link">什么是泛型擦除？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#mybatis配置xml文件的-与-占位符有什么区别" class="sidebar-link">mybatis配置xml文件的$与#占位符有什么区别？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#消息队列可以用来做什么-mq和rpc区别是什么" class="sidebar-link">消息队列可以用来做什么？MQ和RPC区别是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#java内存泄漏-介绍一些四种引用类型" class="sidebar-link">java内存泄漏？介绍一些四种引用类型？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#java为什么不支持多继承-什么时候采用继承和组合" class="sidebar-link">java为什么不支持多继承？什么时候采用继承和组合？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#cglib和jdk动态代理之间的区别" class="sidebar-link">CGLib和JDK动态代理之间的区别</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#分布式锁的方案有哪些" class="sidebar-link">分布式锁的方案有哪些？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/621a20/#职业发展开放性问题" class="sidebar-link">职业发展开放性问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_1、个人职业规划是什么" class="sidebar-link">1、个人职业规划是什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_2、如何看待拼多多" class="sidebar-link">2、如何看待拼多多？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_3、看过哪些技术博客" class="sidebar-link">3、看过哪些技术博客</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_4、说说你从这几个项目中学到了什么" class="sidebar-link">4、说说你从这几个项目中学到了什么？</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_5、谈一下你的优缺点" class="sidebar-link">5、谈一下你的优缺点</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_6、项目中遇到的问题" class="sidebar-link">6、项目中遇到的问题</a></li><li class="sidebar-sub-header level3"><a href="/pages/621a20/#_7、开发和算法之间的选择" class="sidebar-link">7、开发和算法之间的选择</a></li></ul></li></ul></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>简历的面试问题</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>关于</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06970110><div class="articleInfo" data-v-06970110><ul class="breadcrumbs" data-v-06970110><li data-v-06970110><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06970110></a></li> <li data-v-06970110><a href="/more/#更多" data-v-06970110>更多</a></li><li data-v-06970110><a href="/more/#面试" data-v-06970110>面试</a></li></ul> <div class="info" data-v-06970110><div title="作者" class="author iconfont icon-touxiang" data-v-06970110><a href="https://github.com/blage-coding" target="_blank" title="作者" class="beLink" data-v-06970110>phan</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06970110><a href="javascript:;" data-v-06970110>2023-04-18</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">面试问题合集<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="网络"><a href="#网络" class="header-anchor">#</a> 网络</h2> <h3 id="_1、tcp三次握手和四次挥手"><a href="#_1、tcp三次握手和四次挥手" class="header-anchor">#</a> 1、TCP三次握手和四次挥手</h3> <p>三次握手：告诉对方自己报文的<strong>序列号</strong>和<strong>期望号</strong>。</p> <p>四次挥手：停止发送报文，但是仍可接收。“发送”和“回复”是<strong>异步</strong>的，因此需要四次。</p> <h4 id="为什么三次-为什么四次"><a href="#为什么三次-为什么四次" class="header-anchor">#</a> 为什么三次？？为什么四次？？</h4> <p>计算机网络复杂，具有如下特点：</p> <ul><li><p>TCP是可靠传输协议，具有超时重传等机制</p></li> <li><p>数据传输可能会出现数据包丢失，超时到达等情况</p></li></ul> <p>需要结合具体场景分析，经验证三次&amp;&amp;四次是一种比较好的做法，能够最大限度的保证数据可靠传输。（三次能够确保双方的序列号和期望号都得到确认）</p> <h3 id="_2、time-wait状态延迟关闭连接的必要性"><a href="#_2、time-wait状态延迟关闭连接的必要性" class="header-anchor">#</a> 2、TIME_WAIT状态延迟关闭连接的必要性</h3> <p>四次挥手流程：</p> <ul><li>client发给server，停止发送报文</li> <li>server发给client，收到</li> <li>server发给client，停止回复报文</li> <li>client发给server，确认。进入TIME_WAIT状态，2MSL之后才关闭连接</li></ul> <p>因此等待2个报文传输的时间，是<strong>保证server能够收到最后一个client发送的报文</strong>。（如果2MSL内client没收到任何报文，说明服务端已经接受到最后一个报文；而如果client在2MSL之内收到server发送的第三个报文，说明server没收到第四个报文，因此触发重传机制，此时client需要重新发送第四个报文）</p> <h3 id="_3、time-wait的连接数量过多"><a href="#_3、time-wait的连接数量过多" class="header-anchor">#</a> 3、TIME_WAIT的连接数量过多</h3> <p>现象：说明当前高并发短连接的TCP数量过多。每个TIME_WAIT的TCP连接都会<strong>占一个端口</strong>，不关闭会导致后来的TCP连接无法创建。</p> <p>解决：核心思路让服务端快速处理请求，快速关闭客户端的连接。比如设置减少2MSL时间，断开Nginx代理服务器连接。</p> <h3 id="_4、osi、http、url解析"><a href="#_4、osi、http、url解析" class="header-anchor">#</a> 4、OSI、HTTP、URL解析</h3> <p>物理，链路，网络，传输，会话，表示，应用</p> <p>HTTP1.1支持长连接。HTTP2.0支持新的数据压缩和编码方式。</p> <p>HTTP端口号80，而HTTPS为443。后者安全性更高，需要用到安全证书。</p> <p>URL解析：①缓存查映射（浏览器，路由器，本地）②通过DNS对URL进行解析，获取对应IP。③建立TCP连接，发起HTTP请求 ④接收服务器数据，并渲染。</p> <h3 id="_5、重定向和转发"><a href="#_5、重定向和转发" class="header-anchor">#</a> 5、重定向和转发</h3> <p>重定向：地址栏变化，初次request数据不共享</p> <p>转发：地址栏不变，服务端能共享第一次request数据</p> <h3 id="_6、cookie和session区别"><a href="#_6、cookie和session区别" class="header-anchor">#</a> 6、cookie和session区别</h3> <p>两者都用于追踪客户数据状态</p> <p>cookie存在客户端的浏览器上。而session存在服务器上</p> <h3 id="_7、dns解析的过程"><a href="#_7、dns解析的过程" class="header-anchor">#</a> 7、DNS解析的过程？</h3> <p>DNS解析过程：</p> <ol><li>首先从浏览器缓存，系统缓存查看映射</li> <li>DNS服务器会向顶级域名服务器，二级域名服务器发送请求，解析获取IP地址
<ul><li>直接查询：DNS服务器查询完A后，A返回结果，告诉要去B进行访问，然后DNS服务器就会向B请求</li> <li>间接查询：DNS查完A后，A不能解决，直接转发给B进行解析</li></ul></li></ol> <h3 id="_8、tcp拆包沾包半包问题"><a href="#_8、tcp拆包沾包半包问题" class="header-anchor">#</a> 8、TCP拆包沾包半包问题</h3> <p>拆包指接收方的缓存区大小大于一个数据包的大小，那么需要将一个完整的数据包拆分成两段进行接收和读取，从而出现沾包和半包的问题。本质上是因为没有划分数据包之间的隔离标志或是分割符导致的。</p> <h3 id="_9、tcp拥塞控制算法-tcp为什么是可靠的"><a href="#_9、tcp拥塞控制算法-tcp为什么是可靠的" class="header-anchor">#</a> 9、TCP拥塞控制算法？TCP为什么是可靠的？</h3> <p>慢开始、拥塞避免、快重传：核心就是发送方的窗口先指数级增加，如果超过了某个门限再慢慢增加，如果此时网络堵塞了，那么就减小发送窗口，重新设置为一个值。</p> <p>TCP是可靠的主要原因如下：</p> <ul><li>确认和重传机制</li> <li>流量控制：避免数据丢失</li> <li>三握四挥</li></ul> <h2 id="操作系统"><a href="#操作系统" class="header-anchor">#</a> 操作系统</h2> <h3 id="_1、分页置换算法以及代码实现"><a href="#_1、分页置换算法以及代码实现" class="header-anchor">#</a> 1、分页置换算法以及代码实现</h3> <p>FIFO：先进先出</p> <p>LRU：最近最久未使用。<font color="red"><strong>双向链表节点(value,首尾指针)+Map以O(1)复杂度访问节点</strong></font></p> <p>LFU：淘汰最不常访问的内存页，<strong>同使用次数的采用LRU策略</strong>。<font color="red"><strong>节点属性维护count使用次数+TreeMap维护次数-LRU链的缓存+Map以O(1)拿到节点的使用次数</strong></font></p> <h3 id="_2、死锁解决方法"><a href="#_2、死锁解决方法" class="header-anchor">#</a> 2、死锁解决方法</h3> <p>进程持有资源的同时竞争公共资源，造成多个进程同时等待资源释放的现象。</p> <p>解决方法：</p> <ul><li>一次性竞争和分配所有资源。不能吃着碗里的，想着锅里的</li> <li>进程之间可以剥夺共享资源</li> <li>按序请求资源</li> <li>设计超时销毁任务</li></ul> <h3 id="_3、进程之间的通信方式"><a href="#_3、进程之间的通信方式" class="header-anchor">#</a> 3、进程之间的通信方式？</h3> <p>同一台主机进程之间的通信方式如下几种：</p> <ul><li>管道通信</li> <li>消息队列</li> <li>共享内存：通过在共享内存当中，对象obj的wait方法和notify方法，控制线程之间进行通知；volatile和synchronied进行读写变量。</li></ul> <p>如果跨主机之间进行通信，则通过socket进行通信。</p> <h3 id="_4、内核态和用户态之间的区别-为什么区分两个"><a href="#_4、内核态和用户态之间的区别-为什么区分两个" class="header-anchor">#</a> 4、内核态和用户态之间的区别？为什么区分两个？</h3> <p>内核态：涉及操作系统底层和硬件资源的管理。包括内存管理、任务调度、系统管理。</p> <p>用户态：权限较低，一般只用于执行用户程序。</p> <p>区分用户态和核心态主要两个方面：</p> <ul><li>可维护性更高，便于划分功能和边界</li> <li>安全性上，防止用户程序直接调度系统资源，造成系统崩溃</li></ul> <h3 id="_5、操作系统内存管理"><a href="#_5、操作系统内存管理" class="header-anchor">#</a> 5、操作系统内存管理</h3> <p>动态分区算法：最优先匹配、最佳适应、最坏适应。</p> <p>内存淘汰算法：FIFO、LRU</p> <p>虚存技术：解决内存空间不够的问题。一部分程序先装入内存，然后另一部分装入<strong>磁盘空间</strong>，执行的时候程序不在内存，则根据地址映射从磁盘读取物理页到内存当中。</p> <h3 id="_6、进程调度"><a href="#_6、进程调度" class="header-anchor">#</a> 6、进程调度</h3> <p>进程调度算法：FIFO、最短作业优先、高响应比优先、时间片轮转、最高优先级调度。</p> <h3 id="_7、死锁的必要条件"><a href="#_7、死锁的必要条件" class="header-anchor">#</a> 7、死锁的必要条件？</h3> <p>死锁是指多个进程同时进入阻塞等待的状态，它们都在等待某个资源的释放。产生死锁的必要条件：</p> <ol><li>资源是互斥使用的</li> <li>非抢占式</li> <li>进程占有资源并等待</li> <li>循环等待</li></ol> <h3 id="_8、页表-tlb-cache的访问次数"><a href="#_8、页表-tlb-cache的访问次数" class="header-anchor">#</a> 8、页表+TLB+Cache的访问次数</h3> <p>发生缺页中断之后，执行的流程如下：</p> <ul><li>首先查看Cache有没有，如果有则直接读取。</li> <li>查看TLB快表是否命中，如果命中则根据对应的物理页地址读取到内存当中，并更新Cache</li> <li>查看页表，将数据页从磁盘读入内存当中，并更新Cache+TLB。此时总共进行了两次内存访问。</li></ul> <h2 id="java基础"><a href="#java基础" class="header-anchor">#</a> JAVA基础</h2> <h3 id="_1、三大特性-重写和重载"><a href="#_1、三大特性-重写和重载" class="header-anchor">#</a> 1、三大特性？重写和重载</h3> <p>三大特性：继承，封装，多态(方法重写)。JAVA单继承多实现</p> <p>重写：父类方法子类重写覆盖。动态绑定，根据对象类型调用执行方法</p> <p>重载：多个同名方法，按需加载形参匹配的方法，静态绑定，编译时根据形参选择方法</p> <h3 id="_2、static和final"><a href="#_2、static和final" class="header-anchor">#</a> 2、static和final</h3> <p>static：静态方法可以直接通过类名进行调用，没有this的概念，所有对象共同享有这个方法。</p> <p>静态属性则是所有类对象共享一份，通过类名直接调用和读写。</p> <p>final：final修饰的一切不能进行修改。final变量不能进行修改、final方法不能进行重写（相当于private）、final类不能被继承。</p> <h3 id="_3、hashmap的put操作-容量为什么是2的整数次幂-哈希扰动函数-红黑树的优势-死循环问题"><a href="#_3、hashmap的put操作-容量为什么是2的整数次幂-哈希扰动函数-红黑树的优势-死循环问题" class="header-anchor">#</a> 3、HashMap的put操作？容量为什么是2的整数次幂？哈希扰动函数？红黑树的优势？死循环问题？</h3> <p>哈希表核心结构为<strong>数组+链表+红黑树</strong>。put操作和对应扩容步骤如下：</p> <ol><li>根据key计算出当前数组索引</li> <li>查看该索引桶下面，是否存在key值
<ul><li>如果有，则直接将新的value进行覆盖</li> <li>没有，则需要插入新的节点，插入新的链表节点或者是红黑树节点。如果是链表需要判断是否需要转换为红黑树，同时java8采用尾插法，将整个链表按照插入顺序进行维护</li></ul></li> <li>判断整个数组的数量是否大于0.75倍，如果是则需要扩容为原来数组容量的两倍</li></ol> <h4 id="容量2的n次方"><a href="#容量2的n次方" class="header-anchor">#</a> 容量2的N次方？</h4> <p>容器扩容以及索引计算都涉及到取模运算，因此计算时，等价为与二进制全1进行与运算。</p> <p><strong>threshold=capacity * loadFactor</strong></p> <h4 id="哈希值如何计算"><a href="#哈希值如何计算" class="header-anchor">#</a> 哈希值如何计算？</h4> <p><strong>扰动函数</strong>：先获取hashcode值，然后将hashcode值高16位与低16位做异或运算，从而得以融合高位信息，减少碰撞。最后再对长度取模得到数组索引值。</p> <h4 id="说说红黑树相比其他树优势"><a href="#说说红黑树相比其他树优势" class="header-anchor">#</a> 说说红黑树相比其他树优势？</h4> <p>哈希map用红黑树存储节点：</p> <ul><li>普通二叉树：极端情况可能退化成一条链</li> <li>平衡二叉树：维护起来比较困难，旋转次数多</li></ul> <h4 id="死循环问题"><a href="#死循环问题" class="header-anchor">#</a> 死循环问题？</h4> <p>jdk1.7在头插法+多线程+插入时，可能会构造出环形链表，导致出现死循环。</p> <p>jdk1.8使用尾插法不会存在这种问题</p> <h3 id="_4、concurrenthashmap底层如何实现线程安全-get方法是否上锁"><a href="#_4、concurrenthashmap底层如何实现线程安全-get方法是否上锁" class="header-anchor">#</a> 4、ConcurrentHashMap底层如何实现线程安全？get方法是否上锁？</h3> <p>结构和HashMap一样，采用数组+链表+红黑树</p> <p>同时有多线程竞争操作同一个index下的链表/红黑树时，采用Synchronized和CAS进行并发控制:</p> <ul><li>当前数组index元素为null，则使用cas插入数据，防止初始同时有两个插入操作</li> <li>当前数组index元素不为null，则使用synchronized</li></ul> <p>get方法不会syn上锁，因为节点node是volatile修饰的，从而线程可见，防止读到脏数据。</p> <h3 id="_5、stringbuilder和stringbuffer区分"><a href="#_5、stringbuilder和stringbuffer区分" class="header-anchor">#</a> 5、StringBuilder和StringBuffer区分</h3> <p>StringBuilder效率高，但是线程不安全。后者则反之</p> <h3 id="_6、说说类内的静态初始化块执行顺序"><a href="#_6、说说类内的静态初始化块执行顺序" class="header-anchor">#</a> 6、说说类内的静态初始化块执行顺序</h3> <p>静态代码块——》初始代码块——》构造方法——》main方法</p> <p>其中静态代码块只会在该类对象第一个创建时执行一次，第二第三个对象创建时不会再执行。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>
	<span class="token keyword">static</span> <span class="token punctuation">{</span>
		<span class="token comment">//静态代码块</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">{</span>
		<span class="token comment">//初始代码块</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//构造方法</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//main方法</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_7、equals和hashcode的重写问题"><a href="#_7、equals和hashcode的重写问题" class="header-anchor">#</a> 7、equals和hashcode的重写问题？</h3> <p>讨论两个相等的概念，<strong>内容相等</strong>和<strong>引用地址</strong>相等。</p> <p>而上述讨论两个函数的重写问题，主要是为了<strong>保持“相等”这个概念的一致性</strong>。</p> <p>因为equals和hashcode默认都是比较引用地址，如果equals需要重写成内容相等，那么hashcode也需要重写，保证内容相等。</p> <h3 id="_8、java异常-throw和throws"><a href="#_8、java异常-throw和throws" class="header-anchor">#</a> 8、Java异常？throw和throws</h3> <p>Throwable分为Error和Exception。</p> <ul><li>Error错误表示用户不能处理的错误，包括虚拟机异常、内存异常等</li> <li>Exception代表可以处理的异常，包括运行时异常（空指针，数组越界），编译时异常（SQL，IO）。</li></ul> <p>throw只能在方法内部抛出异常，可以直接在方法体内处理，也可以不处理。</p> <p>throws声明抛出多个异常，在方法声明抛出，表示当前方法可能会抛出该异常，<strong>调用该方法的方法需要处理该异常，或者继续声明抛出，交给父调用处理</strong>。</p> <h3 id="_9、threadlocal介绍-内存泄露的问题"><a href="#_9、threadlocal介绍-内存泄露的问题" class="header-anchor">#</a> 9、ThreadLocal介绍？内存泄露的问题？</h3> <p>每个线程维护一个ThreadLocalMap，其中key为ThreadLocal对象，value为存储的值。</p> <p>ThreadLocal是线程隔离的，也就是每个线程根据同一个ThreadLocal对象，访问到的变量副本都是不一样的。</p> <h4 id="threadlocal的内存泄露问题"><a href="#threadlocal的内存泄露问题" class="header-anchor">#</a> ThreadLocal的内存泄露问题？</h4> <p>ThreadLocal在使用时，存在两条引用链：</p> <ul><li>Thread——》ThreadLocal：线程直接使用ThreadLocal对象，进行存储</li> <li>Thread——》<font color="red"><strong>ThreadLocalMap——》ThreadLocal</strong></font>：内部实现原理，<font color="red"><strong>其中弱引用说的是Map持有对ThreadLocal的弱引用</strong></font>。</li></ul> <p>为什么是弱引用？</p> <p>弱引用的特点：A持有B对象的弱引用，那么下一次GC回收时，B对象会被进行垃圾回收。</p> <p>如果当前线程不使用ThreadLocal对象将其置为null，则只剩下一条map对ThreadLocal的引用：</p> <ul><li>如果它是弱引用，那么它能够被自动回收</li> <li>如果它是强引用：那么虽然用户线程不使用ThreadLocal了，该对象依旧不会被回收，存在map的强引用链，从而内存泄漏</li></ul> <p>相反，value不能设置为弱引用，因为引用关系是thread通过threadLocal找到value，如果是弱引用则直接GC回收了，导致线程通过key找不到value。</p> <p>真正的内存泄露问题？</p> <p>内存溢出的本质是因为ThreadLocalMap当中，key和value强弱引用不一致导致的。当key进行回收时，剩下的value因为被map强引用，因此内存的value值在ThreadLocal不被使用后不会被回收，出现内存溢出。</p> <p>因此map内部set、get、remove方法都会对key为null的entry进行清除。当且仅当没有①threadlocal置为空 ②没有调用过上述方法 才会导致内存泄漏问题。</p> <p>所以程序需要调用remove方法删除ThreadLocal对象和value。</p> <h3 id="_10、arraylist的grow扩容过程"><a href="#_10、arraylist的grow扩容过程" class="header-anchor">#</a> 10、ArrayList的grow扩容过程？</h3> <p>添加元素时，会检查当前数组是否是满的，如果满了则需要执行grow方法扩容为原来的1.5倍。在grow方法中，会新开辟一个数组，然后将旧的数组拷贝复制过去，旧的数组在下一次gc就会被回收。</p> <h3 id="_11、hashmap链表插入方式"><a href="#_11、hashmap链表插入方式" class="header-anchor">#</a> 11、Hashmap链表插入方式</h3> <p>jdk1.7：头插法在多线程的条件下，可能会出现环形链表的情况导致死锁。</p> <p>jdk1.8：为了解决这个问题，采用<strong>尾插法</strong>避免死锁。但是多线程下还是可能会出现数据覆盖的情况。</p> <h3 id="_12、注解的底层原理"><a href="#_12、注解的底层原理" class="header-anchor">#</a> 12、注解的底层原理？</h3> <p>定义注解：指明是否是继承哪个注解、作用范围、作用对象(注解在方法还是属性)。</p> <p>所有注解都继承了Annotation这个接口，当声明好注解之后，可以通过反射，或者是AOP切面方法，拿到这个注解对象。</p> <p><strong>注解本质上是一个接口</strong>，每次我们拿到的注解对象都是<strong>代理对象</strong>；获取注解的属性值时，都会调用代理对象的属性+括号的方法。构造对象时默认参数值都存放在常量池。</p> <h3 id="_13、反射的底层机制"><a href="#_13、反射的底层机制" class="header-anchor">#</a> 13、反射的底层机制</h3> <p>java支持反射，而C++不支持反射，主要在于JVM支持根据引用，找到①堆中对象的存放地址②方法区中class类型信息。</p> <p>java通过反射技术能够动态拿到类的属性、方法、构造器等信息，并在堆中生成对应的对象，包括Class对象、Method对象等，这些属性与元空间中的类信息之间都存在索引，从而提高编程灵活性。</p> <h2 id="mysql"><a href="#mysql" class="header-anchor">#</a> MySQL</h2> <h3 id="_1、mysql四个特点-隔离级别-脏读、不可重复读、幻读"><a href="#_1、mysql四个特点-隔离级别-脏读、不可重复读、幻读" class="header-anchor">#</a> 1、MySQL四个特点？隔离级别？脏读、不可重复读、幻读？</h3> <p>MySQL四个特性包括：</p> <ul><li><p>A原子性：事务为不可分割的最小单位，要么同时操作成功，要么同时失败。实现原理是通过undo log，如果某个事务执行失败，数据库能够根据日志，撤销<font color="red"><strong>回滚</strong></font>整个事务的所有操作。</p></li> <li><p>C一致性：数据库是完整的，一致的。基于其它三个特性实现。</p></li> <li><p>I隔离性：事务之间的操作是不可见的，<font color="red"><strong>主要通过MVCC+视图数组实现事务隔离：①MVCC：每行数据都会有多个版本号(相当于事务ID)，从而支持回滚 ②视图：每个事务开启后都会创建一个事务ID视图数组，根据当前活跃事务、已提交事务、未提交事务来指定一系列规则，从而决定当前事务能够看到哪个版本号的数据，也就是数据的可见性</strong></font>。隔离级别主要包括：</p> <ul><li>读未提交：能够读到其它事务操作但是没有提交的数据</li> <li>读已提交：能够读到其它事务提交的数据，能够解决“脏读”问题。
<ul><li>原理：每个语句执行之前，都会重新构建“视图数组”，因此已提交事务，以及当前事务的更新都是可见的。</li></ul></li> <li>可重复读：同一个事务开启后，读到的数据都是不变的，解决“不可重复读”问题，刚提交的未提交的事务都读不到；<strong>解决了部分“幻读</strong>”
<ul><li>原理：开启事务时，创建一个全局的视图数组快照，后续的读都会复用第一次视图数组。</li> <li>解决部分幻读问题：①通过MVCC解决快照读出现的幻读  ②for update添加间隙锁，能够解决当前读的部分问题，但是依然存在幻读。</li></ul></li> <li>串行化：读写锁。同一个记录发生读写冲突后，只能有一个事务获取锁进行操作。后访问的事务必须等待当前事务的读锁或写锁释放，才能进行操作，解决“幻读”问题。
<ul><li>幻读：同一个事务查询语句得到的<font color="red"><strong>记录数量</strong></font>不一致。</li></ul></li></ul></li> <li><p>D持久性：提交事务后，对数据库的操作和影响是永久的。实现原理是通过redo log和bin log，保证某个数据即使因为宕机，也能进行<font color="red"><strong>数据恢复</strong></font></p> <ul><li><p>为了提高性能，在内存和磁盘之间加了一层Buffer pool，读数据和写数据不需要进行磁盘IO。但是如果系统宕机，Buffer pool没能及时更新磁盘，会导致数据丢失，因此引入了redo log，相当于账本，每次操作都会先记录在redo log，然后再对Buffer Pool操作。</p></li> <li><p>redo log：记录的是每个数据页做了什么修改，文件空间用完被覆盖</p></li> <li><p>bin log：二进制内容，记录的是SQL语句，可追加写</p></li></ul></li></ul> <h3 id="_2、mysql为什么使用b-树"><a href="#_2、mysql为什么使用b-树" class="header-anchor">#</a> 2、MySQL为什么使用B+树？</h3> <p>B+树存储索引，主要从三个方面进行叙述：</p> <ul><li>相比于B树，矮胖树三四层可以存储上亿个节点，</li> <li>同时树高比较小，根据索引查询时，<strong>IO次数少</strong>，性能高</li> <li>子节点构成一个双向链表，更擅长范围查询</li></ul> <h3 id="_3、如何建立索引-如何查看是否使用索引-最左匹配原则"><a href="#_3、如何建立索引-如何查看是否使用索引-最左匹配原则" class="header-anchor">#</a> 3、如何建立索引？如何查看是否使用索引？最左匹配原则？</h3> <p>如何建立索引：</p> <ul><li>根据where后面的字段，多字段还可以联合索引</li> <li>数据表中，属于比较独特唯一的字段属性</li> <li>有时候，还可以基于where字段+select字段建立索引，利用索引下推</li></ul> <p>explain+查询语句，其中查看key字段优化器使用了哪个索引，extra字段可能有几种情况：</p> <ul><li>using index：使用索引覆盖</li> <li>using filesort：进行排序。可能是磁盘排序，或者是内存排序</li> <li><strong>using temporary：使用临时表保存中间结果，常见group by</strong></li> <li>using join buffer：关联查询</li></ul> <p>最左匹配原则：对于查询语句where查询条件的字段，需要是联合索引字段的左边字段，才能用到索引。</p> <h3 id="_4、聚簇索引和非聚簇索引"><a href="#_4、聚簇索引和非聚簇索引" class="header-anchor">#</a> 4、聚簇索引和非聚簇索引</h3> <p>聚簇索引和非聚簇索引相对于叶子节点数据来说：</p> <ul><li>聚簇索引：叶子节点相当于找到了数据</li> <li>非聚簇索引：找到叶子节点，只是相当于找了一个指针，需要根据指针进一步查找对应的数据</li></ul> <h3 id="_5、索引什么时候会失效"><a href="#_5、索引什么时候会失效" class="header-anchor">#</a> 5、索引什么时候会失效</h3> <p>索引查询语句包含 不等于，大于，小于，不在，或，<strong>计算表达式</strong>，<strong>隐式类型转换</strong>等，则索引失效。</p> <h3 id="_6、truncate、delete、drop之间的区别"><a href="#_6、truncate、delete、drop之间的区别" class="header-anchor">#</a> 6、truncate、delete、drop之间的区别</h3> <p>drop：速度上最快，删除数据+表结构</p> <p>truncate：删除整表数据。不需要写undo log日志，因此速度比较快，但是不能回滚</p> <p>delete：删除自定义数据，可设置where条件。支持回滚</p> <h3 id="_7、join语句"><a href="#_7、join语句" class="header-anchor">#</a> 7、join语句</h3> <p>A left join B：返回A表和B表匹配的内容，对于无法匹配的行记录，保留A部分内容，B列置为空。</p> <p>法则：①尽量让join on走索引 ②小表作为驱动表，因为需要全表查询；而被驱动表尽量走索引</p> <p>整个过程：先查出驱动表的所有数据作为驱动表，然后每条数据会挨个与被驱动动比较；因此全表扫描需要是小表，被驱动表最好走索引。</p> <h3 id="_8、sql优化方案"><a href="#_8、sql优化方案" class="header-anchor">#</a> 8、SQL优化方案</h3> <p>通过explain语句查看执行情况</p> <ul><li>索引：建立新的索引（根据group by后面的内容建立索引）；使用force index使用指定索引</li> <li>语句优化：检查语句防止索引失效；limit索引优化(找到起始offset位置的数据，然后只需要where+limit count找出对应的数据，还可以通过给where添加索引)</li> <li>数据库：分库分表(分表：用户id作为路由；分库：根据业务进行拆分)，主从复制，读写分离</li></ul> <h3 id="_9、慢sql语句如何排查"><a href="#_9、慢sql语句如何排查" class="header-anchor">#</a> 9、慢SQL语句如何排查？</h3> <p>1、首先在MySQL中设置慢查询的阈值，查询时间超过这个的就算是慢查询语句。开启慢查询后会将所有慢查询语句记录在慢查询日志中。</p> <p>2、分析和优化<strong>慢查询日志</strong>当中的SQL语句，通过explain分析索引、extra字段。</p> <h3 id="_10、mysql数据类型和选用的场景"><a href="#_10、mysql数据类型和选用的场景" class="header-anchor">#</a> 10、MySQL数据类型和选用的场景</h3> <p>varchar：可变长字符串。一般用于名称、<strong>uuid</strong>、描述（InnoDB中一行数据最多是65535字节，扣除长度字段2个字节保存+NULL值列表，等于35532</p> <p>bigint：存储8个字节大小的整型数据。一般用于自增主键、业务相关的ID（比如订单号、报名号）</p> <p>tinyint：用于一些状态字段、类型字段</p> <p>datetime：时间</p> <p>decimal：存储<strong>小数</strong></p> <h3 id="_11、执行一条语句的过程"><a href="#_11、执行一条语句的过程" class="header-anchor">#</a> 11、执行一条语句的过程</h3> <ul><li>查询缓存：是否有执行过缓存的</li> <li>分析器：分析SQL语句是否符合语言规范</li> <li>优化器：生成执行策略，包括是否使用索引</li> <li>执行器：操作引擎，返回结果</li></ul> <h3 id="_12、mysql不使用跳表、b树的原因"><a href="#_12、mysql不使用跳表、b树的原因" class="header-anchor">#</a> 12、Mysql不使用跳表、B树的原因？</h3> <p>1、为什么不使用跳表：跳表是多级链表+链表的结构，从<font color="red"><strong>磁盘IO次数</strong></font>来说，跳表需要开辟额外的空间存储索引节点，因此存储相同数据的B+树磁盘IO次数比跳表的次数更加少；另外，新增数据时，跳表除了直接在底层链表插入数据外，还需要根据随机函数添加不同层级的节点指针。</p> <p>2、为什么不适用平衡二叉树、红黑树、B-树：B+树每个节点（也就是每个页）允许有更多的子节点，因此同样的数据量使用B+树存储，<strong>它的树高是最小的，查找每个数据的磁盘IO次数就是最小</strong>。</p> <p>特别地，对于B树来说，它的非叶子节点和叶子节点都会存储数据，从而导致<strong>非叶子节点能够存储的key索引更加少</strong>，因此同等数据量下只能添加树高，磁盘IO次数增加。</p> <h3 id="_13、redolog与binlog区别-两阶段提交是什么"><a href="#_13、redolog与binlog区别-两阶段提交是什么" class="header-anchor">#</a> 13、redolog与binlog区别？两阶段提交是什么？</h3> <p>redolog：循环写，记录的是当前数据页做了哪些修改，写满之后需要将数据从数据库读到内存，应用redolog刷盘同步，<strong>刷盘后的数据会从redolog删除</strong>。常用于<font color="red"><strong>恢复数据</strong></font>。</p> <p>binlog：追加写，记录的是SQL语句的逻辑操作，是一个二进制文件，常用于<font color="red"><strong>①保存数据库的历史记录②高可用主备同步</strong></font>。</p> <p>两阶段提交流程：</p> <ul><li>redolog提交进入prepare阶段</li> <li>写binlog</li> <li>redolog提交commit阶段</li></ul> <p>两阶段提交是为了保证redolog与binlog内容一致；<strong>而redolog具有crash-safe的能力，是因为binlog不能感知哪些数据已经完成刷盘，而redolog天然就记录了那些没有刷盘的数据</strong>。</p> <p>根据宕机的时刻可以分为以下几种情况，核心<strong>保证redolog和binlog一致性</strong>：</p> <ul><li>一阶段宕机：直接根据redolog中的事务id回滚</li> <li>二阶段宕机：校验binlog完整性：
<ul><li>如果binlog不完整，则直接根据redolog的事务id进行回滚</li> <li>如果binlog完整，根据binlog恢复redolog日志</li></ul></li></ul> <p>输盘时机：</p> <ul><li><p>redolog写满了之后提交</p></li> <li><p>双一配置：每次事务提交后，都会将内存的redolog和binlog进行刷盘，至少两次磁盘IO次数。</p></li> <li><p>因此后续提出了组提交，多个事务都合并为一次进行日志刷盘。</p></li></ul> <h3 id="_14、mysql的刷盘机制"><a href="#_14、mysql的刷盘机制" class="header-anchor">#</a> 14、MySQL的刷盘机制？</h3> <p>MySQL刷盘主要分为两种：</p> <ul><li>数据刷盘：将Buffer Pool当中的脏页刷盘持久化，其中触发刷盘的时机<strong>①redolog写满了 ②buffer pool写满需要内存淘汰</strong>。其中可以修改两个参数，一个是刷盘速度，另一个是<strong>脏页连带数量</strong>。</li> <li>日志刷盘：两阶段提交。</li></ul> <h2 id="juc并发"><a href="#juc并发" class="header-anchor">#</a> JUC并发</h2> <h3 id="_1、volatile保持内存可见性"><a href="#_1、volatile保持内存可见性" class="header-anchor">#</a> 1、volatile保持内存可见性</h3> <p>volatile修饰的变量多线程可见，核心机制：</p> <ul><li>底层防止指令重排：保证代码按序执行。单线程没有问题，多线程数据依赖问题可能会出错</li> <li>内存屏障：保障不同线程见到的变量都是最新的变量值，内存可见性。底层通过嗅探技术，保证线程内存和系统内存的变量值都是一致的，一旦某个线程改了这个值，那么其它线程内存的副本会直接失效。</li></ul> <h3 id="_2、synchronized底层实现-如何获取锁-锁升级"><a href="#_2、synchronized底层实现-如何获取锁-锁升级" class="header-anchor">#</a> 2、synchronized底层实现？如何获取锁？锁升级</h3> <p>实现：通过monitor监视对象实现。</p> <p>正常获取锁流程（轻量级锁）：每个对象的对象头中<strong>mark word</strong>存放锁的状态信息。当线程A获取该对象的锁时，会进行两个操作：</p> <ul><li>复制对象头的mark word字段到当前线程栈帧</li> <li>通过CAS，将对象的mark word改为指向当前线程栈帧的指针</li> <li>底层是通过monitor对象实现，每个锁都对应一个monitor对象，线程进入syn时需要竞争获取这个monitor对象，<strong>本质上就是判断monitor对象的owner字段是不是当前线程</strong>。</li></ul> <p>锁升级分为如下几个步骤：</p> <ul><li>偏向锁：锁偏向于第一个获取该对象的线程，同一个线程多次访问不需要重复CAS，直接保存线程ID</li> <li>轻量级锁：同上采用CAS机制，其它锁竞争时会自旋轮询CAS，响应时间快。释放锁时，如果CAS失败说明同时有其它线程竞争锁，锁升级为重量级锁。</li> <li>重量级锁：其它线程竞争锁失败，直接挂起，直到线程释放重量级锁，唤醒通知其它所有线程。吞吐量高，但是需要线程上下文切换，响应时间低。</li></ul> <h3 id="_3、谈谈reentrantlock-和synchronized对比"><a href="#_3、谈谈reentrantlock-和synchronized对比" class="header-anchor">#</a> 3、谈谈ReentrantLock？和Synchronized对比？</h3> <p>ReentrantLock特性：</p> <ul><li>可重入锁：拿到锁的线程能够重复进入公共代码段执行，能够再次调用lock方法进入同步块。实现方法是在tryAcquire中，通过API判断当前线程是否是获取锁的线程，如果是则tryLock成功，计数器加一，否则失败。</li> <li>排他性：同一时刻只能有一个线程获取锁。</li> <li>公平或非公平：获取锁的顺序与线程请求tryLock的顺序保持一致，默认非公平锁实现。
<ul><li>公平：判断AQS同步队列当中，当前节点是否有前驱节点。如果是首节点才能CAS</li> <li>非公平：加入同步队列后，直接进行CAS，<strong>因此后加入的节点也可能CAS成功</strong>，也就是非公平</li> <li>非公平锁性能高于公平锁的地方在于，非公平锁线程挂起和唤醒的开销要小于公平锁。</li></ul></li></ul> <p>两者有如下不同：</p> <ul><li>Reen需要显示编程获取锁和释放锁，而Syn隐式获取锁，线程执行完同步块后自动释放锁</li> <li>Reen只能在代码块内使用，lock方法；而synchronized可以加在代码块，方法上。</li> <li>两者都是可重入锁，前者是计数器机制，后者是偏向锁机制。</li> <li>Reen是公平或非公平。而Syn是非公平锁</li> <li>Reen是通过AQS同步器实现，而Synchronized通过JVM监视器实现</li></ul> <h3 id="_4、线程池参数-核心线程数设置"><a href="#_4、线程池参数-核心线程数设置" class="header-anchor">#</a> 4、线程池参数？核心线程数设置？</h3> <p>七大线程池参数：</p> <ul><li>核心线程数</li> <li>最大线程数</li> <li>阻塞队列类型：优先级队列（先来后到，优先级大小）、有界队列（限定阻塞队列的大小，很多阻塞队列因为高并发场景，造成任务堆积，如果是无界则内存溢出，系统不可用）</li> <li>拒绝策略：①丢弃当前任务 还是 丢弃队列中的任务 ②是否抛出异常</li> <li>存活时间：空闲线程不接到任务，经过多久会自行释放。核心线程数不释放</li> <li>时间单位</li> <li>线程工厂</li></ul> <p>整个流程如下：</p> <ol><li>如果当前线程数小于核心线程数，则直接创建（获取全局锁）</li> <li>大于核心线程数，则先加入阻塞队列</li> <li>如果阻塞队列任务满了，则创建新的线程（获取全局锁），从队列取出任务，并执行</li> <li>当前线程数超过最大线程数，则直接拒绝任务</li></ol> <p>如果CPU核心数是N，则根据不同任务类型设置核心线程数：</p> <ul><li>计算型任务：CPU一直在运行，直接设置为N+1</li> <li>IO任务：线程需要等待数据，一个线程可能会占据大量时间，为了充分利用CPU资源，设置为2N+1</li> <li>混合型任务：如果分成的两个IO和计算时间相当，可以分别设置两个线程池处理对应的任务。</li></ul> <h3 id="_5、创建线程的方法"><a href="#_5、创建线程的方法" class="header-anchor">#</a> 5、创建线程的方法？</h3> <p>定义任务：①实现Runnable接口方法 ②实现Callable方法，任务方法需要有返回类型</p> <p>通过new Thread创建一个新的线程，然后传入任务，调用线程start方法线程进入运行态</p> <h3 id="_6、obj-wait、thread-join、thread-sleep的区别"><a href="#_6、obj-wait、thread-join、thread-sleep的区别" class="header-anchor">#</a> 6、obj.wait、thread.join、thread.sleep的区别？</h3> <p>obj.wait：事件通知机制。需要使用一个中间对象obj来实现线程之间的通知机制，</p> <p>thread.join：当前线程调用threadb.join方法后，当前线程会被阻塞，直到b线程终止，才会唤醒当前线程</p> <p>thread.sleep：线程进入等待状态，隔某段时间后自动唤醒</p> <h3 id="_7、说说cas思想-缺点是什么-如何解决"><a href="#_7、说说cas思想-缺点是什么-如何解决" class="header-anchor">#</a> 7、说说CAS思想？缺点是什么？如何解决？</h3> <p>CAS：比较和交换。通过版本号的思想，对一个共享变量进行操作和维护。</p> <p>缺点如下：</p> <ul><li>ABA问题，java底层提供并发包，解决版本号问题</li> <li><strong>多个变量的共享读写操作</strong>，不能通过CAS，需要通过锁</li> <li>高并发条件下，CAS容易失败，系统轮询开销大</li></ul> <h3 id="_8、什么时候使用cas和悲观锁"><a href="#_8、什么时候使用cas和悲观锁" class="header-anchor">#</a> 8、什么时候使用CAS和悲观锁？</h3> <p>低并发情况下使用CAS，提高并发度。</p> <p>高并发情况下使用悲观锁，因为CAS轮询开销比较大。</p> <h2 id="jvm内存"><a href="#jvm内存" class="header-anchor">#</a> JVM内存</h2> <h3 id="_1、jvm内存分配-一个对象从创建到gc的整个过程"><a href="#_1、jvm内存分配-一个对象从创建到gc的整个过程" class="header-anchor">#</a> 1、JVM内存分配？一个对象从创建到GC的整个过程？</h3> <p>内存主要分为几个区域：</p> <ul><li>方法区：存放类的静态变量，静态代码块，常量池。</li> <li>堆：存放对象实例。这个区域是共享的</li> <li>线程栈：线程私有的，存放执行方法的栈帧，本地变量</li> <li>方法栈：执行外部native方法</li> <li>程序计数器：线程隔离</li></ul> <p>对象从创建到消亡整个流程：</p> <ul><li>执行类加载过程</li> <li>进行JVM堆内存分配：
<ol><li>对象加入Eden区，如果对象过大，则直接加入老年代Old区。（减少Eden到S区之间对象拷贝的开销）</li> <li>Eden区满了，进行一次Minor GC，把对象拷贝到S区，然后计数器加一。每进行一次Minor GC都会加一，直到到达15，则将对象从S区加入到Old代</li> <li>直到Full GC</li></ol></li> <li>在堆中，初始化对象的属性字段为零值</li> <li>栈帧指向堆内存空间</li></ul> <h3 id="_2、双亲委派机制-如何破坏"><a href="#_2、双亲委派机制-如何破坏" class="header-anchor">#</a> 2、双亲委派机制？如何破坏？</h3> <p>双亲委派机制核心如下：</p> <ul><li>自底向上委托：由子类向父类自底向上<font color="red"><strong>委托父类的loadclass方法处理</strong></font></li> <li>自顶向下加载：再自顶向下负责加载该类，如果当前类加载器不能加载，则交给子类加载器</li></ul> <p>主要分为客户自定义类加载器-》应用类加载器-》拓展类加载器-》启动类加载器。双亲委派机制的意义在于，能够保证代码<strong>安全</strong>，特别是核心代码实现，防止核心代码被篡改。</p> <h4 id="双亲委派机制破坏"><a href="#双亲委派机制破坏" class="header-anchor">#</a> 双亲委派机制破坏？</h4> <p>①破坏类加载器：自定义类加载器，直接重写类方法loadClass</p> <p>②Tomcat进行类加载时，绕开了Application应用加载器，直接交给ext进行加载。</p> <p>③SPI机制以及JDBC：因为外部的实现类在第三方jar包指定的路径下，而这只能由应用类加载器负责，启动类委托应用类加载器则会导致整个委托关系倒置，因此JDK进行妥协，搞了一个上下文类加载器</p> <h3 id="_3、如何判断一个对象是不是垃圾"><a href="#_3、如何判断一个对象是不是垃圾" class="header-anchor">#</a> 3、如何判断一个对象是不是垃圾？</h3> <p>存活算法如下：</p> <ul><li>引用计数法：每个对象如果被栈帧应用，则引用计数加一，否则减一。该方法不能解决循环依赖问题，如果两个对象相互引用，那么引用计数永远不会变为零，导致两个垃圾对象不能被标记</li> <li>根可达性算法：根据GC ROOT向下搜索每个对象的引用关系，如果某一个对象根据GC ROOT的搜索链找不到该对象，那么判定为垃圾对象。（GC ROOT包括虚拟机栈，方法区的静态块，常量池）</li></ul> <h3 id="_4、垃圾回收算法有哪些"><a href="#_4、垃圾回收算法有哪些" class="header-anchor">#</a> 4、垃圾回收算法有哪些？</h3> <p>常见三种垃圾回收算法：</p> <ul><li>标记清除法：将垃圾对象标记出来，然后单独对标记的内存空间进行GC回收。缺点在于存在内存碎片。</li> <li>标记压缩法：将存活对象统一移动到JVM的一端，然后可以直接清除回收其它的空间。</li> <li>内存复制法：整个JVM只使用一般的内存空间创建对象，垃圾回收时，将一半内存当中<strong>存活的对象复制</strong>到另一半的内存（复制的存活对象在另一半内存空间可以是连续的），然后直接回收整个一半的内存空间。缺点在于浪费空间，且效率低。</li></ul> <p>其中对于新生代和老年代而言：</p> <ul><li>新生代使用复制算法更优：①频繁GC，需要减少内碎。②每次存活对象比较少，复制代价低。</li> <li>老年代使用标记算法更优：①复制代价比较大 ②每次死亡对象比较少</li></ul> <h3 id="_5、垃圾回收器有哪些"><a href="#_5、垃圾回收器有哪些" class="header-anchor">#</a> 5、垃圾回收器有哪些？</h3> <p>垃圾回收器：控制GC线程进行垃圾回收，减少对JVM正在运行线程的干预。减少STW状态</p> <p>区分新生代老年代的垃圾回收器：</p> <ul><li><p>串行化垃圾回收器：只用一个GC线程，执行垃圾回收工作。缺点在于，垃圾回收效率比较低</p></li> <li><p>并行垃圾回收器：使用多个GC线程，执行垃圾回收算法。</p></li> <li><p>上面两种垃圾回收器，在GC线程在执行垃圾回收时，都需要进入STW状态冻结其它JVM正在运行线程，因此后续有提出了CMS：</p></li> <li><p>CMS垃圾回收器：<font color="red"><strong>核心思路是让GC线程与用户线程执行并行执行</strong></font>。具体做法分为一下几个步骤：</p> <ol><li>STW：标记出GC ROOT直接关联对象</li> <li>并行阶段，所有被标记的对象执行根可达算法，找出所有垃圾对象</li> <li>STW：重新标记出上一个阶段当中，工作线程新产生的垃圾对象</li> <li>并行回收所有垃圾对象（缺点因为是并行执行垃圾回收，该过程产生的浮动垃圾对象只能交给下一个阶段回收）</li></ol></li></ul> <p>不区分新生代老年代的垃圾回收器：</p> <ul><li>G1：将整个内存分块，每次GC回收“垃圾对象”最多的区域</li></ul> <h3 id="_6、什么是三色标记法-如何解决错标和漏标"><a href="#_6、什么是三色标记法-如何解决错标和漏标" class="header-anchor">#</a> 6、什么是三色标记法？如何解决错标和漏标？</h3> <p>三色标记法：用于解决CMS垃圾回收器的标记算法。包括黑(对象+子属性均标记完)、灰(对象标记完，子属性没有标记)、白(都没有标记)。<font color="red"><strong>标记完毕后，如果还是白色，说明是垃圾对象</strong></font>。</p> <p>漏标记：正常被引用的对象，没有被标记导致被垃圾对象清除。解决：二次STW重新标记阶段</p> <h3 id="_7、minor-gc"><a href="#_7、minor-gc" class="header-anchor">#</a> 7、minor GC</h3> <p>每次执行根可达算法，将S0区的存活对象复制到S1区当中，回收S0区的垃圾对象。下一次Minor GC则会来回执行这个过程。</p> <h3 id="_8、类加载流程"><a href="#_8、类加载流程" class="header-anchor">#</a> 8、类加载流程</h3> <ul><li>加载：将类的二进制字节流文件加载进虚拟机，转换成数据结构，通过类加载器</li> <li>验证：校验字节流文件是否符合规范</li> <li>准备：为类变量，也就是静态变量，在<strong>方法区中开辟空间</strong>并设置初始零值</li> <li>解析：将符号引用转化为直接引用；执行的时候找到类变量和方法的偏移量，从而能够调用找到对象的位置。</li> <li>初始化：初始化类变量</li></ul> <h3 id="_9、对象什么时候跑到堆外面"><a href="#_9、对象什么时候跑到堆外面" class="header-anchor">#</a> 9、对象什么时候跑到堆外面？</h3> <p>经过对象的逃逸分析之后，如果判断对象没有发生逃逸（全局逃逸，参数逃逸），对象的应用没有跑到静态变量、方法返回值，那么就可能采用栈上分配进行优化。</p> <p>对象分配到栈上。随着栈帧出栈，方法结束会将对象进行销毁。</p> <h3 id="_10、cms垃圾回收器-g1垃圾回收器-zgc垃圾回收器-使用场景"><a href="#_10、cms垃圾回收器-g1垃圾回收器-zgc垃圾回收器-使用场景" class="header-anchor">#</a> 10、CMS垃圾回收器？G1垃圾回收器？ZGC垃圾回收器？使用场景</h3> <p>CMS：concurrent mark sweep 并发标记清理，<strong>CMS属于老年代的垃圾回收器</strong>，需要配合新生代的垃圾回收器使用。</p> <ul><li>初始阶段：暂停所有线程，标记GC root相关节点</li> <li>并发标记：GC线程执行根可达算法，标记出所有可达对象</li> <li>重新标记：暂停所有线程，重新标记出并行阶段新产生的垃圾对象</li> <li>并发清除：执行垃圾回收算法。可能会出现浮动垃圾</li></ul> <p>G1：Garbage-First ，适用于服务器的垃圾回收器，适用于产生内碎比较多、<strong>需要可控的GC停顿时间</strong>。采用<font color="red"><strong>标记—复制</strong></font>算法。</p> <ul><li><strong>时间预测模型</strong>，并在后台维护了一个优先列表，<strong>每次根据给定时间</strong>，选择价值最高的region进行回收</li> <li>整体上基于标记-压缩算法，较少内存的内碎。</li></ul> <p>ZGC：<strong>适用于低延迟，对响应时间要求比较高的场景,比如证券系统</strong>。采用<font color="red"><strong>标记--复制</strong></font>算法，STW阶段停顿时间非常低，大多数阶段与用户线程并发执行。采用染色指针和读屏障实现并发标记、并发转移阶段(<strong>G1的转移阶段是完全STW的</strong>)。</p> <h3 id="_11、jdk1-8默认使用什么垃圾回收器"><a href="#_11、jdk1-8默认使用什么垃圾回收器" class="header-anchor">#</a> 11、jdk1.8默认使用什么垃圾回收器？</h3> <p>新生代和老年代默认都使用<strong>并行垃圾回收器</strong>。jdk1.8优先选择“<strong>吞吐量</strong>”，也就是处理GC的时间越短越好；而CMS则追求“<strong>响应时间</strong>”，选择GC程序与用户程序并发执行。</p> <h2 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h2> <h3 id="_1、说说redis、memcache、guava-caffeine"><a href="#_1、说说redis、memcache、guava-caffeine" class="header-anchor">#</a> 1、说说Redis、Memcache、Guava/Caffeine</h3> <p>Redis：分布式缓存：支持多种数据结构，包括跳表、zset、位图；支持持久化、集群部署</p> <p>Memcache：分布式缓存数据库；存在内存；仅支持存储key-value数据；<font color="red"><strong>不支持持久化</strong></font></p> <p>Guava/Caffeine：本地缓存，多个节点使用一份缓存数据；占用服务器的堆内存；<font color="red"><strong>当微服务水平部署多个实例时，对应也要创建新的缓存，因此不具有一致性</strong></font>；具有定时释放、缓存过期、<strong>淘汰机制</strong></p> <h3 id="_2、redis数据类型有哪些-sds和跳表"><a href="#_2、redis数据类型有哪些-sds和跳表" class="header-anchor">#</a> 2、Redis数据类型有哪些？SDS和跳表？</h3> <p>Redis数据结构如下：</p> <ul><li><p>String</p></li> <li><p>Hash哈希表：适合存储对象数据，如购物车</p></li> <li><p>List列表：按插入顺序进行排序</p></li> <li><p>Set集合：数据不可重复，适合进行集合操作比如并集、交集等；比如朋友关系</p></li> <li><p>Zset集合：有序集合，每个元素会设置一个分数；如排名</p></li> <li><p>HyperLogLog</p></li> <li><p>Bitmap：位图，可以用于统计用户签到：key为某天日期，offset为对应用户id(第几个用户)，因此根据key拿到的二进制非零位数为对应当天活跃用户数量；然后某段时间则取出连续key的结果进行与操作；另外，反过来，位图的长度可以代表用户的长度，key代表用户id，offset代表第几天，第几天打卡则置为1</p></li></ul> <p><strong>动态字符串SDS</strong>：</p> <ul><li>字符串内存分配采用预分配和懒删除：分配空间时多分配几个连续空间地址，这样下次分配的时候就不用重新分配；删除时只会进行标记，并不会实际释放对应的内存空间，（这样下次使用的时候就不用重新分配）</li> <li>空间长度大小：直接记录length值，O(1)获取</li></ul> <p><strong>跳表</strong>：</p> <ul><li>不同层次的链表的长度不同，最底层链表的长度最长，跨度最低；每层的链表都是有序的；节点除了指向当前层次的下一个节点外，还会有一个指针指向更低层次链表的指针。</li> <li>跨度越高，链表节点越少；如果当前查询节点大小在当前节点和下一个节点之间，那么则进入下一个更低层次的链表进行搜索。时间是logn</li></ul> <h3 id="_3、redis持久化机制"><a href="#_3、redis持久化机制" class="header-anchor">#</a> 3、Redis持久化机制？</h3> <p>Redis持久化分为两种：</p> <ul><li>RDB：每隔一段时间持久化当前Redis数据。适合用于<strong>备份</strong>数据；但是可能会丢失数据；通过bgsave会fork一个子进程，并不会阻塞主线程</li> <li>AOF：追加写，文件较大，因此启动时耗时较长；每执行一次指令都会追加写AOF文件；适合用于<strong>数据恢复</strong>；不同于redo log，AOF是执行完指令之后才进行复制重写，不会阻塞指令的执行，但是可能会造成数据丢失</li></ul> <h3 id="_4、redis内存淘汰策略-过期策略"><a href="#_4、redis内存淘汰策略-过期策略" class="header-anchor">#</a> 4、Redis内存淘汰策略?过期策略？</h3> <p>内存淘汰策略：LRU，LFU，FIFO</p> <p>过期策略：</p> <ul><li>周期删除：定期删除缓存的过期key</li> <li>惰性删除：过期了不删除，仅在下一次使用时判断是否过期再进行删除。因此如果过期并且不再使用，则导致内存空间浪费</li></ul> <h3 id="_5、缓存穿透、缓存击穿、缓存雪崩-对应解决方法"><a href="#_5、缓存穿透、缓存击穿、缓存雪崩-对应解决方法" class="header-anchor">#</a> 5、缓存穿透、缓存击穿、缓存雪崩？对应解决方法？</h3> <p>Redis生产问题(保证高可用)：</p> <ul><li>缓存穿透
<ul><li>问题：内存和数据库都不存在对应数据，请求打到数据库造成崩溃。</li> <li>解决：①缓存无效数据，key-null，并设置对应TTL过期时间 ②设置布隆过滤器，本质上是通过哈希映射+数组，如果数组不存在则说明一定不存在缓存或者数据库；如果布隆数组存在则说明可能存在也可能不存在，取决于哈希算法和数组长度。</li></ul></li> <li>缓存击穿
<ul><li>问题：大量<strong>热点key失效</strong>，请求打穿redis直达数据库。</li> <li>解决：①热点key设置较长过期时间，或者是不设置过期时间。②缓存预热，提前将热点数据通过定时任务加到缓存 ③数据库访问设置互斥锁，并设置写回策略。</li></ul></li> <li>缓存雪崩
<ul><li>问题：大量key同时失效</li> <li>解决：①每个不同的key设置不同随机的过期时间 ②服务降级限流</li></ul></li></ul> <h3 id="_6、热点key问题"><a href="#_6、热点key问题" class="header-anchor">#</a> 6、热点key问题？</h3> <p>热点key：同时有大量请求线程打到redis的热点key上，可能成为redis的系统瓶颈。占用系统带宽</p> <p>解决方案：</p> <ul><li>建立集群，将热点key打散到多个redis节点当中</li> <li>设置热点key多级缓存，本地缓存&gt;&gt;redis&gt;&gt;数据库</li> <li>读写分离：建立主从redis节点，同一个热点key进行读写操作分离</li></ul> <h3 id="_7、大key问题"><a href="#_7、大key问题" class="header-anchor">#</a> 7、大key问题？</h3> <p>大key问题：redis缓存的key占用内存空间过大，导致对key操作时比较影响系统性能。</p> <p>解决方案：</p> <ul><li>重新选择redis合适的数据类型和数据结构</li> <li>把大key拆分成多个小key分别存储</li></ul> <h3 id="_8、如何保证数据库和缓存一致性"><a href="#_8、如何保证数据库和缓存一致性" class="header-anchor">#</a> 8、如何保证数据库和缓存一致性？</h3> <p>对于Redis缓存，我的理解是，它的引入主要是为了解决AP问题，帮数据库分担流量，保证系统可用，因此客观上来说，缓存和数据库出现不一致的问题是无法避免的。</p> <p>而造成缓存和数据库不一致的问题，本质上是因为系统对数据库和缓存读写操作并不是原子性的，同时多线程环境下程序执行顺序不可控，比较常用的一种读写方案如下：</p> <ul><li>更新：先更新数据库，然后再删除缓存。对于删除数据操作失败导致的脏读，如果要求强一致性，那么可以将这两个操作放在一个事务中。</li> <li>读操作：先读缓存，然后再读数据库；如果缓存没有，需要从数据库将数据更新到缓存，同时设置过期时间。</li></ul> <p>无论通过什么方法，我们都可以通过其它一些手段尽可能保证操作流程执行成功，包括：设置兜底逻辑、定时任务重试机制、</p> <h3 id="_9、redis的主从模式、哨兵模式"><a href="#_9、redis的主从模式、哨兵模式" class="header-anchor">#</a> 9、Redis的主从模式、哨兵模式？</h3> <p>主从模式：一主多从。主节点负责写操作，同时将节点信息更新到其它从节点，从节点负责读操作。</p> <p>哨兵模式：在主从模式下，主节点因为数据同步压力大节点宕机，此时哨兵节点会执行如下操作：</p> <ul><li>判断主节点是否下线：监听主节点的哨兵节点会定时发送ping指令，利用心跳检测判断节点是否存活；其它哨兵节点会向监控该节点的哨兵节点进行确认（因为也有可能是哨兵节点宕机了），从而最终判断主节点是否真的下线。</li> <li>监视这个主服务的所有哨兵节点，会执行<strong>Raft算法</strong>，选举出一个新的leader 哨兵节点：
<ul><li>初始化每个节点都是跟随者节点，初始化Term计时器置为0</li> <li>某个节点超时后，会成为候选节点，首先给自己投一票，并向其它节点发送投票申请</li> <li>其它追随者节点会向发送第一个请求的候选者投票，获得超过半数支持的候选者会成为领导者。</li></ul></li> <li>哨兵leader，会根据优先级、复制偏移量等规则，从从节点当中选出主节点。</li></ul> <p>集群模式：水平拓展；数据分片</p> <h3 id="_10、基于redis能够做什么"><a href="#_10、基于redis能够做什么" class="header-anchor">#</a> 10、基于Redis能够做什么？</h3> <ul><li>内存数据库</li> <li>发布通知订阅</li> <li>分布式锁：①使用setnx ②使用redisson
<ul><li>SETNX：设置一个key和超时释放时间。不存在则设置成功，并返回1；若已存在则设置失败（获取锁失败），返回0。整个查看key以及判断key的操作都是原子的。</li></ul></li></ul> <h3 id="_11、谈谈redis的单线程模型"><a href="#_11、谈谈redis的单线程模型" class="header-anchor">#</a> 11、谈谈Redis的单线程模型？</h3> <p>Redis里面说的单线程模型，指的是接受连接-》解析事件-》事件执行-》响应  这条链路是单线程的，而其它模块，包括持久化、连接关闭等都是另外启一个线程执行。</p> <p>而Redis单线程快的原因，主要是两点：</p> <ul><li>基于内存操作，所以肯定很快。CPU不是瓶颈，因此采取单线程。</li> <li>它是利用IO多路复用，处理客户端连接时，不会阻塞服务端线程；避免使用多线程模型导致的线程上下文切换。</li></ul> <p>具体来说，只创建一个服务端线程（相当于一个IO多路复用程序），负责监听多个套接字的连接请求和数据请求。当套接字的数据准备好后，会轮询执行每个套接字，比如问套接字1好了没，好了就丢给事件分发器，分别处理对应的读事件或者是写事件，然后再问第二个套接字，以此类推。</p> <p>IO多路复用程序分为以下几种：</p> <ul><li>select：只能监听1024个套接字</li> <li>poll：可以监听任意数量的套接字</li> <li>epoll：监听任意数量套接字，并且轮询时只会执行准备好的套接字</li></ul> <h3 id="_12、redis如何设置持久化模式"><a href="#_12、redis如何设置持久化模式" class="header-anchor">#</a> 12、redis如何设置持久化模式</h3> <p>在redis.conf这个文件中进行配置</p> <h3 id="_13、redis刷新策略"><a href="#_13、redis刷新策略" class="header-anchor">#</a> 13、redis刷新策略</h3> <p>1.内存刷新策略：fifo，lru，lfu</p> <p>2.过期刷新策略：周期式，懒汉式</p> <p>3.数据库缓存不一致导致的主动刷新：先改数据库，然后删除缓存</p> <h3 id="_14、redisson如何加锁保证原子性"><a href="#_14、redisson如何加锁保证原子性" class="header-anchor">#</a> 14、redisson如何加锁保证原子性？</h3> <p>redisson实现分布式锁，主要是通过redis+lua脚本实现，封装了加锁的API，通过lua脚本获取锁，<strong>看门狗机制</strong>保证不会死锁。</p> <h3 id="_15、setnx有哪些风险"><a href="#_15、setnx有哪些风险" class="header-anchor">#</a> 15、setnx有哪些风险</h3> <p>1、redis主从同步时，主节点中A用户拿到锁之后突然宕机，此时锁占有没来及同步给从节点，导致从节点变为主节点后，其它的节点重新竞争锁。</p> <p>2、setnx+expire实现分布式锁时，如果过期时间设置过短，<strong>当前业务流程执行时间长，就可能导致当前A线程还没执行完自己的业务，分布式锁就自动释放</strong>。B线程获取锁执行时，A线程执行完后误删了B线程的锁，从而导致不可控的并发问题。解决方法：通过redisson的<strong>看门狗机制</strong>，观察如果客户端线程还持有锁，则续上超时时间。</p> <h3 id="_16、redis一致性hash"><a href="#_16、redis一致性hash" class="header-anchor">#</a> 16、redis一致性hash</h3> <p>一致性hash算法用来解决分布式场景下数据存储的问题。</p> <ul><li>索引计算：不同于直接对机器数量取模，索引计算直接对2^32-1取模。</li> <li>哈希环：key-value和机器都会进行索引计算，映射到哈希环上的某个位置</li> <li>每个节点顺序存储在顺时针方向第一个机器节点</li> <li>容错性和数据倾斜：
<ul><li>节点机器数量改变时，只会影响到部分节点数据</li> <li>通过虚拟节点解决数据倾斜的问题(大部分数据放到一个节点)，同一个机器节点计算多个虚拟节点放入哈希环当中，实际数据存储的位置为虚拟节点对应的物理节点。</li></ul></li></ul> <p>实际redis集群没有使用，而是采用哈希槽。一致性hash可以在客户端实现。</p> <h2 id="消息队列"><a href="#消息队列" class="header-anchor">#</a> 消息队列</h2> <h3 id="_1、介绍kafka中的topic、partition、replica"><a href="#_1、介绍kafka中的topic、partition、replica" class="header-anchor">#</a> 1、介绍kafka中的topic、partition、replica？</h3> <p>除了正常生产者和消费者外，kafka如下概念：</p> <ul><li>broker：相当于kafka消息队列实例，多个broker组成集群</li> <li>topic：订阅者监听的通道</li> <li>partition分区：每个topic下都会有多个分区，相当于队列的概念。其中多个分区不一定都在同一个broker，<font color="red"><strong>因此多分区可以提供负载均衡功能，监听同一个topic的多个消费者可以负载到多个不同的kafka节点(broker)进行消费</strong></font>。</li> <li>replica副本：<strong>每个分区都会有多个副本，副本分为一个leader多个follower</strong>。多个副本相当于提供了消息的高可用机制，某个分区节点的消息丢失，可以通过该分区的其它follower进行复制。</li></ul> <h3 id="_2、kafka与zookeeper之间的关系"><a href="#_2、kafka与zookeeper之间的关系" class="header-anchor">#</a> 2、kafka与zookeeper之间的关系</h3> <p>zookeeper相当于一个注册中心，它为kafka提供以下服务：</p> <ul><li>broker消息队列节点注册</li> <li>topic注册</li> <li>分区注册</li> <li><font color="red"><strong>负载均衡</strong></font></li></ul> <h3 id="_3、kafka如何保证消息的顺序消费"><a href="#_3、kafka如何保证消息的顺序消费" class="header-anchor">#</a> 3、kafka如何保证消息的顺序消费？</h3> <p>在kafka中，同一个队列（partition分区）的消息天然保证顺序性，通过offset维护。</p> <p>因此实现消息顺序消费的关键在于，保证生产者生产的消息能够顺序发送到同一个分区中：</p> <ul><li>每个topic只设定一个分区</li> <li>生产者发送消息时，指定topic的同时，还需要指定partition</li></ul> <h3 id="_4、kafka如何保证消息不会丢失"><a href="#_4、kafka如何保证消息不会丢失" class="header-anchor">#</a> 4、kafka如何保证消息不会丢失？</h3> <p>保证消息不丢失从三个方面考虑，以kafka为例：</p> <ul><li>发送端：生产者发送消息后，设置回调函数，当broker收到消息之后触发回调函数，才能确保消息发送到kafka</li> <li>kafka端：broker节点可能会突然宕机，导致消息没能持久化。解决办法：利用副本replica“集群”的特点，设置多组副本。(牺牲性能换取安全性)；设置<strong>acks=all</strong>，确保所有副本都受到消息之后，才触发生产者的回调。</li> <li>消费者端：<strong>关闭自动提交offset给broker</strong>，仅当消费者处理完消息之后，才会手动提交offset。另一种方法是，消费者收到消息之后，马上提交offset，然后通过异步+重试的方法消费消息。</li></ul> <h3 id="_5、kafka如何保证消息的幂等性消费"><a href="#_5、kafka如何保证消息的幂等性消费" class="header-anchor">#</a> 5、kafka如何保证消息的幂等性消费？</h3> <p>破坏幂等性的原因只要在于，offset没能提交，因此主要解决方案：</p> <ul><li>消费者消息利用mysql主键、redis的key 这些天然幂等性的属性进行校验</li> <li>拿到消息后马上提交offset，然后异步做数据兜底。</li></ul> <h3 id="_6、谈谈死信队列"><a href="#_6、谈谈死信队列" class="header-anchor">#</a> 6、谈谈死信队列</h3> <p>kafka内部支持重试机制，消息消费失败默认重复消费，超过重试次数后，会将消息放到死信队列进行消费。可以基于死信队列实现：</p> <ul><li>信息延迟消费。刻意让消息执行失败，超时进入死信队列。</li></ul> <h3 id="_7、如何处理消息积压问题"><a href="#_7、如何处理消息积压问题" class="header-anchor">#</a> 7、如何处理消息积压问题？</h3> <p>从两个方面进行考虑：</p> <ul><li>broker段：在消费者数量足够多的情况下，此时消费瓶颈在broker，需要拓展topic分发消息。可以创建一个新的临时topic，启动一个程序，将topic下的挤压消息分发到临时topic，</li> <li>消费端：起N台机器进行消费者服务，提高消息的消费效率</li></ul> <h3 id="_8、kafka为什么这么快"><a href="#_8、kafka为什么这么快" class="header-anchor">#</a> 8、kafka为什么这么快？</h3> <p>问题可以从以下几个方面来回答：</p> <ul><li>集群部署：kafka可以水平拓展部署，同一份数据可以存储在多个broker的分区下</li> <li>支持批量处理和异步消费：多个消息可以放入同一个分区当中；同时消费时提交offset可以异步进行，先交偏移量然后再消费消息</li> <li>kafka零拷贝技术：减少数据在内存和磁盘的复制次数</li> <li>注册中心：因为是多个分区，因此注册中心可以采用负载均衡</li></ul> <h2 id="spring"><a href="#spring" class="header-anchor">#</a> Spring</h2> <h3 id="_1、spring说说ioc-整个bean的生命周期"><a href="#_1、spring说说ioc-整个bean的生命周期" class="header-anchor">#</a> 1、Spring说说IOC，整个Bean的生命周期？</h3> <p>整个IOC容器的创建过程中，核心方法是refresh方法，包括如下：</p> <ul><li>解析XML文件，创建Bean定义对象</li> <li>执行BeanFactoryPostProcessor拓展，修改Bean定义对象的属性值。包括①普通字符串类型②对应的Reference依赖对象类型</li> <li>注册BeanPostProcessor</li> <li>初始化事件发布者publisher</li> <li>所有Bean对象预加载：取出所有BeanDefinitionMap中的对象，根据bean定义信息创建对象。</li></ul> <p>其中创建Bean的生命周期doCreateBean如下：</p> <ul><li>实例化：通过<strong>反射</strong>拿到类构造器，newInstance</li> <li><strong>属性填充</strong>：主要根据setField反射进行
<ul><li>普通属性</li> <li>注解的容器对象、@Autowired（通过getBean方法创建对象）、@value对象（解析资源文件）</li></ul></li> <li>初始化：initializeBean方法，其中会拓展执行BeanPostProcessor前置方法和后置方法
<ul><li>前置方法：Aware对象注入</li> <li>执行①InitializingBean的afterPropertySet方法拓展点 ②初始化方法</li> <li>后置方法：AOP代理对象创建</li></ul></li></ul> <h3 id="_2、spring的aware依赖倒置"><a href="#_2、spring的aware依赖倒置" class="header-anchor">#</a> 2、Spring的Aware依赖倒置？</h3> <p>用户业务代码逻辑需要拓展，使用IOC容器当中的容器对象，包括：整个容器对象、Bean对象名称、上下文。流程如下：</p> <ul><li>用户实现对应的aware接口</li> <li>IOC容器会在初始化Bean的时候，将当前容器的上下文对象、Bean工厂等对象，调用set方法将对象传给用户自定义的业务类</li></ul> <h3 id="_3、spring的aop切面实现"><a href="#_3、spring的aop切面实现" class="header-anchor">#</a> 3、Spring的AOP切面实现？</h3> <p>核心都是通过<strong>instanceOf、isAssignableFrom</strong>方法，判断bean对象是不是实现了某个接口，或者是继承某个父类。</p> <p><strong>AOP核心是通过代理对象实现</strong>：<strong>代理对象并非所有方法都设置了切面方法</strong>，通过<font color="red"><strong>intercept方法</strong></font>拦截到方法执行时，判断当前方法是否用户自定义拦截方法和拦截类型，如果是则进行前置后置处理增强（织入切面方法）。</p> <p>将代理对象织入Bean生命周期时，在BeanPostProcessor后置增强当中，如果对象是代理对象，则创建一个代理对象，并加入IOC进行管理。</p> <ul><li>整个IOC中，创建的Bean只能是普通对象，或者是代理对象</li> <li>对象某个方法织入了AOP切面，那么只能保存代理对象。因为通过代理对象执行的方法会被拦截</li></ul> <h3 id="_4、spring-如何解决循环依赖问题"><a href="#_4、spring-如何解决循环依赖问题" class="header-anchor">#</a> 4、Spring 如何解决循环依赖问题？</h3> <p>首先对于普通对象之间的循环依赖，二级缓存已经能够解决。三级缓存解决的是需要AOP代理对象的循环依赖问题。各级缓存设置如下：</p> <ul><li>一级缓存：存放成品对象</li> <li>二级缓存：存放半成品对象，以及对应的成品对象。这里实际上是一个动态的过程</li> <li>三级缓存：存放的是<strong>函数式接口</strong>。所谓暴露指的是，可以向缓存存入一个lambda表达式，当getObject方法调用的时候，才会真正执行lambda表达式，构造代理对象。</li></ul> <p>本质上就是在B属性注入时，能够<strong>利用三级缓存触发A代理对象的提前创建</strong>。而只使用二级缓存，只能显式提前创建AOP代理对象，这会<strong>破坏Bean的生命周期</strong>，因此需要使用三级缓存。</p> <ol><li>A对象实例化——》注入三级缓存，提供代理对象创建的一个入口——》属性填充B对象</li> <li>B对象实例化——》加入三级缓存，也有一个——》属性填充A对象</li> <li>触发A对象的代理创建，放入二级缓存</li> <li>B对象创建完毕，触发自己的三级缓存的创建过程——》放入二级缓存——》B创建完毕，放入一级缓存</li> <li>A对象创建结束——》加入一级缓存</li></ol> <h3 id="_5、spring的-event事件机制-观察者模式"><a href="#_5、spring的-event事件机制-观察者模式" class="header-anchor">#</a> 5、Spring的 Event事件机制—观察者模式？</h3> <p>观察模式分为三个部分：</p> <ul><li>推送者：负责将事件推送给监听者，起桥梁的作用</li> <li>事件event：自定义事件</li> <li>监听者listener：当监听的事件触发之后，自动执行业务代码，<strong>核心实现是自定义的监听者接口中，声明时指定了监听的事件作为泛型</strong>。</li></ul> <p>发生事件时，具体流程如下：</p> <ul><li>调用publisher推送者发送事件，会将该事件广播给监听者。</li> <li>遍历所有监听者缓存，如果当前事件和监听者泛型属于同一个类别（或者是子类），则说明当前监听者匹配，调用执行监听者的onxxEvent，执行用户自定义的业务逻辑。</li></ul> <h3 id="_6、spring的自动扫描-component-那么-autowired呢"><a href="#_6、spring的自动扫描-component-那么-autowired呢" class="header-anchor">#</a> 6、Spring的自动扫描@component？那么@Autowired呢？</h3> <p>包扫描路径+@component：本质上是通过扫描路径，拿到所有注解的类名className，然后构建Bean定义信息</p> <p>@Autowired：本质上是在属性填充阶段，获取到所有注解的beanName，通过递归调用getBean方法创建出自动分配的对象，然后反射setField填充给Bean</p> <h3 id="_7、spring当中的factorybean和beanfactory有什么区别"><a href="#_7、spring当中的factorybean和beanfactory有什么区别" class="header-anchor">#</a> 7、Spring当中的FactoryBean和BeanFactory有什么区别？</h3> <p>BeanFactory相当于一个产生Bean的工厂，包含所有Bean定义信息，可以BeanFactory创建Bean对象</p> <p>FactoryBean提供用户自定义创建Bean的接口，创建的Bean不会经过复杂的生命周期流程。</p> <h3 id="_8、spring的设计模式有哪些"><a href="#_8、spring的设计模式有哪些" class="header-anchor">#</a> 8、Spring的设计模式有哪些</h3> <p>单例模式：Bean默认都是单例的</p> <p>模板模式：最常见，抽象类定义模板方法交给子类实现；getBean方法</p> <p>工厂模式：BeanFactory创建Bean工厂</p> <p>策略模式：xmlBeanDefinitionReader、PropertyBeanDefinitionReader。 Bean定义信息读取对象</p> <p>代理模式：AOP的实现就是通过代理模式实现</p> <p>观察者模式：multicast、event、listener</p> <h2 id="netty"><a href="#netty" class="header-anchor">#</a> Netty</h2> <h3 id="_1、谈谈bio、nio、aio"><a href="#_1、谈谈bio、nio、aio" class="header-anchor">#</a> 1、谈谈BIO、NIO、AIO</h3> <p>正常数据需要经过几个传输阶段：网卡、内核空间、用户空间、用户程序。</p> <p>BIO：用户程序请求数据，如果没有数据，会被阻塞在网卡这里</p> <p>NIO：用户请求时，<font color="red"><strong>如果网卡没有准备好数据，将数据拷贝到内核空间，那么不会阻塞直接返回</strong></font>。因此可以用IO多路复用程序，提高资源利用率。但是，数据拷贝到内核空间和用户空间这段时间是同步的，直到拷贝到程序都会被阻塞。</p> <p>AIO：数据准备，以及数据拷贝都是异步的。</p> <p>select和poll通过代理的方式，当”数据准备好“才会通知，轮询所有套接字。epoll则是只会轮询处理数据准备好的套接字。</p> <h3 id="_2、reactor模型"><a href="#_2、reactor模型" class="header-anchor">#</a> 2、Reactor模型</h3> <p>事件驱动。所有请求分为两个核心操作：连接操作和处理操作。</p> <p>单线程模型：只有一个线程负责客户端连接和处理操作。一个线程在连接时，另外一个不能进行处理</p> <p>多线程模型：一个线程负责连接操作，多个线程负责处理请求</p> <p>主从线程：多个线程分别处理连接操作和处理操作。</p> <p>在Netty当中，boss线程就是负责连接操作，而worker线程负责处理操作</p> <h3 id="_3、netty和nio之间的区别"><a href="#_3、netty和nio之间的区别" class="header-anchor">#</a> 3、Netty和NIO之间的区别</h3> <p>NIO编程灵活性差，没有处理半包、粘包、重连的问题。</p> <p>Netty内部默认支持<strong>多种协议格式</strong>，实现对应的编码器和解码器，同时可以自定义解决半包和粘包问题。另外Netty经过许多优秀开源组件的考验，包括Dubbo、RocketMQ等等，性能强大。</p> <h3 id="_4、半包和粘包问题-如何解决"><a href="#_4、半包和粘包问题-如何解决" class="header-anchor">#</a> 4、半包和粘包问题，如何解决？</h3> <p>粘包：指的是当前数据包包含下一个数据包的内容</p> <p>半包：当前数据包的数据不完整</p> <p>产生半包和粘包问题根本在于，双方协议没有指定对应的数据包开始符号、结束符号。需要自定义结束符、数据包大小。Netty内部默认实现。</p> <h3 id="_5、netty零拷贝"><a href="#_5、netty零拷贝" class="header-anchor">#</a> 5、Netty零拷贝</h3> <p>零拷贝指的是，数据不需要从一个存储区域拷贝到另一个存储区域。比如从硬件设备拷贝到内核空间、从内核空间拷贝到用户空间。</p> <p>其中Netty零拷贝主要是节省了用户空间的拷贝：</p> <ul><li>composition：ByteBuf之间如果需要合并，比如head和body，那么传统做法是需要开辟一个空间，然后分别将两个ByteBuf复制到这个合并的空间当中。而Netty可以直接合成，虽然物理上内存不是连续的，通过改变readIndex读指针来实现逻辑上是连续。</li> <li>splice：同一块内存空间支持分割成多个部分，不需要重新开辟空间进行拷贝。每个ByteBuf都会维护自己的读索引和写索引。</li> <li>transferTo：通过地址映射，内核空间的数据不需要拷贝到用户空间。</li></ul> <h3 id="_6、netty为什么快"><a href="#_6、netty为什么快" class="header-anchor">#</a> 6、Netty为什么快</h3> <p>1、Netty基于NIO和IO多路复用，能够处理大量并发连接</p> <p>2、Netty内部零拷贝机制（组合composition+splice+transferto）</p> <h2 id="项目一"><a href="#项目一" class="header-anchor">#</a> 项目一</h2> <h3 id="_1、抽奖项目设计模式"><a href="#_1、抽奖项目设计模式" class="header-anchor">#</a> 1、抽奖项目设计模式</h3> <p>项目中使用到的设计模式如下：</p> <ul><li>工厂模式：奖品分发工厂。根据奖品编号，从工厂Map当中取出对应的奖品对象。</li> <li>策略模式：抽奖策略，根据不同的策略类型，调用具体对象的抽象算法的具体实现。分为总体概率、单项概率：
<ul><li>总体概率：抽到奖品的概率，会根据奖池的商品总数、当前奖品数量动态改变。Random类生成一个随机数之后，看抽到数落在哪个奖品概率区间，其中每个奖品的区间长度等于奖品概率</li> <li>单项概率：抽到奖品的概率固定，如果抽到的奖品数量变为零，则返回没抽到。这里可以通过令牌桶将算法时间复杂度简化O（1），具体来说，创建一个大小为100的数组，然后商品概率乘上100记为n，将n个数组的值设置成该商品的ID。生成的随机数直接根据string[random]获取抽到的奖品编号</li></ul></li> <li>模板模式：定义抽奖流程。抽象类定义整个流程的编排，然后子类实现具体流程。doDrawExec方法定义抽奖流程：获取抽奖策略、查询商品数量、执行抽奖过程、封装抽奖结果。</li> <li>状态模式：定义几个状态对象，在每个状态对象内部定义流转到其它对象的逻辑，用户在外部传入一个状态接口。抽奖活动状态的流转，包括编辑、提审、通过、拒绝、撤审、运行、关闭</li></ul> <h3 id="_2、数据库路由组件"><a href="#_2、数据库路由组件" class="header-anchor">#</a> 2、数据库路由组件</h3> <p>组件分为三部分实现：</p> <ul><li>通过Spring AOP切面，在需要分库分表的SQL方法执行时，获取“分表”的key字段，拿到形参的值，根据形参计算分库分表的哈希值</li> <li><strong>实现分表</strong>：通过mybatis@interceptor拦截器，拦截到statementHandler方法的prepare方法，拿到对应SQL语句，通过正则、反射修改SQL语句的表名，实现分表路由。</li> <li>实现分库：创建一个新的数据源，并重写determineCurrentLookupKey方法，决定数据源key。每次执行SQL语句getConnnection时，都会调用该方法。因此可以在里面替换<strong>数据库名路由</strong>。因为是ThreadLocal，因此每个线程的路由都是不同。</li> <li>获取SpringBoot配置的路由信息：<font color="red"><strong>通过EnvironmentAware获取对应的配置对象，从而拿到配置参数</strong></font>。</li></ul> <h3 id="_3、谈谈规则引擎设计的意义是什么-如何实现的"><a href="#_3、谈谈规则引擎设计的意义是什么-如何实现的" class="header-anchor">#</a> 3、谈谈规则引擎设计的意义是什么？如何实现的？</h3> <p>在抽奖过程中，用户可以自由抽奖，可以点击官方推荐的按钮报名活动进行抽奖。而抽奖引擎就是用于官方控制成本、精细化运营。比如某个活动A，限制只有年龄大于30、性别女、购物金额达到多少的用户才能参加。</p> <p>实现方式采用基于组合模式的<strong>决策树</strong>实现，非叶子节点表示决策的属性，叶子节点表示最终决策的活动ID。举例来说，比如当前节点属性是性别，如果是男则走左子树，女则走右子树。</p> <ul><li>数据库存储两个表，一个是节点表，每个节点存储决策属性、节点ID、属性值；另一个是边表，存储父节点ID、从节点ID、表达式（大于、小于）、比较值。</li> <li>实现决策时，首先根据数据库表封装每个节点的聚合对象，包括<strong>当前非叶子节点属性+所有边节点的集合</strong>。</li></ul> <h3 id="_4、介绍一下整个抽奖活动的主链路"><a href="#_4、介绍一下整个抽奖活动的主链路" class="header-anchor">#</a> 4、介绍一下整个抽奖活动的主链路？</h3> <p>整个抽奖链路包括五个部分：</p> <ol><li>报名活动
<ul><li>校验活动：包括判断刷单、活动过期、用户没有抽奖次数</li> <li>redis活动数量减一</li> <li><font color="red"><strong>落库报名记录</strong></font>：添加活动报名记录，扣减个人活动次数</li></ul></li> <li>异步扣减活动数量</li> <li>执行抽奖算法
<ul><li>获取抽奖策略，以及产品中奖概率</li> <li>生成随机数，判断落在哪个产品区间</li></ul></li> <li>封装抽奖结果，并落库抽奖记录
<ul><li><font color="red"><strong>落库中奖记录</strong></font>：报名记录锁定，添加中奖记录</li></ul></li> <li>异步发奖</li></ol> <h3 id="_5、说说抽奖活动的秒杀场景"><a href="#_5、说说抽奖活动的秒杀场景" class="header-anchor">#</a> 5、说说抽奖活动的秒杀场景</h3> <p>秒杀场景主要在活动报名阶段，每个用户报名活动时，首先获取key，然后扣减redis中的活动数量。</p> <p>其中key设置为<strong>活动ID+redis活动报名数量</strong>。参考concurrenthashMap进行设计，锁的粒度变细，相比于仅设置整个活动ID为key的做法，可以提高获取锁的成功率。</p> <p>缺点：细粒度意味着需要占用更多的redis内存，100个活动就需要存100个分布式锁。此外，如果获取锁的流程失败，如何恢复也是一个问题？是否需要redis加回去，还是仅仅删除key。</p> <h3 id="_6、动态路由导致事务失效如何解决"><a href="#_6、动态路由导致事务失效如何解决" class="header-anchor">#</a> 6、动态路由导致事务失效如何解决？</h3> <p>通过spring提供的编程式事务来解决，Transactiontemplate来控制事务全部执行，或者全部失败。</p> <p>在项目当中主要有两个地方：</p> <ul><li>用户扣减活动报名次数+用户添加活动报名记录</li> <li>插入中奖记录+修改活动报名记录状态</li></ul> <h3 id="_7、如何防止超领和超发"><a href="#_7、如何防止超领和超发" class="header-anchor">#</a> 7、如何防止超领和超发？</h3> <p>超领问题：</p> <ul><li>问题：指的是用户同一时刻快速点击活动报名按钮两次，从而一次活动报名多次。</li> <li>解决方法：保证<font color="red"><strong>活动报名记录表的幂等性</strong></font>，设置一个唯一的uuid字段，它等于<strong>活动ID+用户ID+用户剩余报名次数</strong>。因此只要出现多条报名记录uuid重复，数据库插入时就会报异常。</li></ul> <p>超发问题：</p> <ul><li>问题：超领问题指的是系统对于一条中奖记录，发送多次奖品。</li> <li>解决方法：保证<font color="red"><strong>中奖记录表的幂等性</strong></font>，设置唯一的uuid字段。一条中奖记录记录对应一条活动报名记录，设置值为对应活动报名ID。</li></ul> <h3 id="_8、谈谈两个kafka异步流程"><a href="#_8、谈谈两个kafka异步流程" class="header-anchor">#</a> 8、谈谈两个kafka异步流程？</h3> <p>核心：通过kafka异步执行不干扰主链路的其它链路，保证从用户点击活动抽奖，到界面弹出抽奖结果的相应，这个响应时间尽可能快。</p> <p>第一个kafka流程：异步更改数据库的活动数量；这里并没有设置回调确保消息一定消费成功，因此可能会导致<strong>数据库活动数量扣减失败</strong>，导致出现”数据库库存剩余，但是不可秒杀“的问题。</p> <p>第二个kafka流程：异步发货；中奖记录有两个字段，包括发奖状态字段、MQ消息补偿字段。此处设置MQ回调：</p> <ul><li>如果消息发送消费成功，中奖记录发奖状态更改，那么触发成功回调，MQ字段不更改。</li> <li>如果消费失败，没有发奖成功，那么触发失败回调，MQ字段更改为”待补偿“。</li> <li>后台启动一个定时任务，扫描所有中奖记录表的记录，如果MQ状态字段为”待补偿“，则重新消费这条消息。</li></ul> <h3 id="_9、项目中遇到什么问题"><a href="#_9、项目中遇到什么问题" class="header-anchor">#</a> 9、项目中遇到什么问题？</h3> <p>1、动态路由组件：希望设计一个能够根据SQL语句的某个字段，路由到任意分库和分表；如何解决更换数据源导致的事务失效问题</p> <p>2、秒杀场景：如何减小锁的粒度，提高获取锁的成功率。</p> <p>3、决策树：如何存储DB，保存决策树的节点以及边</p> <h3 id="_10、抽奖项目调优经验"><a href="#_10、抽奖项目调优经验" class="header-anchor">#</a> 10、抽奖项目调优经验</h3> <p>项目采用两台4c8G的阿里云服务器进行压测：</p> <ul><li>一台只部署springBoot项目，并对外开放Rest接口</li> <li>部署Mysql、中间件redis、kafka、xxljob</li></ul> <p>使用jmeter进行梯度压测，循环次数都设置2000，线程数从10开始每隔5进行递增。最终TPS稳定在600左右（这里将吞吐当成TPS），这里测的是整个链路。</p> <p>优化：</p> <ul><li>针对所有查询语句进行优化：①用户信息表建立联合索引，uid和活动id，<font color="red"><strong>当时吞吐翻了三四倍</strong></font>；以及查询用户活动报名记录，也是添加uid和活动id联合索引  ②查活动表直接添加活动id作为索引，但是效果没有很明显，可能是数据量不够。</li> <li>针对RTT响应时间进行优化：查询活动信息，把从数据库查询换成从缓存redis查询，也就是将活动信息存到redis中，key为活动ID。使用<strong>redis哈希</strong>这个数据结构进行存储。最终这个活动查询接口快了不少。</li></ul> <h3 id="_11、抽奖项目数据库表设计"><a href="#_11、抽奖项目数据库表设计" class="header-anchor">#</a> 11、抽奖项目数据库表设计</h3> <p>数据库表设计包含以下几个表：</p> <ul><li>活动信息表：包括活动ID、活动状态、活动起止日期、活动数量</li> <li>用户信息表：用户ID、活动ID、用户可报名活动次数、当前报名次数。（<strong>创建联合约束用户id-活动ID</strong></li> <li>奖品表：奖品ID、奖品类型、奖品数量</li> <li>抽奖策略表：策略ID、单体还是总体概率</li> <li>抽奖详情表：策略ID，奖品ID，奖品概率、当前奖品数量</li> <li>活动报名记录表：活动ID，用户ID，uuid防重、当前活动状态、<strong>领取ID</strong>，剩余活动报名次数，报名ID</li> <li>中奖记录表：活动ID，用户ID，奖品ID，发奖状态，发奖方式，发奖时间，MQ状态，订单ID</li> <li>决策树节点信息表：决策属性，决策树ID，节点类型、节点值</li> <li>决策树边路径信息表：父节点、从节点、决策值、决策表达式</li></ul> <h3 id="_12、项目ddd划分成几个领域"><a href="#_12、项目ddd划分成几个领域" class="header-anchor">#</a> 12、项目DDD划分成几个领域？</h3> <p>包括规则引擎、抽奖策略、活动报名、奖品发送。</p> <h3 id="_13、组合模式"><a href="#_13、组合模式" class="header-anchor">#</a> 13、组合模式</h3> <p>组合模式主要用于处理整体-部分的对象关系，在项目中主要是用于决策树节点的存储，区分非叶子结点和叶子节点，通过每个非叶子节点决策走哪条树茎，最终决策出叶子节点的活动ID返回给用户。</p> <h3 id="_14、递增分布式id的方案"><a href="#_14、递增分布式id的方案" class="header-anchor">#</a> 14、递增分布式ID的方案</h3> <p>方案对比如下：</p> <ul><li>UUID：无序不能用到索引，长度比较大耗费磁盘存储空间。字符串存储</li> <li>数据库自增ID：分库场景下，可能会出现ID重复的情况，不能水平拓展</li> <li>雪花算法：分布式场景下能够保证整体序列递增。但是依赖机器时钟，可能会出现重复ID生成。</li></ul> <h2 id="项目二"><a href="#项目二" class="header-anchor">#</a> 项目二</h2> <h3 id="_1、项目包含哪几个功能模块-简要每个模块的功能和作用"><a href="#_1、项目包含哪几个功能模块-简要每个模块的功能和作用" class="header-anchor">#</a> 1、项目包含哪几个功能模块？简要每个模块的功能和作用？</h3> <p>项目可以分为三个模块进行介绍：</p> <ul><li>启动引擎、核心通信、启动助手：启动引擎作为SpringBoot程序入口，内嵌了核心通信、启动助手两个包。
<ul><li>核心通信：Netty服务端，相当于一个网关算力。用于监听客户端连接，并执行处理和协议转换</li> <li>启动助手：SpringBoot starter程序，启动引擎启动服务时，能够向注册中心注册当前算力节点，并拉取服务信息构建缓存（当前节点负责转发哪些API接口）。</li></ul></li> <li>注册中心：作为一个中间者，主要提供整个网关服务相关的数据库操作。采用SpringBoot+MySQL实现，其它组件或者程序通过Hutool的http连接调用注册中心的服务。</li> <li>服务上报：它是一个SprigBoot starter，当服务提供方，比如Dubbo、Http提供服务时，能够将当前服务信息向注册中心注册。让整个网关能够感知到当前的服务。</li></ul> <h3 id="_2、网关通信会话流程如何进行编排"><a href="#_2、网关通信会话流程如何进行编排" class="header-anchor">#</a> 2、网关通信会话流程如何进行编排</h3> <p>在Netty服务端中，通过给channel指定和编排多个handler，当请求到达通道后，会顺序调用多个handler进行处理。本项目主要编排了三个handler：</p> <ul><li>请求参数解析handler：包括截取url获取映射，获取请求参数，包括application/json和multipart，获取表单数据</li> <li>鉴权handler：拿到请求体中的uid和token，利用jwt解码验证当前用户是否授权，没有则直接返回writeAndFlush，不会进行下一步接口调用</li> <li>服务调用handler：根据uri的接口映射，从全局缓存中拿到对应的泛化调用对象，并且传入参数。结果写回通道响应客户端。</li></ul> <h3 id="_3、说明算力注册和服务发现starter的设计"><a href="#_3、说明算力注册和服务发现starter的设计" class="header-anchor">#</a> 3、说明算力注册和服务发现starter的设计？</h3> <p>服务助手这个starter实现了两个主要功能：</p> <ul><li>算力注册：将当前内嵌的网关信息，包括网关名称、网关地址、监听端口等注册到数据库。</li> <li>服务发现：获取当前网关节点所支持转发的接口和方法，并加入configuration缓存当中。</li></ul> <p><font color="red"><strong>通过实现ApplicationContextAware接口实现，会在初始化之前执行</strong></font>。</p> <h3 id="_4、redis服务发布订阅使用场景"><a href="#_4、redis服务发布订阅使用场景" class="header-anchor">#</a> 4、Redis服务发布订阅使用场景？</h3> <p>使用Redis主要是因为，之前没怎么听说Redis还有这个订阅发送的功能，一般都是作为缓存来用的嘛，所以就打算用redis试一试，<strong>拓展技术广度</strong>。其实用其他MQ产品也是一样的。</p> <p>场景：因为前面也提到了，服务提供方启动后，会注册服务接口信息，然后才能启动网关算力节点（整个启动引擎）。因此如果后续需要另外添加新的接口方法，那么就需要重启网关节点，显然这是不合适的。</p> <p>方法：当服务提供方启动服务之后，会发送信息给监听者，topic主题是网关ID，也就是负责转发当前接口的网关；内容是系统ID，代表当前整个提供服务的系统。然后启动引擎那边会设置一个监听者代码，收到消息后会<strong>重新拉取该系统的注册信息，更新缓存</strong>。</p> <h3 id="_5、编程式docker如何实现-应用场景是什么"><a href="#_5、编程式docker如何实现-应用场景是什么" class="header-anchor">#</a> 5、编程式Docker如何实现？应用场景是什么？</h3> <p>实现：使用docker-java包，指定docker在服务器的路径，通过java连接到服务器的docker，从而可以编程式调用docker的容器。</p> <p>场景：网关整个处理请求的链路是这样的，请求先打到一台Nginx上，然后Nginx根据url路由到对应的网关服务器地址上。因此我们配置好Nginx的上游服务器地址后，如果后续需要启动新的网关节点，那么就需要更改Nginx配置并重启。</p> <p>需求：能不能我启动网关节点之后，不需要重新启动Nginx，也能被Nginx代理到当前网关节点上？</p> <p>做法：要实现以上需求，就需要每个网关节点启动之后，动态刷新Nginx的配置，同时reload整个docker服务使其生效。具体来说分为两步：</p> <ol><li>更新Nginx配置文件：每个网关节点启动后，会刷新容器内部的一个配置文件，因为整个容器内部将该文件地址，<strong>关联挂载</strong>到了容器外部，也就是服务器中的文件，而该外部文件也是Docker容器Nginx关联的外部文件。相当于A与B关联，A更新之后B也会更新，因为B和C也是关联的，因此C也会更新，而C就是Docker内部Nginx的配置文件。new一个File，然后写入。</li> <li>reload重启Nginx，则是通过docker-java连接，然后根据容器名获取容器ID，exec进入容器之后，调用cmd脚本Nginx reload生效。</li></ol> <p>但是这种方案缺陷在于，如果是Nginx集群，或者网关节点和Nginx不在同一台机器上，则无法刷新。</p> <p>调研过其它网关产品的做法，阿帕奇神禹(soul)解决网关动态刷新的做法，通过<strong>启动另外一个注册中心（Nacos、zookeeper）监视存活的网关实例</strong>，然后OpenResty（Nginx+lua）连接注册中心，就可以拿到实时的存活实例，更新到上游服务器。</p> <h3 id="_6、谈谈注册中心数据库表的设计"><a href="#_6、谈谈注册中心数据库表的设计" class="header-anchor">#</a> 6、谈谈注册中心数据库表的设计</h3> <p>数据表包括如下：</p> <ul><li>网关信息表：包含网关ID、IP端口、网关状态，每条记录对应一个网关实例</li> <li>网关分配表：网关ID、应用ID，同一个应用下的所有接口和方法都交给该网关ID负责协议转换</li> <li>应用信息表：应用ID、注册中心</li> <li>接口信息表：应用ID、接口ID、接口名、版本号</li> <li>方法信息表：应用ID、接口ID、方法ID、形参类型、请求方式(get/post)、<font color="red"><strong>uri</strong></font>、鉴权标志</li></ul> <h3 id="_7、如何利用spi-spring如何利用拓展点"><a href="#_7、如何利用spi-spring如何利用拓展点" class="header-anchor">#</a> 7、如何利用SPI？Spring如何利用拓展点？</h3> <p>SPI：通过spring.factories文件指定@Bean对象，该对象@configuration进行标记，主SpringBoot的IOC容器就会将第三方外部Bean加入到容器进行管理。</p> <p>网关项目中，主要用到了几个拓展点：</p> <ul><li>closeEvent：容器关闭事件触发之后，会执行Netty服务的关闭，防止占用资源。</li> <li>ApplicationContextAware：aware触发算力注册、服务拉取。</li> <li>BeanPostProcessor：IOC容器执行初始化方法后，后置增强会执行<strong>RPC服务上报</strong>功能</li></ul> <h3 id="_8、项目遇到的问题"><a href="#_8、项目遇到的问题" class="header-anchor">#</a> 8、项目遇到的问题</h3> <h4 id="问题一-关于netty服务端绑定的问题"><a href="#问题一-关于netty服务端绑定的问题" class="header-anchor">#</a> 问题一：关于Netty服务端绑定的问题</h4> <p>当时尝试将网关部署在虚拟机的时候，服务端bind需要绑定监听的IP和端口：</p> <ul><li>监听IP设置成虚拟机IP，启动的时候发现没法正常启动</li> <li>监听IP设置成127.0.0.1，可以正常启动但是收到外部请求</li></ul> <p>经过查询和了解，这个服务端bind指的是监听的网卡IP，也就是说它会接收到发送往当前主机某个网卡的所有请求，交给程序处理。因此，如果设置的IP当前主机网卡没有这个地址，那么就会报错。</p> <p>于是尝试了ifconfig查看本机网卡，果然只有一个虚拟网卡，另一个是127.0.0.1。因此设置虚拟机IP是感知不到的。而127.0.0.1是一个本地环回地址，因此只有在虚拟机内部通过127.0.0.1发送才能接收到，而外部或者其它客户端发送往这个地址，只会发送到自己的机器。</p> <p>所以最终的方案是设置成0.0.0.0，因为网关挂载外部某个端口，那么向当前虚拟机IP发送的请求，肯定接受到。它表示监听发送往当前主机的所有网卡。</p> <h4 id="问题二-服务上报的问题"><a href="#问题二-服务上报的问题" class="header-anchor">#</a> 问题二：服务上报的问题</h4> <p>因为只有先启动RPC服务提供方，向注册中心注册，再启动网关算力，网关才能感知到接口服务。因此如果后续需要启动新的服务，那么需要重新启动网关。</p> <p>所以就希望能不能不重启网关，后续新的接口启动后，网关也能感知到并且刷新缓存。因此想到了事件发布订阅这么一个通知机制。</p> <h3 id="_9、系统的性能瓶颈在哪儿"><a href="#_9、系统的性能瓶颈在哪儿" class="header-anchor">#</a> 9、系统的性能瓶颈在哪儿？</h3> <p>整个网关系统有多条链路，包括算力注册、服务注册，其中性能瓶颈主要集中在这条链路：客户端连接-》参数解析-》获取服务调用-》封装结果并响应返回。因此可以从以下几个方面进行优化：</p> <ul><li>网络IO：当多个用户请求打进来的时候，Netty需要处理大量的IO读写事件。可以采用Netty零拷贝等一些方法提高IO性能。</li> <li>线程池：如何设置好Netty线程池参数是提高系统的关键。EventLoop对应一个Netty线程，分为两种，boss线程负责处理连接事件，worker线程则负责执行业务操作。一般来说，服务端监听了几个IP，那么就设置几个boss线程；worker线程则设置为CPU核心数*2，因为worker线程并不是一直都在工作的，可能客户端数据没有到。</li> <li>内存设置：网关很多对象都是朝生夕死的，因此设置合理的JVM内存大小可以防止出现内存问题。<strong>可以将新生代设置大一些</strong>，让所有对象都在新生代存活和销毁。</li> <li>服务提供方：提高RPC方法调用的效率可以提高系统整体的性能。比如采用Dubbo的异步执行、负载均衡。</li></ul> <h3 id="_10、netty如何实现断线重连"><a href="#_10、netty如何实现断线重连" class="header-anchor">#</a> 10、Netty如何实现断线重连？</h3> <p>一般重连可以通过定时任务，重复执行客户端连接的代码。</p> <p>本系统因为客户端不需要处理数据，因此没有编写客户端代码，客户端通过网络连接实现服务端的连接。如果断了那么客户端直接刷新浏览器就好了。</p> <h3 id="_11、网关高可用可以做哪些处理"><a href="#_11、网关高可用可以做哪些处理" class="header-anchor">#</a> 11、网关高可用可以做哪些处理？</h3> <ul><li>异地多机房部署多个网关实例</li> <li>网关实例执行RPC服务调用失败，需要进行重试机制</li> <li>负载均衡：前端LVS+硬件负载均衡F5+Nginx</li></ul> <h3 id="_12、该网关与springcloud网关有什么区别"><a href="#_12、该网关与springcloud网关有什么区别" class="header-anchor">#</a> 12、该网关与springcloud网关有什么区别？</h3> <p>SpringCloud网关主要是处理Http连接的一些问题，包括降级、熔断、限流</p> <p>本网关系统主要是负责协议转换，控制API接口调用的管理</p> <h3 id="_13、其它系统想要接入你的网关-需要哪些步骤"><a href="#_13、其它系统想要接入你的网关-需要哪些步骤" class="header-anchor">#</a> 13、其它系统想要接入你的网关，需要哪些步骤?</h3> <ul><li>首先需要在注册中心，配置相关URL的映射，什么样的请求格式才会打到对应RPC服务</li> <li>网关内部需要拓展当前协议格式，要转发给你提供的API接口，请求格式是什么，参数是什么</li> <li>提供方需要暴露服务，嵌入我们的SDK服务上报，如果是Dubbo那么系统正好实现；而如果是其它服务，则需要调用注册中心接口，上传接口、方法、参数等信息。</li></ul> <h3 id="_14、网关为什么自研-和市面上的产品区别在哪儿"><a href="#_14、网关为什么自研-和市面上的产品区别在哪儿" class="header-anchor">#</a> 14、网关为什么自研？和市面上的产品区别在哪儿？</h3> <p>我觉得区别主要在两个方面：</p> <ul><li>拓展性：自研网关可以很好的拓展支持公司内部协议，拓展实现其它功能</li> <li>维护成本低：自研的产品减少依赖包版本导致的不兼容问题，同时代码全程都是可控的，因此不会出现安全问题，比如之前log4j的漏洞</li></ul> <h3 id="_15、网关如何进行区分"><a href="#_15、网关如何进行区分" class="header-anchor">#</a> 15、网关如何进行区分？</h3> <p>数据库中有一个网关分配表，每一条网关ID对应一个应用ID，这是一个一对多的关系，该应用ID下的所有接口和方法都负责交给该网关进行转发。</p> <p>如果需要同一个接口下方法1交给网关A转发，方法2交给网关B，那么需要进一步细粒度的设计这个网关分配表。</p> <h3 id="_16、rpc服务上报后协议变了-网关如何进行处理"><a href="#_16、rpc服务上报后协议变了-网关如何进行处理" class="header-anchor">#</a> 16、RPC服务上报后协议变了，网关如何进行处理？</h3> <p>处理如下：</p> <ul><li>首先网关Handler内部需要支持当前协议的转发，保证RPC服务能够被正确的转发和调用</li> <li>数据库中，网关的接口方法数据也需要更新，包括方法参数，请求格式等等</li></ul> <h3 id="_17、服务降级方案怎么进行设计"><a href="#_17、服务降级方案怎么进行设计" class="header-anchor">#</a> 17、服务降级方案怎么进行设计？</h3> <p>服务降级可以通过一个插件实现，嵌入到服务提供方；当服务启动注册后<strong>开启服务治理配置</strong>，当触发服务降级时，可以设置返回一个错误码。</p> <h2 id="其它"><a href="#其它" class="header-anchor">#</a> 其它</h2> <h3 id="_1、说说jwt安全认证"><a href="#_1、说说jwt安全认证" class="header-anchor">#</a> 1、说说JWT安全认证？</h3> <p>本质上是一种数据签名方式，用于加密认证。服务端保存一个私钥，利用<strong>私钥</strong>进行加密解密，根据结果判断用户的信息是否被篡改过、被认证过。</p> <h3 id="_2、说说github-actions如何工作"><a href="#_2、说说github-actions如何工作" class="header-anchor">#</a> 2、说说Github Actions如何工作？</h3> <p>部署前端项目时，push推到master分支时，github会自动读取并执行workflow下的配置脚本。</p> <p>具体来说，在jobs下定义每个操作步骤step，包括切换分支、安装node.js、执行前端代码部署脚本、运行。</p> <h3 id="_3、操作系统内核的工作"><a href="#_3、操作系统内核的工作" class="header-anchor">#</a> 3、操作系统内核的工作</h3> <ul><li>负责网络IO，将网卡的数据接收到内核空间，以及将数据发送出去</li> <li>协议解析，将数据包发往对应的协议端口</li> <li>维护当前主机和远程主机的连接</li></ul> <h3 id="_4、top指令"><a href="#_4、top指令" class="header-anchor">#</a> 4、top指令</h3> <p>通过top指令，查看整个服务器的资源占用，包括CPU、内存、交换区的使用占比。然后会列出所有进程的使用情况。</p> <p>如果想要查看某个进程的资源占用情况，使用如下语句：</p> <p><strong>top -p 指定进程的pid，查询对应进程的资源使用情况</strong></p> <h3 id="_5、lsof指令全称是什么"><a href="#_5、lsof指令全称是什么" class="header-anchor">#</a> 5、lsof指令全称是什么</h3> <p>lsof：list open files 列出进程打开的所有文件。</p> <h3 id="_6、乐观锁悲观锁使用场景"><a href="#_6、乐观锁悲观锁使用场景" class="header-anchor">#</a> 6、乐观锁悲观锁使用场景</h3> <p>1、乐观锁主要用于读多写少的场景，底层通过版本号实现。</p> <p>2、悲观锁主要用在数据激烈竞争的场景、写多读少。synchronized和lock都是悲观锁</p> <h3 id="_7、反射违背面向对象的封装性吗"><a href="#_7、反射违背面向对象的封装性吗" class="header-anchor">#</a> 7、反射违背面向对象的封装性吗？</h3> <p>反射并不会破坏对象的封装性，那些有限定符限制访问的还是遵循对应的约束。</p> <p>可以通过setAccessible修改权限，但是这是一种暴力的方法。</p> <h3 id="_8、mybatis和mybatis-plus的区别"><a href="#_8、mybatis和mybatis-plus的区别" class="header-anchor">#</a> 8、Mybatis和Mybatis-plus的区别</h3> <p>Mybatis：所有dao操作都需要在xml文件当中配置SQL语句、ID映射</p> <p>MP：通过内置的Mapper，直接调用默认方法，实现数据表的CRUD操作。</p> <h3 id="_9、跨域问题"><a href="#_9、跨域问题" class="header-anchor">#</a> 9、跨域问题</h3> <p>跨域问题：因为浏览器同源策略，导致当前页面不能进行跨域访问，包括IP+端口+协议必须要保持一致。</p> <p>解决方案：在controller上面注解@<strong>CrossOrigin</strong>。本质都是<strong>在响应头当中，加入允许跨域的字段</strong>。</p> <h3 id="_10、cpu中断之后进程的处理流程"><a href="#_10、cpu中断之后进程的处理流程" class="header-anchor">#</a> 10、CPU中断之后进程的处理流程?</h3> <ul><li>保存进程状态：寄存器</li> <li>切换上下文，执行中断处理程序</li> <li>恢复现场</li> <li>返回用户态，继续执行中断代码</li></ul> <h3 id="_11、cas算法"><a href="#_11、cas算法" class="header-anchor">#</a> 11、CAS算法？</h3> <p>CAS：compare and swap</p> <p>广泛用于并发控制的算法，基于乐观锁通过检查版本号实现。</p> <p>首先读取要修改的变量值，更改时如果发现该数据已经被改变，则更新失败；否则更新成功。</p> <h3 id="_12、nginx负载策略"><a href="#_12、nginx负载策略" class="header-anchor">#</a> 12、Nginx负载策略</h3> <ol><li>默认轮询方式：按照请求时间将请求负载到不同的服务器</li> <li>权重：每个服务器设置权重，权重的大小与被负载的概率成正比</li> <li>最短连接：每次Nginx会将请求负载到连接数量最少的服务器</li> <li>哈希</li></ol> <h3 id="_13、两个线程交替打印奇数偶数"><a href="#_13、两个线程交替打印奇数偶数" class="header-anchor">#</a> 13、两个线程交替打印奇数偶数</h3> <p>1、synchronized+wait+notify</p> <p>2、BlockingQueue</p> <h3 id="_14、协程"><a href="#_14、协程" class="header-anchor">#</a> 14、协程</h3> <p>1、适用于IO密集型任务场景，比如连接数多、读写频繁、</p> <p>2、协程运行于线程之上，一个线程包含多个协程</p> <p>3、协程是用户自定义的，操作系统不会感知到协程的存在，因此切换时不存在内核态的上下文切换开销。</p> <h3 id="_15、docker容器虚拟化技术"><a href="#_15、docker容器虚拟化技术" class="header-anchor">#</a> 15、Docker容器虚拟化技术</h3> <p>技术发展：VM虚拟机的问题在于，只实现了<strong>操作系统级别的虚拟化</strong>，每次迁移都需要重新安装操作系统，迁移比较重；Docker实现了<strong>进程级别的虚拟化</strong>，不同进程之间感知不到对方的存在，容器之间的资源都是隔离的，包括库、程序、资源配置等。 虚拟机运行的是操作系统，而docker运行的是应用。</p> <p>实现docker虚拟化的核心技术：</p> <ul><li>linux namespace：在每个namespace中，能够控制每个容器能够<font color="red"><strong>看到的pid、网络等资源</strong></font>，每个资源都是容器独一份的，最终实际运行时在映射到Linux的全局资源</li> <li>control group：<font color="red"><strong>限制每个容器能够使用的具体硬件资源</strong></font>，包括内存，磁盘。</li></ul> <h3 id="_16、数组和链表在内存存储上的区别"><a href="#_16、数组和链表在内存存储上的区别" class="header-anchor">#</a> 16、数组和链表在内存存储上的区别？</h3> <p>数组内存地址是连续的；而链表在物理上是不连续的。因此从某种意义上来说，数组比链表更快，差距可能出现在计算下一个访问节点的内存地址上。</p> <h2 id="备战"><a href="#备战" class="header-anchor">#</a> 备战</h2> <h3 id="技术选型问题-kafka和rocketmq-网关使用netty-注册中心数据存储"><a href="#技术选型问题-kafka和rocketmq-网关使用netty-注册中心数据存储" class="header-anchor">#</a> 技术选型问题？kafka和RocketMQ？网关使用Netty?注册中心数据存储？</h3> <p>消息队列选型：</p> <ul><li>单机kafka吞吐是比RocketMQ高的，主要原因在于①kafka零拷贝②kafka发送消息时支持批量压缩（问题：缓存GC，生产者宕机）</li> <li>kafka主要定位是日志，而rocketmq可以满足订单、交易、充值等场景。</li></ul> <p>网关技术选型：</p> <ul><li>springcloud gateway底层使用的webflux就是基于Netty搭建，它是一个高性能的通信框架。</li></ul> <p>注册中心数据存储：</p> <ul><li>Nacos：嵌入式数据库，MySQL。分成三个部分provider、server、consumer。其中nacos-server就是一个springboot程序，提供服务注册和服务发现接口，以及持久化接口。</li> <li>zookeeper：主要是通过磁盘持久化+内存持久化实现。数据写到内存之后，异步写到磁盘当中。磁盘文件包括日志+快照，每次开机恢复时都会取最新 id 的快照和日志进行恢复，读到内存。</li> <li>京东的注册中心：采用redis+mysql水平分片实现。保证高可用</li> <li>注册中心需要保证AP原则，考虑扩容和容灾，</li></ul> <h3 id="mysql锁分类-死锁问题-事务的锁的关系"><a href="#mysql锁分类-死锁问题-事务的锁的关系" class="header-anchor">#</a> MySQL锁分类？死锁问题？事务的锁的关系？</h3> <p>MySQL锁划分：</p> <ul><li>根据锁粒度可以分为表锁、行锁、页锁；</li> <li>根据锁功能分为共享S锁、排他X锁；</li> <li>根据操作性能分为乐观锁(更新时才会进行冲突检测)、悲观锁(在更新前先锁定数据，防止被篡改)；<strong>资源竞争激烈时使用悲观锁</strong>，防止乐观锁重试浪费资源。</li> <li>根据行锁算法可以分成记录锁（锁住的实际上是索引记录，如果没有走索引会隐式创建索引，然后锁全表所有记录）、gap间隙锁（锁区间）、临建锁（记录+间隙锁）。具体是哪种行锁情况，会根据执行SQL语句中的范围查询、等值查询，唯一索引等条件退化成不同的锁。</li></ul> <p>死锁主要发生于持有某个锁资源同时，等待其它事务释放锁资源。造成多个事务同时等待的局面。比如：</p> <ul><li>表死锁：线程1先获取A的表锁，然后等待获取B的表锁；线程2先获取B的表锁，然后等待获取A的表锁</li> <li>行死锁：事务1首先在记录5添加X锁，然后等待记录10释放行锁；事务2首先在记录10添加X锁，然后等待记录5释放行锁</li></ul> <p>如何解决死锁：</p> <ul><li>核心是<strong>按序申请资源，按序加锁</strong>；程序批量处理数据时，如果能够进行排序，每个线程按序处理数据，则可以减少死锁出现的可能</li> <li>根据情况创建合适的索引，防止不走索引锁住表的每一行记录，增加出现死锁的概率</li> <li>线上如果发生死锁，则根据数据库<strong>监控工具</strong>，查询事务状况、锁资源状况；从而直接kill进程，或者是回滚事务</li></ul> <p>事务本质上是锁+MVCC实现的结果，进行了底层封装；对于用户来说，如果使用事务能够解决并发问题，那么则无需额外操作，否则需要手动加锁。</p> <h3 id="spring事务-事务传播"><a href="#spring事务-事务传播" class="header-anchor">#</a> Spring事务？事务传播？</h3> <p>Spring事务本质上就是通过AOP实现的，实际上的回滚操作都是通过数据库事务支持实现的。</p> <p>通常使用数据库事务，需要通过①拿到conn，并将autoCommit设置为false。②通过conn调用rollback回滚事务。而Spring使用事务通过AOP方法，将这两个步骤省略去掉。</p> <p>事务传播：两个Spring事务注解方法之间，如果存在嵌套调用关系，那么<strong>事务作用的范围是否会扩大</strong>，主要包括七个事务传播级别。比如A调用B方法，B进行事务传播注解，那么B抛出异常后，A中其它方法是否会进行回滚。</p> <h3 id="设计高性能接口"><a href="#设计高性能接口" class="header-anchor">#</a> 设计高性能接口</h3> <p>使用Guava的RateLimiter，限制接口访问频率。</p> <p>高并发三架马车：限流、缓存、降级：</p> <ul><li>限流
<ul><li>漏桶算法：请求到达会先放入<strong>队列</strong>，处理器按照固定频率从队列当中取出任务执行。队列满了之后，请求会被抛弃。</li> <li>令牌桶算法：按照一定频率向阻塞队列当中放入令牌，请求到达会向<strong>阻塞队列</strong>当中取出令牌。阻塞队列没有令牌则请求被阻塞。</li></ul></li> <li>降级</li></ul> <h3 id="dubbo协议与http协议"><a href="#dubbo协议与http协议" class="header-anchor">#</a> Dubbo协议与HTTP协议</h3> <p>HTTP协议是应用层协议，它是在TCP之上的，发送数据量会很大，同时每次请求都需要握手挥手。适用于外部系统连接，跨语言通信服务。</p> <p>Dubbo协议是TCP协议进行传输，默认使用TCP长连接，速度更加快，适用于<strong>内部系统</strong>互联。通信是基于Netty的NIO实现的。</p> <p>其中Dubbo泛化调用中创建三个重的实例，向注册中心获取泛化服务对象：</p> <ul><li>应用配置对象</li> <li>注册中心配置对象</li> <li>引用配置对象：指定全限定接口名</li></ul> <p>拿到接口的泛化调用对象之后，通过invoke方法，形参中指定<strong>方法名，参数类型，参数</strong>，即可向服务提供方发起远程调用。</p> <h3 id="孤儿进程-僵尸进程"><a href="#孤儿进程-僵尸进程" class="header-anchor">#</a> 孤儿进程？僵尸进程？</h3> <p>孤儿进程：子进程还没结束，父进程先退出，导致子进程找不到父进程。此时操作系统会设置init进程收留子进程。</p> <p>僵尸进程：子进程退出后，子进程资源没有被回收。父进程如果死循环，一直没有调用wait方法收尸，则会产生僵尸进程。</p> <h3 id="硬中断-软中断"><a href="#硬中断-软中断" class="header-anchor">#</a> 硬中断？软中断？</h3> <p>硬中断：硬件外部设备到达CPU的中断，通知CPU外设状态变更。比如收到数据。</p> <p>软中断：程序产生。</p> <h3 id="jvm栈帧对象释放"><a href="#jvm栈帧对象释放" class="header-anchor">#</a> JVM栈帧对象释放</h3> <p>JVM对每个栈帧只有两个操作：每个方法执行时入栈，执行完毕之后出栈。不存在GC操作，但是有可能出现OOM溢出的情况。</p> <h3 id="kafka消息到消费者是推还是拉模式"><a href="#kafka消息到消费者是推还是拉模式" class="header-anchor">#</a> kafka消息到消费者是推还是拉模式？</h3> <p>结论：kafka采用的<strong>拉模式</strong>。</p> <p>推模式：</p> <ul><li>消息由broker节点推向消费者</li> <li>缺点：消费速率和推送消息速率不一致，消费过慢导致消息会在消费者端堆积爆仓</li> <li>场景：适用于实时性要求高，消费速率较快的场景</li></ul> <p>拉模式</p> <ul><li>消息由消费者<strong>定期</strong>向broker节点拉取</li> <li>缺点：消费者不知道具体什么时候消息到达，因此存在延迟</li> <li>场景：减少broker负担。broker可以感知消费者的消费速度，支持批量传输。</li></ul> <h3 id="为什么要分库-分表-如何分"><a href="#为什么要分库-分表-如何分" class="header-anchor">#</a> 为什么要分库，分表？如何分？</h3> <p>分库分表主要是为了<font color="red"><strong>分散存储，减轻DB性能压力</strong></font>。</p> <p>分库场景：</p> <ul><li>单个数据库的数据量暴增，导致磁盘容量可能会撑爆</li> <li>并发场景下，单库的连接数有限，大量请求到来时数据库可能扛不住</li> <li>如何分库：根据业务模块比如订单库、商品库进行划分，拆分成不同功能的数据库，分担读写压力</li></ul> <p>分表场景：</p> <ul><li>单个数据表数据量达到500w或者2000w可能就需要考虑分表，否则数据量多会增加磁盘IO次数，访问效率降低</li> <li>如何分表：基于某一个字段计算出一个分表键</li></ul> <p>①水平分指的是按照以记录为单位进行切分 ②垂直分库按照业务属性进行划分 ③垂直分表按照字段的活跃性</p> <h3 id="分库和分表存在的问题"><a href="#分库和分表存在的问题" class="header-anchor">#</a> 分库和分表存在的问题？</h3> <p>分表：分表策略如果不对，可能会出现<strong>数据倾斜</strong>的问题，大多数记录分到同一个表上，这种情况下需要更改分表策略。</p> <p>分库：不同数据源会导致事务失效。</p> <p>分库分表存在的查询问题：①join表查询、以及基于一些全表数据的查询group by  order by、分页查询都会出现问题 ②不能使用数据库自增ID，需要使用分布式ID</p> <h2 id="备战2"><a href="#备战2" class="header-anchor">#</a> 备战2</h2> <h3 id="什么是泛型擦除"><a href="#什么是泛型擦除" class="header-anchor">#</a> 什么是泛型擦除？</h3> <p>在JVM编译期间，对象指定泛型在字节码中会被擦除，<strong>统一替换为Object原始类型</strong>。因此可以通过反射，向一个String的列表插入Integer数据。</p> <p>实际使用时，如果向容器插入不同类型的数据会报错，原因在于：</p> <ul><li>编译前进行类型检查，编译时会进行类型擦除</li> <li>基于<font color="red"><strong>引用对象</strong></font>进行检查，如果引用指明了容器类型，那么通过引用调用方法时，则会进行类型检查。</li></ul> <h3 id="mybatis配置xml文件的-与-占位符有什么区别"><a href="#mybatis配置xml文件的-与-占位符有什么区别" class="header-anchor">#</a> mybatis配置xml文件的$与#占位符有什么区别？</h3> <p>#{}占位符一般用于将程序中的变量填入SQL语句中占位符的位置，执行效率更高；</p> <p>${}占位符存在两个问题：①程序传入什么值，最终SQL语句就是什么类型的数据，<strong>不会进行类型转换和区分</strong>，比如“ ‘ name ’  ” ②SQL注入风险，它采用字符串拼接的方式</p> <h3 id="消息队列可以用来做什么-mq和rpc区别是什么"><a href="#消息队列可以用来做什么-mq和rpc区别是什么" class="header-anchor">#</a> 消息队列可以用来做什么？MQ和RPC区别是什么？</h3> <p>消息队列的作用：</p> <ul><li>异步：将执行的流程交给另一个消息监听者消费，和主流程并行执行</li> <li>解耦：减少服务之间的依赖关系；比如A调用B服务，可以将B服务通过MQ抽离出来执行。</li> <li>消息可靠性：MQ通过持久化，重试等机制保证消息不丢失，能够异步消费。</li></ul> <p>RPC场景：①需要服务返回值回调 ②适用于<strong>不同系统不同服务</strong>之间的调用</p> <p>MQ场景：需要解耦程序之间不同组件之间的通信；保证数据安全传输；需要使用同一个系统的上下文信息</p> <h3 id="java内存泄漏-介绍一些四种引用类型"><a href="#java内存泄漏-介绍一些四种引用类型" class="header-anchor">#</a> java内存泄漏？介绍一些四种引用类型？</h3> <p>对象在程序结束，或者程序不再使用的情况下，分配的内存空间没有被回收从而造成内存泄漏。</p> <p>四种引用：</p> <ul><li>强引用：程序代码中的引用默认为强引用</li> <li>软引用：在内存空间不够的情况下进行回收。一般用于有用但是非必需的场景，比如缓存。</li> <li>弱引用：下一次GC一定会被回收。</li> <li>虚引用：随时会被回收。</li></ul> <h3 id="java为什么不支持多继承-什么时候采用继承和组合"><a href="#java为什么不支持多继承-什么时候采用继承和组合" class="header-anchor">#</a> java为什么不支持多继承？什么时候采用继承和组合？</h3> <p>java不支持多继承主要有两个方面：</p> <ul><li>多继承会出现“菱形问题”，重写方法的调用链会出现一些歧义问题。</li> <li>即使技术上能够解决，但是从java面向对象的编程思想上看，java采用继承更多是对当前对象<strong>更高层次的抽象</strong>，而非<strong>更多层次的抽象</strong>。而如果需要“更多层次的拓展”方法，java提供了多接口实现的方法。</li></ul> <p>代码复用包含继承 和 组合两种方式：</p> <ul><li>对象创建：组合需要依次创建多个依赖使用的组合对象；而继承只需要创建子类对象</li> <li>独立与耦合：组合能够使组合对象与整体对象解耦，彼此相对独立：而继承则破坏了父类的封装性</li> <li>可拓展性：组合具有较好的可拓展性，支持调用不同组合类的方法；而对于继承，java只支持单继承，因此灵活性差。</li></ul> <p>使用场景：从抽象概念上来说，如果是is-A类型，A类确实是B类的抽象类型，那么可以使用继承复用父类方法；而除此之外的其它情况，<strong>都优先考虑使用组合</strong>，effective java也是优先推荐使用组合。</p> <h3 id="cglib和jdk动态代理之间的区别"><a href="#cglib和jdk动态代理之间的区别" class="header-anchor">#</a> CGLib和JDK动态代理之间的区别</h3> <p>动态代理技术：</p> <ul><li>运行时生成字节码：本质上是在<strong>程序运行时</strong>生成代理类的字节码文件，然后交给JVM进行类加载，生成代理类信息。其中JDK是通过直接写Class字节码实现，而CGLib是通过ASM字节码框架。</li> <li>实现方式：JDk基于接口实现代理，它只能代理目标类实现的<strong>接口方法</strong>。而CGLib是通过<strong>创建目标类的子类</strong>，在代理类的方法中可以重写目标类的方法，并在方法前后插入自定义增强方法和逻辑。</li> <li>方法调用：JDK调用方法时，是通过反射invoke间接调用；而CGLib则是直接调用父类方法super，性能更好。</li> <li>使用场景：JDK一般用于实现接口的代理，比如Spring AOP和日志；而CGlib则用于不需要实现接口对象的代理，提高性能。</li></ul> <h3 id="分布式锁的方案有哪些"><a href="#分布式锁的方案有哪些" class="header-anchor">#</a> 分布式锁的方案有哪些？</h3> <p>1、数据库：主键ID或唯一字段插入成功才能获取锁；乐观锁，加入版本号字段</p> <p>2、redis：setnx、redisson、lua脚本</p> <p>3、zookeeper：利用临时节点和watch机制，在锁目录下下创建临时节点</p> <h2 id="职业发展开放性问题"><a href="#职业发展开放性问题" class="header-anchor">#</a> 职业发展开放性问题</h2> <h3 id="_1、个人职业规划是什么"><a href="#_1、个人职业规划是什么" class="header-anchor">#</a> 1、个人职业规划是什么？</h3> <p>理想情况下，我期望的职业发展是这样的：</p> <ul><li>前三年时间充分理解和熟悉业务，并结合具体场景拓宽开发技能，向着中级开发工程师，再到高级开发工程师迈进。</li> <li>后两年除了关注产品功能实现之外，还需要能够多关注方案设计等方面，努力向着架构师这个目标发展。</li></ul> <p>当然这个过程是比较理想的，作为一个职场新人小白，我认为最重要的就是提高自己的技术实力和核心竞争力，多向周围有经验的前辈学习和请教，努力追赶他们的步伐，<font color="red"><strong>争取在自己负责的业务上做出更多的成绩</strong></font>，<strong>在专业领域更加具有影响力</strong>，成为团队不可缺少的一环。</p> <p>而对于前面提高的职业规划和晋升方面，我认为个人技术和能力达到要求后，得到公司领导认可，一切都是水到渠成的，因此加入公司后，对于自己更重要的事是如何让自己<strong>快速成长起来，承担起自己的职责</strong>。</p> <h3 id="_2、如何看待拼多多"><a href="#_2、如何看待拼多多" class="header-anchor">#</a> 2、如何看待拼多多？</h3> <p>拼多多作为国内电商领域的龙头企业，它之所以能够成功我认为可以从两个方面探讨：</p> <ul><li>人效：什么是人效，我有看过一些网络上公布的销售额数据，比如淘宝天猫销售额达到五千亿，而咱们多多能干到两千五百亿；但是人家阿里有十几万人，有很多人，而咱们多多好像是只有几千人吧。因此从人效上看别人是和我们比不了的，毕竟员工也需要公司发工资养这嘛。</li> <li>用户/广告：我们知道现在做电商广告就意味着用户，淘宝，京东广告都是满天飞，机场、以及软件进入画面摇一摇都是，而拼多多在广告这方面投入很少，或者说是精准有效，它主要是从两个方面切入：
<ul><li>心智占领：拼多多通过百亿补贴这些活动，在广大用户心中已经树立起了一个便宜的形象，作为用户我肯定希望买东西越便宜越好，因此用户每次想要购买商品的时候，都会先想“要不去拼多多看看吧，那里便宜”。所以我不需要买多少广告就有很多买家用户。</li> <li>精准投放：多多广告主要在一些直播平台或者是视频软件上，比如B站某个up打个广告，然后评论区附带一个链接，从而刺激很大一部分年轻人的进行消费。</li></ul></li></ul> <p>从业务角度说，多多通过百亿补贴等这些活动覆盖大量一二线用户，在电商领域做到头部地位，另外还有社区团购的多多买菜这些业务也都做到了第一梯队的地位，<strong>因此一家公司能够在做好核心业务的同时，能够有能力孵化其它业务，我认为这家公司在组织领导能力、产品创新、技术研发等方面都是很顶尖的</strong>。</p> <h3 id="_3、看过哪些技术博客"><a href="#_3、看过哪些技术博客" class="header-anchor">#</a> 3、看过哪些技术博客</h3> <p>公开的博客：比如左耳耗子老师，还有一些不知名的开发者的博客，他们都会分享一些小场景的设计、重构、SDK开发。</p> <p>Github：有时候没事就上去trending看一下哪些有意思的开源项目；同时也关注了一些知名阿里、美团等一些团队。</p> <h3 id="_4、说说你从这几个项目中学到了什么"><a href="#_4、说说你从这几个项目中学到了什么" class="header-anchor">#</a> 4、说说你从这几个项目中学到了什么？</h3> <p>抽象项目当中：</p> <ul><li>设计模式的使用</li> <li>MQ回调+定时任务消息补偿</li> <li>对于数据库路由组件设计有了更深的理解，开发spring starter</li></ul> <p>网关项目：</p> <ul><li>设计模式的使用</li> <li>Spring拓展点使用</li> <li>Netty搭建服务端，编排通道事件</li> <li>对设计网关有了更深的理解，包括网关节点探活与负载，服务刷新等</li></ul> <h3 id="_5、谈一下你的优缺点"><a href="#_5、谈一下你的优缺点" class="header-anchor">#</a> 5、谈一下你的优缺点</h3> <p>优点：</p> <ul><li>善于复盘总结：有记录博客的习惯。因为写一遍讲述给别人看，也是一种知识输出的手段，可以加强记忆和理解。</li> <li>不服输，坚持：面对问题或者困难能够拆解成一个个子问题，再逐个解决。做事情能够持之以恒。</li> <li>主动，有责任感：能够主动承担一些任务，并且主动交流沟通。研究生阶段主动承担----</li></ul> <p>缺点：</p> <ul><li>有时候结果不符合预期，或者是自己的努力和心血没有得到回报的时候会焦虑吧。</li> <li>英语还能再提高一些。</li></ul> <h3 id="_6、项目中遇到的问题"><a href="#_6、项目中遇到的问题" class="header-anchor">#</a> 6、项目中遇到的问题</h3> <p>在抽奖系统中，执行完抽奖生成抽奖记录响应给用户后，需要异步修改中奖记录状态字段为待发货，实际压测的时候发现会出现消息消费失败的情况，于是查阅了kafka保证消息不丢失的方案。</p> <p>第一步就是根据kafka的一些配置，生产者端设置一个回调，onfailure失败逻辑中重试发送消息；MQ端在配置文件设置单分区多副本，并且acks设置为all，表示消息发送到多个副本之后才返回给生产者回调。</p> <p>但是压测之后还发现<strong>依然存在消息消费失败的情况</strong>，也就是状态位字段不正确。于是就去调研了一下对应的消息自动补偿的方案，普遍做法是后台另启一个定时任务，重新消费失败的记录。</p> <p>第二步的做法就是，在中奖记录表中设置一个MQ状态字段，如果onfailure触发失败回调则将它置为1。定时任务会扫描整个中奖记录表中MQ状态为1的字段，并消费修改这条记录。</p> <h3 id="_7、开发和算法之间的选择"><a href="#_7、开发和算法之间的选择" class="header-anchor">#</a> 7、开发和算法之间的选择</h3> <p>首先兴趣（本科接触了java，对此比较感兴趣，第一点java整个语言的生态比较好，无论是一些issue还是迭代，以及相关组件依赖包的开发，都有很多开发者在参与；第二点选择开发能够接触并且使用到的工具和插件更丰富一些，这点我认为算法是比不上开发的）</p> <p>其次做好开发，需要理解用户各种不同的需求，理解<strong>不同的业务</strong>，因此能够碰到的场景更丰富一些。而算法可能更多的是给到一批数据，期望输出得到什么样的数据。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/blage-coding/blog/edit/master/docs/07.更多/01.面试/10.面试问题合集.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/04/18, 16:33:48</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/b5e3a0/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">分散的面试问题</div></a> <a href="/pages/0f37ca/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">散列与哈希算法</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/b5e3a0/" class="prev">分散的面试问题</a></span> <span class="next"><a href="/pages/0f37ca/">散列与哈希算法</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2024
    <span>blageCoder</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.36a8861c.js" defer></script><script src="/assets/js/2.1ba3a2de.js" defer></script><script src="/assets/js/3.6e4df72f.js" defer></script><script src="/assets/js/421.7854bb4d.js" defer></script>
  </body>
</html>
