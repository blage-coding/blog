(window.webpackJsonp=window.webpackJsonp||[]).push([[356],{674:function(s,t,a){"use strict";a.r(t);var e=a(4),v=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"redis分布式缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式缓存"}},[s._v("#")]),s._v(" Redis分布式缓存")]),s._v(" "),t("h2",{attrs:{id:"_1-redis保证高可用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis保证高可用"}},[s._v("#")]),s._v(" 1.Redis保证高可用")]),s._v(" "),t("ul",[t("li",[s._v("主从模式")])]),s._v(" "),t("p",[s._v("只有一个主节点，和多个从节点，主节点进行写，然后会把数据同步到所有从节点上，而"),t("strong",[s._v("从节点只能读")]),s._v("，用来缓冲高并发读下的流量冲击。缺点在于，主节点宕机后，需要手动设置把一个从节点提到主节点的位置，费时费力并且还会造成一段时间的停止服务。")]),s._v(" "),t("ul",[t("li",[s._v("哨兵模式")])]),s._v(" "),t("p",[t("strong",[s._v("哨兵进程通过发送哨兵命令来监控主从节点是否宕机")]),s._v("，一旦发现主节点挂了，哨兵进程之间就会选举产生新的Master节点。")]),s._v(" "),t("ul",[t("li",[s._v("集群模式")])]),s._v(" "),t("p",[s._v("由于每台Redis机器都存储相同数据，很浪费内存。因此可以让数据分片，"),t("strong",[s._v("每台redis机器上都存储不同的内容")]),s._v("。")]),s._v(" "),t("h2",{attrs:{id:"_2-redis持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis持久化"}},[s._v("#")]),s._v(" 2.Redis持久化")]),s._v(" "),t("h4",{attrs:{id:"rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[s._v("#")]),s._v(" RDB")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("RDB：把内存中的所有数据都记录保存在"),t("strong",[s._v("磁盘")]),s._v("中一个RDB文件。当Redis实例故障重启后，能够从磁盘读取快照文件恢复数据。一般默认关机会自动保存，redis.conf中有触发RDB的机制，save 900 1 表示900秒内如果至少有一个key被修改，则执行bgsave后台保存。")])]),s._v(" "),t("li",[t("p",[s._v("本质是fork主进程得到子进程，子进程复制主进程的页表，通过页表来读取物理内存。")])]),s._v(" "),t("li",[t("p",[s._v("当主进程执行写操作时，采用copy-on -write会先拷贝一份数据，再执行写操作。")])]),s._v(" "),t("li",[t("p",[s._v("缺点：耗时，两次备份之间宕机会丢失数据。")])])]),s._v(" "),t("h4",{attrs:{id:"aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[s._v("#")]),s._v(" AOF")]),s._v(" "),t("ul",[t("li",[s._v("AOF：redis处理的每一个写命令都记录在AOF文件中，Redis只需要重新执行一遍AOF中的写命令就可以恢复数据。实现时通过服务器创建一个"),t("strong",[s._v("没有网络连接的伪客户端")]),s._v("(因为Redis命令只能在客户端上下文中进行)，然后从AOF文件读一条指令，并写入到Redis中，不断重复。")]),s._v(" "),t("li",[s._v("RDB记录的是值，而AOF记录的操作中含有很多无效信息，因此"),t("strong",[s._v("AOF文件会比RDB文件大很多")]),s._v("。")]),s._v(" "),t("li",[s._v("缺点：AOF的文件体积可能会越来越大，比如不断对同一条记录添加删除添加删除。因此可以使用"),t("strong",[s._v("bgrewriteaof")]),s._v("命令，让"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("AOF文件执行重写功能")])]),s._v("，以最少的命令达到同样效果。(比如对相同key的覆盖操作)")],1),s._v(" "),t("li",[t("strong",[s._v("AOF安全性比RDB高，数据恢复优先级先选AOF")]),s._v("。")])]),s._v(" "),t("p",[s._v("系统优先使用AOF持久化进行数据复原；若AOF关闭则使用RDB文件进行还原。")]),s._v(" "),t("h2",{attrs:{id:"_3-redis主从同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis主从同步"}},[s._v("#")]),s._v(" 3.Redis主从同步")]),s._v(" "),t("p",[s._v("主节点负责写操作，其余的所有从节点负责读操作。主节点需要向从节点进行数据同步。")]),s._v(" "),t("ul",[t("li",[s._v("全量同步：执行bgsave生成RDB+新的数据log，都发送给slave进行同步。"),t("strong",[s._v("从节点第一次和主节点会采用全量同步")]),s._v("，master判断replid回复id一致则进行增量同步。")]),s._v(" "),t("li",[s._v("增量同步："),t("strong",[s._v("一般发生在从节点重启的情况")]),s._v("。不需要发送RDB，仅发送offset后的数据。"),t("strong",[t("font",{attrs:{color:"red"}},[s._v("repl_baklog本质是一个环形数组，当master的offset和slave相差超过整个环时，master上还没同步的数据被覆盖了，因此slave需要去主节点内存中做全量同步")]),s._v("。")],1)])]),s._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/image-20230308204421284.50wivh0hnio0.webp",alt:"image-20230308204421284"}}),s._v(" "),t("ul",[t("li",[s._v("优化主从同步\n"),t("ul",[t("li",[s._v("主节点启用"),t("strong",[s._v("无磁盘复制")]),s._v("，因为RDB正常是先写到磁盘中，然后再进行网络传输。启用后RDB直接写到网络IO流中传输，避免了磁盘IO。")]),s._v(" "),t("li",[s._v("Redis单节点内存占用不要太大，减少RDB导致的过多磁盘IO。")]),s._v(" "),t("li",[s._v("提高repl_baklog的大小；从节点及时同步。")]),s._v(" "),t("li",[s._v("减轻集群中master节点同步的压力，主-从-从结构，由同步了的从节点接下去给其它从节点进行同步。")])])])]),s._v(" "),t("h2",{attrs:{id:"_4-哨兵机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-哨兵机制"}},[s._v("#")]),s._v(" 4.哨兵机制")]),s._v(" "),t("p",[s._v("哨兵的作用：①监控主从节点是否按照预期工作②主节点故障后会将一个从节点提升为主节点③通知redis客户端")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("选举规则")]),s._v(" "),t("ul",[t("li",[s._v("哨兵会每隔1秒钟向redis发送ping命令进行心跳监测，如果发现主节点故障，则开始选举新的master。")]),s._v(" "),t("li",[s._v("首先排除和主节点断开时间很长的slave")]),s._v(" "),t("li",[s._v("然后判断从节点的优先级，越小优先级越高")]),s._v(" "),t("li",[s._v("如果优先级一样则判定offset，越大说明数据越新")]),s._v(" "),t("li",[s._v("最后是slave节点的运行id，越小优先级越高。")]),s._v(" "),t("li",[s._v("选举成功后修改原先主节点的配置文件，变成slave节点。")])])]),s._v(" "),t("li",[t("p",[s._v("RedisTemplate 配置读(从)写(主)分离")]),s._v(" "),t("ul",[t("li",[s._v("引入maven依赖")]),s._v(" "),t("li",[s._v("配置"),t("strong",[s._v("哨兵集群")]),s._v("地址(redis-sentinel s1/sentinel.conf 启动哨兵节点)")]),s._v(" "),t("li",[s._v("配置读写分离")])])])]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Bean")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LettuceClientConfigurationBuilderCustomizer")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("clientConfigurationBuilderCustomizer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" clientConfigurationBuilder "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("->")]),s._v(" clientConfigurationBuilder"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("readFrom")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReadFrom")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("REPLICA_PREFERRED")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("ul",[t("li",[s._v("哨兵模式下如何选取新的主节点")])]),s._v(" "),t("p",[s._v("哨兵节点先"),t("strong",[s._v("给redis集群中的节点发送心跳包")]),s._v("，对方未回应且超过一定数量哨兵节点都认为该节点下线，则该节点下线。")]),s._v(" "),t("p",[s._v("如果下线的是主节点，则哨兵集群中会先选择一个哨兵leader(每个哨兵给自己投票)，然后由哨兵leader选主节点。依据的优先级：")]),s._v(" "),t("p",[s._v("①从节点优先级最大的作为主节点②复制偏移最大的作为主节点③runid最小的作为主节点。")]),s._v(" "),t("h2",{attrs:{id:"_5-分片集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-分片集群"}},[s._v("#")]),s._v(" 5.分片集群")]),s._v(" "),t("p",[s._v("解决主从集群①高并发写②海量数据存储的问题。")]),s._v(" "),t("p",[s._v("多个master节点之间相互做哨兵，相互发送心跳监测。")])])}),[],!1,null,null,null);t.default=v.exports}}]);