(window.webpackJsonp=window.webpackJsonp||[]).push([[336],{655:function(a,t,s){"use strict";s.r(t);var n=s(4),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"concurrenthashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),t("h2",{attrs:{id:"_1-concurrenthashmap对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-concurrenthashmap对比"}},[a._v("#")]),a._v(" 1.ConcurrentHashMap对比")]),a._v(" "),t("p",[a._v("HashMap多线程环境下不安全；而HashTable通过synchronized保证线程安全，但是它的锁粒度比较大，是一个全表锁，因此效率会比较低。")]),a._v(" "),t("p",[a._v("两者区别在于①继承父类不同②HashMap扩容时是原来的两倍；而HashTable扩容时容量变为原来的两倍加一。③HashMap"),t("strong",[a._v("解决冲突时")]),a._v("节点数量小于8则用链表解决，大于等于8则用红黑树进行存储，小于6时由转化为链表存储；而HashTable解决冲突都是以链表方式进行存储。")]),a._v(" "),t("h2",{attrs:{id:"_2-jdk7与8的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-jdk7与8的区别"}},[a._v("#")]),a._v(" 2.JDK7与8的区别")]),a._v(" "),t("p",[a._v("ConcurrentHashMap在JDK1.7下使用的是分段锁机制，一个ConcurrentHashMap下维护一个segment数组，每个segment下都有一个HashMap链表并继承ReentrantLock可重入锁。"),t("strong",[a._v("写操作put()时只需要锁住当前Segment不会影响到其它的段，而对于读操作get()则不需要加锁，因为具体的值都是使用volatile来修饰的")]),a._v("。缺点在于定位一个数据需要"),t("strong",[a._v("两次hash")]),a._v("，第一次先找到该数据所在的Segment，然后再定位在链表中的位置。")]),a._v(" "),t("p",[a._v("而JDK1.8下则是使用跟HashMap一样的数据结构，维护一个Node数据，冲突时根据该节点长度来扩展为链表或者是红黑树。控制并发的方式是使用synchronized+CAS，这里"),t("strong",[a._v("sychronized不同于HashTable，它只锁住Node节点链表头")]),a._v("，只要没有Node节点哈希冲突就不会产生并发问题。")]),a._v(" "),t("h2",{attrs:{id:"_3-computeifabsen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-computeifabsen"}},[a._v("#")]),a._v(" 3.computeIfAbsen")]),a._v(" "),t("p",[a._v("computeIfAbsen方法用于"),t("strong",[a._v("获取key对应value")]),a._v("，同时合并首次获取不到"),t("strong",[a._v("执行key插入的操作")]),a._v("。")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" map "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" concurrentHashMap"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("computeIfAbsent")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("strategyId"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" key "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("RATE_TUPLE_LENGTH")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])])])}),[],!1,null,null,null);t.default=e.exports}}]);