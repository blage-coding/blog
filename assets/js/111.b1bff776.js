(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{429:function(t,e,n){"use strict";n.r(e);var s=n(4),o=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_141-环形链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_141-环形链表"}},[t._v("#")]),t._v(" 141.环形链表")]),t._v(" "),e("p",[t._v("给你一个链表的头节点 "),e("code",[t._v("head")]),t._v(" ，判断链表中是否有环。")]),t._v(" "),e("blockquote",[e("p",[t._v("输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。")])]),t._v(" "),e("ol",[e("li",[t._v("遍历一轮链表，让链表中所有结点的指向全部反向，phead和p结点之间断，pnext记录p节点的后继，当pnext最终又指回到最初链表的首节点时，则说明链表存在环。还有一种更通俗的思路，设置快慢指针，每移动一个节点判断是否相碰，如果两个指针最终能够相碰则说明存在环。这两种思路空间复杂度都是O(1)。")]),t._v(" "),e("li",[t._v("如果用哈希表存放记录访问过的ListNode，用containskey()判断是否有环，空间复杂度为O(n)。")])]),t._v(" "),e("p",[t._v("原理：只要一个数组是环形的，那么遍历的过程中，"),e("strong",[t._v("只要两个指针的步长不相同，那么它们总会相遇")]),t._v("(它们走过的路程之差正好等于环形数组大小的整数倍)。")])])}),[],!1,null,null,null);e.default=o.exports}}]);