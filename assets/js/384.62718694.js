(window.webpackJsonp=window.webpackJsonp||[]).push([[384],{704:function(t,s,a){"use strict";a.r(s);var r=a(4),n=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"临时表与内存表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#临时表与内存表"}},[t._v("#")]),t._v(" 临时表与内存表")]),t._v(" "),s("p",[t._v("临时表：分两种，一种是用户自己创建的"),s("strong",[t._v("用户临时表")]),t._v("。另一种是前面讲到的排序时用到的"),s("strong",[t._v("内部临时表")]),t._v("。注意临时表可以使用各种引擎，包括InnoDB，MyISAM")]),t._v(" "),s("p",[t._v("内存表："),s("strong",[t._v("指使用Memory引擎")]),t._v("的表，表数据结构都保存在内存中，一旦重启就会被清空。")]),t._v(" "),s("h2",{attrs:{id:"_1-用户临时表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-用户临时表"}},[t._v("#")]),t._v(" 1.用户临时表")]),t._v(" "),s("p",[t._v("用户临时表一般指的是用户手动创建的临时表。建表语句create temporary table ...")]),t._v(" "),s("h3",{attrs:{id:"_1-1用户临时表特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1用户临时表特点"}},[t._v("#")]),t._v(" 1.1用户临时表特点")]),t._v(" "),s("p",[t._v("用户临时表具有以下特性：")]),t._v(" "),s("ul",[s("li",[s("p",[s("font",{attrs:{color:"red"}},[s("strong",[t._v("临时表写操作会写在磁盘上")])])],1)]),t._v(" "),s("li",[s("p",[t._v("一个临时表只能被创建它的session访问，"),s("strong",[t._v("对其它线程不可见")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("临时表可以与普通表同名，在这种情况下，"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("执行show create和增删改查操作会优先选择临时表")])])],1)]),t._v(" "),s("li",[s("p",[s("font",{attrs:{color:"red"}},[s("strong",[t._v("线程会话结束后，会自动删除临时表")])]),t._v("。执行drop temporary table自动回收。")],1)])]),t._v(" "),s("h3",{attrs:{id:"_1-2用户临时表重名与可见性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2用户临时表重名与可见性"}},[t._v("#")]),t._v(" 1.2用户临时表重名与可见性")]),t._v(" "),s("ul",[s("li",[t._v("物理磁盘上区分")])]),t._v(" "),s("p",[t._v("创建临时表时，MySQL会创建一个"),s("strong",[t._v("frm文件")]),t._v("保存表结构定义(放在临时文件夹目录下，而不是当前数据库目录下)，而"),s("strong",[t._v("文件名的前缀为”#sql进程id_线程id_序列号")]),t._v("“。")]),t._v(" "),s("p",[t._v("因此不同创建的临时表名在磁盘上并不会重名。")]),t._v(" "),s("ul",[s("li",[t._v("内存上区分")])]),t._v(" "),s("p",[t._v("在内存中每个表都对应一个"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("table_def_key")])]),t._v("。普通表的"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("table_def_key")])]),t._v("是通过”库名+表名“得到；而"),s("strong",[t._v("临时表的名称会在普通表的基础上添加”server_id+thread_id")]),t._v("“，有了线程id作为区分后，不同线程创建的同名临时表也会被区分。")],1),t._v(" "),s("h3",{attrs:{id:"_1-3用户临时表的主备复制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3用户临时表的主备复制"}},[t._v("#")]),t._v(" 1.3用户临时表的主备复制")]),t._v(" "),s("p",[s("font",{attrs:{color:"red"}},[s("strong",[t._v("binlog在row格式下，不会记录所有在临时表上的操作日志")])]),t._v("。")],1),t._v(" "),s("p",[t._v("💣问题一：关于临时表的所有操作记录为什么都需要记录到binlog中？")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t_normal "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" temp_t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("上面这条SQL语句中，因为是普通表的更新操作，因此会被记录到binlog中。当它需要在备库中应用binlog恢复时分几种情况：")]),t._v(" "),s("ul",[s("li",[t._v("如果当前binlog设置为row格式，该条日志会记录下所有插入的行数据，因此可以直接应用日志进行更新。")]),t._v(" "),s("li",[t._v("如果当前binlog设置为statment/mixed时，"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("binlog就需要同时记录下所有临时表的所有操作")])]),t._v("。")],1)]),t._v(" "),s("p",[t._v("反过来说对于删除操作也是如此，对于每个drop table操作(后面可以接多个表)，如果删除的表存在临时表，并且binlog格式为row，那么备库执行日志文件时就会报错。"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("因此每个drop命令的binlog日志都会进行重写，保证特殊情况下不能有临时表")])]),t._v("。")],1),t._v(" "),s("p",[t._v("💣问题二：主库上不同线程创建同名的临时表没有问题，那么在备库上有没有问题？")]),t._v(" "),s("p",[t._v("MySQL在记录主库操作时，"),s("strong",[t._v("会把执行这个语句的线程id页一并记录到binlog中")]),t._v("，这样就可以在备库生成对应的"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("table_def_key")])]),t._v("，因此备库上的临时表不存在临时表重名的问题。")],1),t._v(" "),s("h3",{attrs:{id:"_1-4临时表应用-分库分表系统跨库查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4临时表应用-分库分表系统跨库查询"}},[t._v("#")]),t._v(" 1.4临时表应用——分库分表系统跨库查询")]),t._v(" "),s("p",[t._v("假设存在一个大表ht，那么分库分表可以这么做：将表按照字段 f 分成1024个表，然后将它们平均分配在32个MySQL实例上。一般来说会有一个中间层proxy，客户端需要访问数据库需要经过中间层。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230710/image.1cprbobw8vxc.webp",alt:""}})]),t._v(" "),s("p",[t._v("考虑这样一条SQL语句，需要从大表查询到按照t_modified字段排序后的前100条记录。这种情况下因为每个数据表都是按照字段f进行区分的，所以只能"),s("strong",[t._v("将大表所有分区的的数据全都取出来，统一order by")]),t._v("。具体有两方案：")]),t._v(" "),s("p",[t._v("①"),s("strong",[t._v("在proxy层实现排序逻辑")])]),t._v(" "),s("p",[t._v("拿到所有数据后，直接在内存进行计算。这种方案的缺点在于，当表数据量大并且SQL操作复杂时，会给proxy的CPU和内存造成很大的压力。")]),t._v(" "),s("p",[t._v("②"),s("strong",[t._v("汇总实例上建立用户临时表")])]),t._v(" "),s("p",[t._v("本质上有点类似于归并算法。")]),t._v(" "),s("ol",[s("li",[t._v("创建一个新的MySQL实例来进行数据汇总")]),t._v(" "),s("li",[t._v("在汇总库上创建一个临时表temp。")]),t._v(" "),s("li",[t._v("在"),s("strong",[t._v("每个分库的分表")]),t._v("上执行select语句，根据t_modified字段排序取出前100条记录。")]),t._v(" "),s("li",[t._v("把分库的结果都插入到临时表中。")]),t._v(" "),s("li",[t._v("最后在临时表执行select limit 100语句。")])]),t._v(" "),s("p",[t._v("💡实际场景下，计算量往往都是不饱和的，因此可以直接在其中一个分库上进行临时表的汇总和计算。")]),t._v(" "),s("h2",{attrs:{id:"_2-内部临时表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-内部临时表"}},[t._v("#")]),t._v(" 2.内部临时表")]),t._v(" "),s("h3",{attrs:{id:"_2-1场景一、union执行流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1场景一、union执行流程"}},[t._v("#")]),t._v(" 2.1场景一、union执行流程")]),t._v(" "),s("p",[t._v("考虑SQL语句：Query1 union Query2；执行过程如下：")]),t._v(" "),s("ol",[s("li",[t._v("创建一个内部临时表。执行第一个查询Query1，并将所有结果存入临时表。")]),t._v(" "),s("li",[t._v("执行第二个子查询：\n"),s("ul",[s("li",[t._v("如果某行记录插入内存临时表时，表中已经存在相同数据，违反了唯一性约束插入失败。")]),t._v(" "),s("li",[t._v("插入成功。")])])]),t._v(" "),s("li",[t._v("从临时表中取出数据，并返回结果，删除临时表。")])]),t._v(" "),s("p",[t._v("这里临时表起到了”"),s("strong",[t._v("数据暂存")]),t._v("“的功能。")]),t._v(" "),s("p",[t._v("另外如果使用了"),s("strong",[t._v("union all")]),t._v("则表示结果不进行去重，因此"),s("strong",[t._v("不会使用到临时表")]),t._v("，直接执行子查询发给客户端。")]),t._v(" "),s("h3",{attrs:{id:"_2-2场景二、group-by"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2场景二、group-by"}},[t._v("#")]),t._v(" 2.2场景二、group by")]),t._v(" "),s("p",[t._v("假设t1表中a字段存在索引，以下SQL语句按照id%10进行分组统计，并按照m的结果排序后输出。explain后可以发现Extra字段存在using index：temporary：filesort，并且使用上了a字段覆盖索引。")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("group")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("by")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ol",[s("li",[t._v("首先创建临时表，表中存在两个字段m和c，其中m字段作为主键(因为group by的是m)")]),t._v(" "),s("li",[t._v("扫描t1表上a索引字段(覆盖索引)B+树叶子节点，拿到id：\n"),s("ul",[s("li",[t._v("如果id%10得到的结果在m字段下还没有这一条记录，那么插入新的记录(id%10,1)")]),t._v(" "),s("li",[t._v("如果已经存在，则该行记录c字段值加1")])])]),t._v(" "),s("li",[t._v("遍历完后，根据字段m进行排序。根据前面的内容，内存临时表会将数据一行一行放入"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("sort_buffer")])]),t._v("，"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("sort_buffer")])]),t._v("中包括排序字段+位置信息，排序完后从内存临时表按序取数据返回结果集。")],1)]),t._v(" "),s("p",[t._v("如果group by不需要这个排序过程，那么可以直接在后面加上"),s("strong",[t._v("order by null")]),t._v("。")]),t._v(" "),s("p",[s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("tmp_table_size")])]),t._v("：表示内存临时表的大小，如果group by执行时内存临时表放不下所有数据，那么就会"),s("strong",[t._v("转化为磁盘临时表(InnoDB管理的磁盘表，按照索引排序")]),t._v(")。因此可以通过调大这个值"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("避免")])]),t._v("使用磁盘临时表。")],1),t._v(" "),s("h4",{attrs:{id:"_2-2-1group-by优化-直接排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1group-by优化-直接排序"}},[t._v("#")]),t._v(" 2.2.1group by优化——直接排序")]),t._v(" "),s("p",[t._v("可以在SQL加入"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("SQL_BIG_RESULT")])]),t._v("告诉优化器"),s("strong",[t._v("直接使用")]),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("sort_buffer")])]),t._v("排序后的结果进行统计。相当于直接order by，但是因为可以直接利用"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("sort_buffer")])]),t._v("里的结果返回结果集，因此不需要创建临时表，通过回表临时表生成结果集。")],1),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" SQL_BIG_RESULT id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("group")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("by")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230710/image.kqo38zyvrow.webp",alt:""}})]),t._v(" "),s("ol",[s("li",[t._v("扫描t1表a字段索引树，计算id%100的值并放入"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("sort_buffer")])]),t._v("当中，此时"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("sort_buffer")])]),t._v("仅有一个m字段")],1),t._v(" "),s("li",[t._v("全部计算并放入完后，对"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("sort_buffer")])]),t._v("中的m字段值进行排序。")],1),t._v(" "),s("li",[t._v("这样就得到一个有序m字段的有序数组。之后"),s("strong",[t._v("直接统计有序数组内出现的字段值和次数")]),t._v("即可。")])]),t._v(" "),s("p",[s("strong",[t._v("整个过程不需要内存临时表，但还是需要进行排序")]),t._v("。explain后Extra字段using index；filesort。")]),t._v(" "),s("h4",{attrs:{id:"_2-2-2group-by优化-索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2group-by优化-索引"}},[t._v("#")]),t._v(" 2.2.2group by优化——索引")]),t._v(" "),s("p",[t._v("原理：使用内存临时表的原因在于，需要一个临时表保存中间结果，如果当前计算id%10=6时，下一行记录id%10=1则需要回头更新数量。所以如果表内所有的行数据的id%10(也就是"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("排序字段值)本身就是有序")])]),t._v("的，在统计的过程中，遇到第一个id%10=2，那么说明id%10=1的行数为"),s("strong",[t._v("当前的计数器值")]),t._v("。")],1),t._v(" "),s("p",[t._v("上一种优化方法可以省略了内存临时表的操作，进一步优化，有没有办法省略掉在"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("sort_buffer")])]),t._v("中进行排序步骤？")],1),t._v(" "),s("p",[s("strong",[t._v("索引就可以保证这个排序字段有序的条件")]),t._v("，也就是说只需要创建一个排序字段的索引值，那么就可以"),s("strong",[t._v("省略内存临时表temporary+整个排序过程filesort")])]),t._v(" "),s("p",[t._v("如果排序字段是某个函数映射时，可以通过给表t1创建一个新的列，并"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("在该排序字段列上建立索引")])]),t._v("，SQL如下：")],1),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("column")]),t._v(" z "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" generated always "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h4",{attrs:{id:"_2-2-3group-by优化-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3group-by优化-总结"}},[t._v("#")]),t._v(" 2.2.3group by优化——总结")]),t._v(" "),s("p",[t._v("无论是哪一种优化方式，假设group by 字段A，"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("本质上都是要得到一个按照A字段排序后的表结构")])]),t._v("，这样就可以直接读一次这个“有序”表返回结果集，不需要临时表。")],1),t._v(" "),s("p",[t._v("✨"),s("strong",[t._v("如果explain没有using filesort和temporary，则说明使用上了group by字段的索引")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_2-3总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3总结"}},[t._v("#")]),t._v(" 2.3总结")]),t._v(" "),s("p",[t._v("什么情况下MySQL会使用内存临时表？")]),t._v(" "),s("ol",[s("li",[t._v("语句执行过程可以"),s("strong",[t._v("只读一遍表就得到结果")]),t._v("(可以是原表索引，也可以是内存sort_buffer)，那么就不需要中间表。否则就需要临时表保存中间结果。")]),t._v(" "),s("li",[t._v("临时表是二维结构，如果需要用到二维表结构，"),s("strong",[t._v("一个group by作为主键，另一个字段作为其它统计的映射函数")]),t._v("，则优先考虑临时表。")])]),t._v(" "),s("h3",{attrs:{id:"_2-4group-by与distinct性能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4group-by与distinct性能"}},[t._v("#")]),t._v(" 2.4group by与distinct性能")]),t._v(" "),s("p",[t._v("场景：只需要去重结果，不需要执行聚合函数和排序。")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("group")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("by")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("order")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("by")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*Q1*/")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("distinct")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*Q2*/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("Q1执行时不需要排序，并且不需要计数，因此"),s("strong",[t._v("性能上两个SQL语句是相同的")]),t._v("。")]),t._v(" "),s("ol",[s("li",[t._v("首先创建一个临时表，临时表"),s("strong",[t._v("仅有一个字段a(不需要聚合)，且在a上创建一个唯一索引")])]),t._v(" "),s("li",[t._v("遍历表t，依次取出行记录进临时表中进行判断：\n"),s("ul",[s("li",[t._v("如果唯一性约束直接跳过返回，不需要额外计算")]),t._v(" "),s("li",[t._v("否则插入a值作为新的行记录")])])]),t._v(" "),s("li",[t._v("遍历完成后，返回结果集")])]),t._v(" "),s("h2",{attrs:{id:"_3-内存表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存表"}},[t._v("#")]),t._v(" 3.内存表")]),t._v(" "),s("p",[t._v("内存表建表语句为create table ... engine=memory。")]),t._v(" "),s("h3",{attrs:{id:"_3-1内存表的特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1内存表的特性"}},[t._v("#")]),t._v(" 3.1内存表的特性")]),t._v(" "),s("p",[t._v("与InnoDB引擎不同，Memory引擎的数据和索引是分开的：")]),t._v(" "),s("ul",[s("li",[t._v("数据部分"),s("strong",[t._v("以数组的方式单独存放")]),t._v("。并且内存表数据存放顺序按照"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("写入顺序")])]),t._v("存放，是无序的。")],1),t._v(" "),s("li",[t._v("索引上存的是"),s("strong",[t._v("每个数据所在的位置")]),t._v("，即“堆组织表”。查找"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("每个索引地位等同")])]),t._v("，走一次索引后就能拿到数据。")],1)]),t._v(" "),s("p",[t._v("因此在"),s("strong",[t._v("增删改查")]),t._v("上，Memory引擎和InnoDB存在一下不同：")]),t._v(" "),s("ul",[s("li",[t._v("insert数据前删了前面某个id的记录，当数据文件有空洞时，InnoDB为了保证有序性，只能在固定位置插入新的数据；而对于内存表则可以直接插入数据。")]),t._v(" "),s("li",[t._v("数据位置发生改变时，InnoDB只需要调整主键索引树；而对于内存表，则需要修改所有的索引结构，因为每个索引都保存同一个数据的位置。")]),t._v(" "),s("li",[t._v("InnoDB支持边长数据；而内存表中每行数据的长度都是固定的。")]),t._v(" "),s("li",[s("strong",[t._v("内存表的主键索引是哈希索引，不保证有序，因此如果是范围查询则会进行全表扫描")]),t._v("。")])]),t._v(" "),s("p",[t._v("基于以上特性，假设t1是内存表，执行以下语句SQL：")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("id=10的记录发现id=5位置存在空洞后，会插入到空洞位置。因此输出时会发现id=10出现在id=4后面")]),t._v(" "),s("h3",{attrs:{id:"_3-2内存表b-tree索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2内存表b-tree索引"}},[t._v("#")]),t._v(" 3.2内存表B-Tree索引")]),t._v(" "),s("p",[t._v("在内存表中，使用普通索引或者是主键索引查询时，会到"),s("strong",[t._v("内存里的数据数组(按照写入顺序组织")]),t._v(")进行全表扫描。那么有没有办法像InnoDB一样输出按照某个索引字段排序后的结果？")]),t._v(" "),s("p",[t._v("内存表也支持B-Tree索引：")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v(" a_btree_index "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("using")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("btree")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("此时执行select * from t1 where id<5"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("优化器会选择B-Tree索引")])]),t._v("。除非使用force index(primary)id索引，又会变回原本的扫描方式。")],1),t._v(" "),s("h3",{attrs:{id:"_3-3内存表在生产环境下使用的弊端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3内存表在生产环境下使用的弊端"}},[t._v("#")]),t._v(" 3.3内存表在生产环境下使用的弊端")]),t._v(" "),s("p",[t._v("内存表具有如下优势：")]),t._v(" "),s("ul",[s("li",[t._v("Memory引擎支持hash索引")]),t._v(" "),s("li",[t._v("内存表数据都在内存，因此读写速度肯定要比磁盘快")])]),t._v(" "),s("p",[t._v("然而实际上在生产环境并不推荐使用内存表，主要从以下几个方面进行讨论。")]),t._v(" "),s("h4",{attrs:{id:"_3-3-1内存表锁粒度问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1内存表锁粒度问题"}},[t._v("#")]),t._v(" 3.3.1内存表锁粒度问题")]),t._v(" "),s("p",[s("font",{attrs:{color:"red"}},[s("strong",[t._v("内存表不支持行锁，只支持表锁")])]),t._v("。因此一旦一张表有更新，那么整张表上的读写操作都会被锁住。")],1),t._v(" "),s("p",[t._v("在下面例子中sessionA更新操作会锁住t1内存表，导致sessionB进入锁等待状态。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230711/image.3c6mfz73g880.png",alt:""}})]),t._v(" "),s("h4",{attrs:{id:"_3-3-2数据持久化问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2数据持久化问题"}},[t._v("#")]),t._v(" 3.3.2数据持久化问题")]),t._v(" "),s("p",[s("strong",[t._v("内存表一旦重启，数据就会清空")]),t._v("，因此在高可用架构下，数据丢失会影响到其它节点。场景如下：")]),t._v(" "),s("ol",[s("li",[t._v("备库硬件需要升级，因此需要重启，删除内存表t1。此时"),s("strong",[t._v("MySQL为了防止重启后主备不一致，会往binlog写入一条删除t1内存表的操作日志")]),t._v("。")]),t._v(" "),s("li",[t._v("此时客户端向主库发送一条update更新语句，同步时"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("备库就会发现找不到t1内存表，从而主备同步线程停止")])]),t._v("。")],1),t._v(" "),s("li",[t._v("如果是双M结构，主库还需要同步应用备库发送过来的删除日志，就会导致"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("此时主库的内存表也自己删除了")])]),t._v("。")],1)]),t._v(" "),s("h3",{attrs:{id:"_3-4内存表使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4内存表使用场景"}},[t._v("#")]),t._v(" 3.4内存表使用场景")]),t._v(" "),s("p",[t._v("①既然内存表存在以上问题，因此"),s("strong",[t._v("高并发情况下一般建议使用InnoDB表代替内存表")]),t._v("，从读写性能上考虑：")]),t._v(" "),s("ul",[s("li",[t._v("写操作来说，在高并发场景最重要的就是"),s("strong",[t._v("并发度")]),t._v("。内存表是表锁，InnoDB支持行锁，因此InnoDB表>内存表")]),t._v(" "),s("li",[t._v("读操作而言，因为能放进内存表的表本身就不会大，而对于小表来说InnoDB同样也可以直接利用buffer pool的数据页命中来加速读；和内存表直接读内存相比不会差，唯一的区别也就在buffer pool命中率上。因此InnoDB表≈内存表。")])]),t._v(" "),s("p",[t._v("②对于数据量可控，不会耗费过多内存的情况下，比如前面join语句优化，可以使用内存表。")]),t._v(" "),s("p",[t._v("前面在join语句优化时，使用的用户临时表是写在"),s("strong",[t._v("磁盘")]),t._v("上的，而如果这里使用“"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("内存临时表")])]),t._v("”，那么它就可以同时具有内存表优点(快速读写)+临时表优点(线程隔离，主备复制)。具体SQL只需要在"),s("strong",[t._v("创建临时表时设置Memory引擎")]),t._v("即可，具体如下：")],1),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("create temporary table "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("temp_t")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" primary key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("engine"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("memory"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ninsert into temp_t select "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" from t2 where b"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" and b"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nselect "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" from t1 join temp_t on "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("temp_t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("与前面使用的用户临时表对比，优势如下：")]),t._v(" "),s("ul",[s("li",[t._v("插入数据时写内存后，不需要回写磁盘，因此速度更快")]),t._v(" "),s("li",[s("font",{attrs:{color:"red"}},[s("strong",[t._v("内存临时表主键使用哈希索引")])]),t._v("，因此相比于innoDB临时表的B-Tree索引，查找速度更快。")],1)]),t._v(" "),s("p",[t._v("✨在线上无论是主库还是备库，需要设置一个自动巡检的工具，"),s("strong",[t._v("只要发现存在内存表")]),t._v("，都需要马上把该表的引擎改为InnoDB，变成磁盘表。")])])}),[],!1,null,null,null);s.default=n.exports}}]);