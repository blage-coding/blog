(window.webpackJsonp=window.webpackJsonp||[]).push([[410],{729:function(_,v,t){"use strict";t.r(v);var s=t(4),r=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"消息队列面试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息队列面试"}},[_._v("#")]),_._v(" 消息队列面试")]),_._v(" "),v("h2",{attrs:{id:"一、-mq有什么用-有哪些具体的使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、-mq有什么用-有哪些具体的使用场景"}},[_._v("#")]),_._v(" 一、 MQ有什么用？有哪些具体的使用场景？")]),_._v(" "),v("p",[_._v("1.Message Queue消息队列，是一种FIFO的数据结构。消息由生产者发送到MQ进行排队，然后由消费者对信息进行处理。QQ，微信。")]),_._v(" "),v("p",[_._v("2.MQ有三个作用：\n"),v("strong",[_._v("异步")]),_._v("：让消息的发送和接收可以异步进行，生产者不必一直等消费者，此时MQ相当于一个中转站。提高系统响应速度和吞吐量。\n"),v("strong",[_._v("解耦")]),_._v("：可以减少服务之间的影响，提高系统稳定性和"),v("strong",[_._v("独立性")]),_._v("（不同服务分来独立进行）。另外还可以实现"),v("strong",[_._v("数据分发")]),_._v("，生产者发送一条消息，可以由多个消费者处理。\n"),v("strong",[_._v("削峰")]),_._v("：可以应对"),v("strong",[_._v("生产者的流量冲击")]),_._v("(类似于流量控制)，MQ类似于缓存，可以进行高并发量下的流量削峰。")]),_._v(" "),v("p",[_._v("MQ也具有如下缺点:")]),_._v(" "),v("p",[v("strong",[_._v("系统可用性降低")]),_._v(":MQ要保证具有高可用性，否则如果MQ当机，则整个系统都会崩溃用不了。\n"),v("strong",[_._v("数据链路复杂")]),_._v(":本来A只需要直接发消息给C，这时候加入一个中间站B，让A先发给B再发给C，可能出现"),v("strong",[_._v("消息丢失")]),_._v("，"),v("strong",[_._v("消息的转发顺序改变")]),_._v("，"),v("strong",[_._v("消息重复调用")]),_._v("等等问题。\n"),v("strong",[_._v("数据一致性问题")]),_._v(":A发送消息需要B,C共同处理，如果B处理成功，而C处理失败，则会造成数据一致性问题。或者是多个消费者要处理修改同一条消息时，也可能会造成一致性问题。")]),_._v(" "),v("h2",{attrs:{id:"二、mq进行产品选型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、mq进行产品选型"}},[_._v("#")]),_._v(" 二、MQ进行产品选型？")]),_._v(" "),v("p",[_._v("1.kafka:优点是吞吐量大，性能非常好。缺点是"),v("strong",[_._v("会丢数据，功能单一")]),_._v("。")]),_._v(" "),v("p",[_._v("使用场景:日志分析，或者是大数据采集，允许有一小些数据丢失的情况，订单类型的就不适合使用Kafka。")]),_._v(" "),v("p",[_._v("2.RabbitMQ：优点是可靠性高，提供多种功能队列。缺点吞吐量低，"),v("strong",[_._v("消息堆积会影响性能")]),_._v("，消息一来立马处理。")]),_._v(" "),v("p",[_._v("使用场景:小规模场景。")]),_._v(" "),v("p",[_._v("3.RocketMQ:优点高吞吐，高可用，功能全面。缺点是开源版功能不如云上版本，客户端支持JAVA(不能解耦)。")]),_._v(" "),v("h2",{attrs:{id:"三、如何保证消息不丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、如何保证消息不丢失"}},[_._v("#")]),_._v(" 三、如何保证消息不丢失？")]),_._v(" "),v("p",[_._v("1.生产者发送消息时会丢失。")]),_._v(" "),v("p",[_._v("解决方法: ①kafka中生产者会注册一个回调函数，当"),v("strong",[_._v("MQ收到消息后，会发送一个请求去调用回调函数")]),_._v("，来告诉生产者已经收到消息，如果生产者发现回调函数没被调用，则重发消息。")]),_._v(" "),v("p",[_._v("②RocketMQ当中还提供"),v("strong",[_._v("事务消息机制")]),_._v("，保证"),v("strong",[_._v("本地事务")]),_._v("和"),v("strong",[_._v("消息发送原子性")]),_._v("一致性，同时失败或成功。过程如下:")]),_._v(" "),v("p",[_._v("首先生产者会先发送一个半消息(对于消费者不可见)，"),v("strong",[_._v("目的在于确认MQ服务正常")]),_._v("，然后MQ会发送半消息响应。生产者"),v("strong",[_._v("收到半消息响应后")]),_._v("(说明MQ正常)，然后"),v("strong",[_._v("执行本地事务")]),_._v("(往数据库插入消息) 。")]),_._v(" "),v("p",[_._v("执行完后生产者就会往MQ发送真正的事务消息，并且"),v("strong",[_._v("附带本地事务的状态")]),_._v("(包括成功，失败，未知)，成功就会推送给消费者进行下一步事务处理，失败MQ就不发了。")]),_._v(" "),v("p",[_._v("而如果MQ收到的状态是未知的，表明本地事务可能还没有执行完，那么就"),v("strong",[_._v("MQ就会反复轮询本地事务进行回查")]),_._v("，看他完成没有， 生产者就会"),v("strong",[_._v("检查本地数据库mysql是否插入成功")]),_._v("。然后发送事务状态给MQ重复上述过程。最多回查15次，如果还是未知就说明本地事务超时就丢弃。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/a7b00da1aaf04c5698bc26b955ca8223.s3xiryd4csg.webp",alt:"Snipaste_2022-02-17_12-31-03"}})]),_._v(" "),v("p",[_._v("消息事务的应用场景很多，比如先完成在支付系统支付后才能发送MQ进行手续费处理或者清空购物车。假如要设计一个5min内付款功能，"),v("strong",[_._v("因为只要生产者第一次发送事务状态是未知的，那么就可以触发整个回查机制")]),_._v("，所以我们只要保证5min内回查15次支付系统看是否支付即可。注意，"),v("strong",[_._v("消息事务仅保证了分布式事务一半的原子性")]),_._v("。")]),_._v(" "),v("p",[_._v("2.MQ中消息主从同步时会丢失。")]),_._v(" "),v("p",[_._v("RocetkMQ：①普通集群中，Master和Slave主从模式配合进行"),v("strong",[_._v("消息主从复制")]),_._v("，达到"),v("strong",[_._v("高可用性")]),_._v("。消息同步方式分为同步和异步。")]),_._v(" "),v("p",[v("strong",[_._v("同步")]),_._v("表示生产者往MQ发起消息时，Master立即往Slave消息同步存盘，"),v("strong",[_._v("存盘完后才向生产者响应")]),_._v("。好处是一定能够"),v("strong",[_._v("保证消息同步保存")]),_._v("，但是会产生阻塞。")]),_._v(" "),v("p",[v("strong",[_._v("异步")]),_._v("表示生产者发送消息后，Master"),v("strong",[_._v("立即返回响应生产者")]),_._v("，然后才向Slave存盘，好处是"),v("strong",[_._v("效率更高")]),_._v("，但是可能有丢消息风险。")]),_._v(" "),v("p",[_._v("kafka：通常使用在允许消息少量丢失场景，丢失不可完全避免。")]),_._v(" "),v("p",[_._v("3.MQ时基于内存工作的，因此保存消息到硬盘时可能会丢失。")]),_._v(" "),v("p",[_._v("Rocket MQ:同步刷盘和异步刷盘。同步刷盘当消息写入内存后，通知线程立即刷盘，"),v("strong",[_._v("写入磁盘完成后才向应用返回写成功信息")]),_._v("，消息安全性高，效率低；异步则是"),v("strong",[_._v("只有当内存中的消息积累到一定程度，才统一触发写磁盘")]),_._v("。")]),_._v(" "),v("p",[_._v("4.MQ发送给消费者时可能会丢失。")]),_._v(" "),v("p",[_._v("队列当中有一个offset偏移量，标记消费者消费到哪个消息。")]),_._v(" "),v("p",[_._v("消费者如果是同步机制，执行完事务后才返回offset,则不会造成消息丢失；而如果进行异步机制，消费者收到消息立马提交offset给MQ，此时MQ中的offset就会往后偏移，消费者再处理事务，那么如果执行本地事务写数据库失败，下一次消息事务处理就是另外一条，先前失败的订单则会丢失。 因此"),v("strong",[_._v("消费者端一定要采用同步机制")]),_._v("。")]),_._v(" "),v("p",[_._v("整个消息丢失情况如下:")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/4f575bf9ff3148b98a3b3555604afe0c.1e7iqbiqyjnk.webp",alt:"Snipaste_2022-02-17_11-40-32"}})]),_._v(" "),v("h2",{attrs:{id:"四、如何保证信息消费幂等性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、如何保证信息消费幂等性"}},[_._v("#")]),_._v(" 四、如何保证信息消费幂等性?")]),_._v(" "),v("p",[_._v("由于网络等因素，使得MQ发送重复消息给消费者消费的问题。所有MQ产品并没有提供主动解决幂等性机制，需要消费者自己控制。"),v("strong",[_._v("数据库查询")]),_._v("，"),v("strong",[_._v("删除")]),_._v("操作是天然的幂等操作。")]),_._v(" "),v("p",[_._v("1.通过"),v("strong",[_._v("乐观锁")]),_._v("，给每一个业务数据增加一个版本号属性，"),v("strong",[_._v("每次本地事务完成更新后版本号+1")]),_._v("，当消息数据版本号和当前数据库的版本号不一致，则拒绝更新。")]),_._v(" "),v("p",[_._v("2.通过一个"),v("strong",[_._v("全局的带有业务标识")]),_._v("的OrderID进行判断， 比如订单编号，消费者获得消息后会先验证该id是否已经被消费，如果没有则进行消息处理后，"),v("strong",[_._v("把id存入redis设置为已消费。")])]),_._v(" "),v("h2",{attrs:{id:"五、如何保证消息的顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、如何保证消息的顺序"}},[_._v("#")]),_._v(" 五、如何保证消息的顺序？")]),_._v(" "),v("p",[_._v("1.MQ只需要保证局部有序(对于一个业务而言)，不需要全局有序。 如果只是有一个队列的话，队列天生就是可以保证FIFO有序的。但是在分布式场景下，会有多个MQ队列，生产者发送的消息会考虑充分利用MQ资源，并不会都在同一个队列中，消费者取出消息时也是分布式的读取处理消息。因此不能保证单个业务消息有序。")]),_._v(" "),v("p",[_._v("2.RocketMQ在生产者和MQ间有一个Message selector,它保证"),v("strong",[_._v("一组有序消息一定是在同一个队列中的")]),_._v("。而对于消费者来说，它"),v("strong",[_._v("一次仅消费整个队列的消息(如果是分布式接收处理消息事务，则按序把消息放在同一个队列并锁住，消费完这个队列再消费下一个 )")]),_._v("。RocketMQ中有完整的设计。")]),_._v(" "),v("h2",{attrs:{id:"六、如何保证消息的高效读写"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、如何保证消息的高效读写"}},[_._v("#")]),_._v(" 六、如何保证消息的高效读写？")]),_._v(" "),v("p",[_._v("传统的文件发送过程首先"),v("strong",[_._v("通过read()调用进行上下文切换(用户态->核心态)")]),_._v("，把磁盘文件读取到内核空间中缓冲区，因为JAVA程序运行用户空间，因此需要从"),v("strong",[_._v("内核空间缓冲区")]),_._v("再拷贝到"),v("strong",[_._v("用户空间内存缓冲区")]),_._v("中，并"),v("strong",[_._v("返回read()调用(又引发一次上下文切换，内核态->用户态")]),_._v("),这时候应用程序才能操作文件数据；然后调用send()上下文切换，用户空间拷贝到内核空间的Socket 缓冲区(与目标套接字相关联)；最后send()返回调用，通过DMA把数据从内存拉到网卡缓冲区。")]),_._v(" "),v("p",[_._v("其中第二次和第三次是比较耗费资源的，因为需要内核态和用户态之间来回切换并且CPU拷贝开销大。而"),v("strong",[_._v("第一次和第四次是通过DMA拷贝")]),_._v("，外设直接与系统内存交换数据，不需要通过CPU。传统的文件发送过程如下:")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/3d3ba60d4ff64731b565748e4d00b3f7.1b9v9hkjcy80.webp",alt:"Snipaste_2022-02-17_23-41-44"}})]),_._v(" "),v("p",[_._v("kafka和RocketMQ背后都是通过"),v("strong",[_._v("零拷贝")]),_._v("来优化文件读写。")]),_._v(" "),v("p",[_._v("1.Mmap。应用进程系统调用mmap()并返回后，拿到文件的映射，"),v("strong",[_._v("用户空间和内核态缓冲区共享一个缓冲区")]),_._v("，然后再依次拷贝到-Socket缓冲区->NIC 缓冲区。好处是"),v("strong",[_._v("可以直接在用户空间对内存中的文件进行操作,缺点在于建立映射开销大")]),_._v("。RocketMQ通过Mmap写日志文件。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/e1554ae5a8da436db23760fcc43bbab7.41hwog13qzy0.webp",alt:"Snipaste_2022-02-18_00-00-11"}})]),_._v(" "),v("p",[_._v("2.sendfile+DMA 。如果文件不需要操作内容，可以"),v("strong",[_._v("直接从内核空间读写缓冲区拷贝到Socket缓冲区")]),_._v("，JAVA通过transferTo()方法可以实现。第二步，读写缓冲区"),v("strong",[_._v("把包含有文件长度和位置的文件描述符发到套接字缓冲区中")]),_._v("，"),v("strong",[_._v("给用户区返回send()调用上下文切换")]),_._v("。利用"),v("strong",[_._v("网卡DMA控制器可以直接访问内存中的文件描述符")]),_._v("，把文件直接拷贝到网卡缓冲区中。总共只需要两次DMA拷贝，以及两次上下文切换。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/78794f55c4da4e6090006b8165342f47.3fkf8oj60ci0.webp",alt:"Snipaste_2022-02-17_23-54-11"}})]),_._v(" "),v("p",[v("strong",[_._v("kafka索引文件使用的是mmap+write，数据文件使用的是sendfile")]),_._v("。假设有10个消费者，那么仅需要拷贝1(读写缓冲区)+10(10份文件网卡缓冲区)=11次，相比传统方法需要的40次而言大大减少。")]),_._v(" "),v("p",[_._v("因此实际上的零拷贝指的是在用户空间不需要拷贝，并不是真正的不需要拷贝。")]),_._v(" "),v("h2",{attrs:{id:"七、使用mq如何保证分布式事务最终一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七、使用mq如何保证分布式事务最终一致性"}},[_._v("#")]),_._v(" 七、使用MQ如何保证分布式事务最终一致性？")]),_._v(" "),v("p",[_._v("分布式事务：就是指业务相关的操作需要"),v("strong",[_._v("同时成功或者同时失败")]),_._v("，比如过下单可以分为支付和下物流单两个操作，不可能会有你支付交钱了，人家没有把东西发给你的情况。")]),_._v(" "),v("p",[_._v("最终一致性是指，只要求最终事务之间状态是对齐的，中间允许有不对齐状态，比如A完成了B没完成，但是最后两个事务一定是同时完成或者未完成的。\n强一致性要求每时每刻事务之间状态都是对齐相同的。")]),_._v(" "),v("p",[_._v("MQ要保证事务最终一致性需要保证两点:")]),_._v(" "),v("p",[_._v("1.生产者需要保证百分百的消息投递。通过事务消息机制。")]),_._v(" "),v("p",[_._v("2.消费者需要保证幂等性消费。唯一全局业务ID。")])])}),[],!1,null,null,null);v.default=r.exports}}]);