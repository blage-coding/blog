(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{437:function(t,s,n){"use strict";n.r(s);var e=n(4),l=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_23-合并k个升序链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_23-合并k个升序链表"}},[t._v("#")]),t._v(" 23.合并k个升序链表")]),t._v(" "),s("p",[t._v("给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。")]),t._v(" "),s("blockquote",[s("p",[t._v("输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]")])]),t._v(" "),s("ol",[s("li",[t._v("合并两个链表时，插入链表插入时要保存插入节点后继，被插入链表要保存节点后移时要保存当前节点前驱。答案给的一种是分治，但个人觉得一个循环就能解决的问题为什么非要写个递归函数实现呢。")])])])}),[],!1,null,null,null);s.default=l.exports}}]);