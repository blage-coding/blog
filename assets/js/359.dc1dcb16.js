(window.webpackJsonp=window.webpackJsonp||[]).push([[359],{679:function(t,v,e){"use strict";e.r(v);var s=e(4),_=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"内存策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存策略"}},[t._v("#")]),t._v(" 内存策略")]),t._v(" "),v("h2",{attrs:{id:"过期策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过期策略"}},[t._v("#")]),t._v(" 过期策略")]),t._v(" "),v("p",[t._v("expire设置过期TTL")]),t._v(" "),v("p",[t._v("在Redis数据库结构体中，"),v("font",{attrs:{color:"red"}},[v("strong",[t._v("有两个字典Dict结构保存键值对，一个用来记录key-value，另一个用来记录key-TTL")])]),t._v("。")],1),t._v(" "),v("p",[t._v("惰性删除：当一个key的TTL到期后，并不是立刻删除，而是在"),v("strong",[t._v("访问key")]),t._v("时检查它的存活时间，过期才执行删除。问题：如果不去访问那么就永远不会删除")]),t._v(" "),v("p",[t._v("周期删除：通过定时任务，周期性的抽样部分过期key进行删除。")]),t._v(" "),v("h2",{attrs:{id:"淘汰策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#淘汰策略"}},[t._v("#")]),t._v(" 淘汰策略")]),t._v(" "),v("p",[t._v("内存达到设置的阈值，Redis主动挑选部分key删除以释放更多内存。Redis会在任何命令执行之前进行内存检查。")]),t._v(" "),v("p",[t._v("淘汰策略：allkeys—针对所有字典中的所有keys。volatile—针对所有设置了过期时间TTL的key")]),t._v(" "),v("p",[t._v("lru：每个key上次被访问的时间距离现在越久，被淘汰的优先级越高。")]),t._v(" "),v("p",[t._v("lfu：每个key被访问的频率越少，被淘汰的优先级越高。计数器随着访问次数增加，加一的概率逐渐降低。")]),t._v(" "),v("p",[t._v("根据淘汰策略，池子按照升序排列，值越大的淘汰的优先级越高。(now-LRU，255-LFU，maxTTL-TTL)")]),t._v(" "),v("h2",{attrs:{id:"解决redis内存饱和"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决redis内存饱和"}},[t._v("#")]),t._v(" 解决Redis内存饱和")]),t._v(" "),v("p",[t._v("1.使用内存淘汰策略，常见的淘汰算法有FIFO，LRU，LFU("),v("strong",[t._v("数据引用次数最小的淘汰")]),t._v("，是一种全局的算法，不关注短期是否被使用)")]),t._v(" "),v("p",[t._v("2.惰性过期："),v("strong",[t._v("过期的数据被再次访问时")]),t._v("，才判断是否过期并进行删除。缺点在于极端情况下过期数据会占据大量内存，而不被删除释放。")]),t._v(" "),v("p",[t._v("定期过期：每隔一段时间，CPU扫描内存删除过期数据。")])])}),[],!1,null,null,null);v.default=_.exports}}]);