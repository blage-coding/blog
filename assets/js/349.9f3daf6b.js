(window.webpackJsonp=window.webpackJsonp||[]).push([[349],{668:function(t,a,s){"use strict";s.r(a);var e=s(4),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"executor框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#executor框架"}},[t._v("#")]),t._v(" Executor框架")]),t._v(" "),a("p",[t._v("Java中将任务和调度分开。任务单元为Runnbale，而"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("执行机制")])]),t._v("和"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("任务调度")])]),t._v("由Executor框架提供。")],1),t._v(" "),a("p",[t._v("在JVM线程模型中，java.lang.Thread与系统线程是一一对应的。Executor负责若干个任务映射成对应的Java线程，操作系统底层再调度系统线程。")]),t._v(" "),a("h2",{attrs:{id:"_1-executor框架简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-executor框架简介"}},[t._v("#")]),t._v(" 1.Executor框架简介")]),t._v(" "),a("p",[t._v("框架主要包含三个部分：")]),t._v(" "),a("ul",[a("li",[a("font",{staticStyle:{background:"rgb(255, 240, 102)"}},[a("strong",[t._v("Runnable接口不会返回结果，而Callable可以返回结果")])]),t._v("。")],1),t._v(" "),a("li",[t._v("Executor接口创建线程执行任务。")]),t._v(" "),a("li",[t._v("Future接口用于获取异步计算的结果。FutureTask实现类。")])]),t._v(" "),a("p",[t._v("Executors是工厂类，用于创建两种类型的线程池：")]),t._v(" "),a("h2",{attrs:{id:"_2-threadpoolexecutor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-threadpoolexecutor"}},[t._v("#")]),t._v(" 2.ThreadPoolExecutor")]),t._v(" "),a("p",[t._v("下面介绍如下三种线程池：")]),t._v(" "),a("h3",{attrs:{id:"fixedthreadpool"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fixedthreadpool"}},[t._v("#")]),t._v(" FixedThreadPool：")]),t._v(" "),a("ul",[a("li",[t._v("线程数量：核心线程数、最大线程数都设置为"),a("strong",[t._v("固定值")]),t._v("。")]),t._v(" "),a("li",[t._v("任务队列：使用无界队列，不存在拒绝任务的情况。"),a("strong",[t._v("存在任务过多内存移除的风险")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"singlethreadexecutor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#singlethreadexecutor"}},[t._v("#")]),t._v(" SingleThreadExecutor")]),t._v(" "),a("ul",[a("li",[t._v("线程数量：核心线程数、最大线程数都设置为1.")]),t._v(" "),a("li",[t._v("任务队列：使用无界队列。反复从任务队列取出并执行，因此"),a("strong",[t._v("任务执行是有序")]),t._v("的。")])]),t._v(" "),a("h3",{attrs:{id:"cachedthreadpool"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cachedthreadpool"}},[t._v("#")]),t._v(" CachedThreadPool")]),t._v(" "),a("p",[t._v("线程队列执行poll将空闲线程出队，如果60s内没有任务offer进来，那么该线程直接终止。")]),t._v(" "),a("ul",[a("li",[t._v("线程数量：核心线程数为0，最大线程数为MAX_VALUE。")]),t._v(" "),a("li",[t._v("任务队列：使用无容量的SynchronousQueue。"),a("strong",[t._v("必须等队列中的添加元素被消费后才能继续添加新的元素")]),t._v("，否则会被阻塞。")]),t._v(" "),a("li",[t._v("适用于执行"),a("strong",[t._v("大量短期异步任务")])])]),t._v(" "),a("h2",{attrs:{id:"_3-scheduledthreadpoolexecutor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-scheduledthreadpoolexecutor"}},[t._v("#")]),t._v(" 3.ScheduledThreadPoolExecutor")]),t._v(" "),a("p",[t._v("可以"),a("strong",[t._v("延期执行任务")]),t._v("，适用于"),a("font",{staticStyle:{background:"rgb(255, 240, 102)"}},[a("strong",[t._v("多个后台线程执行周期任务")])]),t._v("。")],1),t._v(" "),a("p",[t._v("每个任务对象ScheduledFutureTask主要几个成员变量：")]),t._v(" "),a("ul",[a("li",[t._v("time：开始执行时刻")]),t._v(" "),a("li",[t._v("period：任务执行的周期(过了多久要执行下一次)")])]),t._v(" "),a("p",[t._v("任务队列使用"),a("strong",[t._v("DelayQueue")]),t._v("，会根据"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("任务的开始执行时刻进行优先级排序")])]),t._v("：")],1),t._v(" "),a("ul",[a("li",[t._v("取出最早time的任务，并执行")]),t._v(" "),a("li",[t._v("修改time为下次执行的时间currentTime+period")]),t._v(" "),a("li",[t._v("放回任务队列中")])]),t._v(" "),a("h2",{attrs:{id:"_4-futuretask"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-futuretask"}},[t._v("#")]),t._v(" 4.FutureTask")]),t._v(" "),a("p",[t._v("注意："),a("font",{staticStyle:{background:"rgb(255, 240, 102)"}},[a("strong",[t._v("本身FutureTask并不是一个线程，需要启动一个新的线程执行。在另一个调用get()的线程才能被阻塞")])]),t._v("。")],1),t._v(" "),a("h3",{attrs:{id:"api用例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api用例"}},[t._v("#")]),t._v(" API用例")]),t._v(" "),a("p",[t._v("FutureTask提供了以下异步任务方法和API：")]),t._v(" "),a("ul",[a("li",[t._v("FutureTask本身实现了Runnable接口，因此可以执行run方法执行任务。")]),t._v(" "),a("li",[a("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[a("strong",[t._v("get()")])]),t._v("方法会阻塞“调用线程”，知道任务执行结束并返回结果。")],1),t._v(" "),a("li",[a("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[a("strong",[t._v("cancel(")]),t._v(")")]),t._v("方法会导致任务永远不会被执行。")],1)]),t._v(" "),a("p",[t._v("使用时创建FutureTask任务，并交给线程池或创建一个新线程来执行。通过get()方法阻塞当前线程获取结果。")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FutureTask")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" future "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FutureTask")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Job")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExecutorService")]),t._v(" executorService "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Executors")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("newFixedThreadPool")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nexecutorService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("submit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("future"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" integer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" future"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("h3",{attrs:{id:"源码解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码解析"}},[t._v("#")]),t._v(" 源码解析")]),t._v(" "),a("p",[t._v("内部是通过AQS实现一个同步类Sync，通过sync来控制执行状态。")]),t._v(" "),a("h4",{attrs:{id:"get-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-方法"}},[t._v("#")]),t._v(" get()方法")]),t._v(" "),a("p",[t._v("通过"),a("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[a("strong",[t._v("awaitDone()")])]),t._v("方法阻塞线程：")],1),t._v(" "),a("ul",[a("li",[a("p",[t._v("自旋判断当前任务执行状态"),a("strong",[t._v("state")]),t._v("，若执行完毕则直接返回结果。否则按序执行如下步骤：")])]),t._v(" "),a("li",[a("p",[t._v("CAS向等待队列加入当前get调用的线程(创建WaitNode节点)，存在多个线程都调用get阻塞的情况。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("LockSupport.part")]),t._v("阻塞当前线程")])])]),t._v(" "),a("h4",{attrs:{id:"run-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#run-方法"}},[t._v("#")]),t._v(" run()方法")]),t._v(" "),a("p",[t._v("执行完任务后，CAS修改线程状态，并最后通过"),a("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[a("strong",[t._v("finishCompletion()")])]),t._v("方法唤醒等待队列的线程：")],1),t._v(" "),a("ul",[a("li",[t._v("CAS获取waiters等待队列，并置为空。(实际上这里不需要多线程控制)")]),t._v(" "),a("li",[t._v("依次取出每个等待队列节点，并执行"),a("strong",[t._v("LockSupport.unpark")]),t._v("唤醒线程。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);