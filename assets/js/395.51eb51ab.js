(window.webpackJsonp=window.webpackJsonp||[]).push([[395],{714:function(v,_,t){"use strict";t.r(_);var s=t(4),r=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"mysql面试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql面试"}},[v._v("#")]),v._v(" MySQL面试")]),v._v(" "),_("h2",{attrs:{id:"一、什么是脏读-幻读-不可重复读-如何处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是脏读-幻读-不可重复读-如何处理"}},[v._v("#")]),v._v(" 一、什么是脏读，幻读，不可重复读？如何处理？")]),v._v(" "),_("p",[v._v("1.脏读：事务读取数据"),_("strong",[v._v("读取到其它事务未提交的数据(更新)")]),v._v("。")]),v._v(" "),_("p",[v._v("不可重复读：在一个事务过程中"),_("strong",[v._v("多次查询结果")]),v._v("不一致("),_("strong",[v._v("读到其他事务已经提交的数据")]),v._v(")。")]),v._v(" "),_("p",[v._v("幻读：在一个事务过程中"),_("strong",[v._v("多次查询的记录数")]),v._v("不一致("),_("strong",[v._v("重点在于insert和delete")]),v._v(")。")]),v._v(" "),_("p",[v._v("问题的根本原因在于MySQL事务的并发性所引起的。")]),v._v(" "),_("p",[v._v("2.解决方式：加锁，事务隔离，MVCC。")]),v._v(" "),_("p",[v._v("加锁：①脏读：类似于读者写者问题，对数据库的操作同时只能有一个事务写多个事务读。在修改时增加一个"),_("strong",[v._v("排他锁")]),v._v("，在读取时增加一个"),_("strong",[v._v("共享锁")]),v._v("，多个事务只要是读操作就可以获得共享锁。")]),v._v(" "),_("h2",{attrs:{id:"二、事务基本特性和隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、事务基本特性和隔离级别"}},[v._v("#")]),v._v(" 二、事务基本特性和隔离级别？")]),v._v(" "),_("p",[v._v("1.多个数据操作组成一个完整的事务单元，事务内的所有操作要么同时成功要么同时失败。事务特性包括ACID：")]),v._v(" "),_("p",[_("strong",[v._v("原子性")]),v._v("atomicity：事务是不可分割的，要么同时成功要么完全失败。")]),v._v(" "),_("p",[_("strong",[v._v("一致性")]),v._v("consistenct：事务内的操作保持一致性，"),_("strong",[v._v("如果中间有操作失败，则要对前面的操作进行回滚")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("隔离性")]),v._v("isolation：事务在进行数据操作时，要进行事务隔离，防止多个事务之间相互干扰。")]),v._v(" "),_("p",[_("strong",[v._v("持久性")]),v._v("durability：事务一旦提交，对应数据状态就会永久保存到数据库中。即使系统故障也不会丢失。")]),v._v(" "),_("p",[v._v("2.事务隔离级别：set "),_("strong",[v._v("transaction level")]),v._v(" xx设置"),_("strong",[v._v("下次事务")]),v._v("隔离级别。MySQL当中有五种隔离级别：")]),v._v(" "),_("p",[v._v("NONE:不使用事务。")]),v._v(" "),_("p",[v._v("READ UNCOMMITED:允许脏读。")]),v._v(" "),_("p",[_("strong",[v._v("READ COMMITED:防止脏读，最常用隔离级别。")])]),v._v(" "),_("p",[v._v("REPEATABLE READ:防止脏读和不可重复读。MySQL默认。")]),v._v(" "),_("p",[v._v("SERIALIZABLE：事务串行，可以防止脏读，幻读，不可重复读。")]),v._v(" "),_("p",[_("strong",[v._v("隔离级别越高，事务安全性越高，但是事务性能越低")]),v._v("。"),_("strong",[v._v("一般保证数据库的并发性，让它的性能更多的提高，而把事务安全问题移到应用程序中来进行控制。")])]),v._v(" "),_("h2",{attrs:{id:"三、mysql的锁有哪些-什么是间隙锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、mysql的锁有哪些-什么是间隙锁"}},[v._v("#")]),v._v(" 三、MySQL的锁有哪些？什么是间隙锁？")]),v._v(" "),_("p",[v._v("1.按照粒度可分为如下：")]),v._v(" "),_("p",[v._v("①行锁：粒度小，但是加锁资源消耗开销大，InnoDB支持。又分为共享锁和排他锁(InnoDB会自动对增删改加排他锁，查询也可以手动添加select * where "),_("strong",[v._v("FOR UPDATE")]),v._v(")，自增锁(用来维护自增序列)。")]),v._v(" "),_("p",[v._v("②表锁：粒度大，开销小。")]),v._v(" "),_("p",[v._v("③全局锁：粒度大，"),_("strong",[v._v("加锁后数据库处于只读状态，只允许读操作")]),v._v("，所有修改操作都会被挂起。一般用于"),_("strong",[v._v("全库备份")]),v._v("时候。")]),v._v(" "),_("p",[v._v("2.InnoDB常见锁算法：")]),v._v(" "),_("p",[v._v("①比方说我有一个user表，其中的key userid有三个值(1,4,9)。如果事务进行update set xx where userid=4,那么就会执行"),_("strong",[v._v("记录锁(具体执行操作某一条记录时锁住该记录,且记录存在)")]),v._v("，用于"),_("strong",[v._v("唯一索引")]),v._v("。")]),v._v(" "),_("p",[v._v("②间隙锁："),_("strong",[v._v("RR隔离级别下用于锁住某个开区间")]),v._v("，比如要select xx where xx BETWEEN A and B，"),_("strong",[v._v("目的是防止其他事务在间隔中插入数据，产生幻读")]),v._v("。一般用于"),_("strong",[v._v("①非唯一索引②唯一索引等值查询记录不存在③范围查询")]),v._v("。")]),v._v(" "),_("p",[v._v("③next key临键锁:对非唯一索引进行更新for update等操作时，会获得"),_("strong",[v._v("该条记录所在的左开右闭区间的锁")]),v._v("。当希望禁用间隙锁提高系统性能，可以将隔离级别降为RC使用NEXT key。"),_("strong",[v._v("仅仅针对于非唯一索引")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"四、mysql的索引结构是怎么样的-为什么用b-树不用b树-什么是主索引和辅助索引-聚簇索引和非聚簇索-什么是索引覆盖-非聚簇索引一定会导致回表吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、mysql的索引结构是怎么样的-为什么用b-树不用b树-什么是主索引和辅助索引-聚簇索引和非聚簇索-什么是索引覆盖-非聚簇索引一定会导致回表吗"}},[v._v("#")]),v._v(" 四、MySQL的索引结构是怎么样的？为什么用B+树不用B树？什么是主索引和辅助索引，聚簇索引和非聚簇索？什么是索引覆盖？非聚簇索引一定会导致回表吗？")]),v._v(" "),_("p",[v._v("1.二叉树->AVL树->红黑树->B树->B+树")]),v._v(" "),_("ul",[_("li",[v._v("二叉树")])]),v._v(" "),_("p",[v._v("二叉树的问题在于：当树结构非常不平衡(所有节点只有右孩子)时，查询效率会非常低。")]),v._v(" "),_("ul",[_("li",[v._v("AVL树")])]),v._v(" "),_("p",[v._v("树中所有节点的左孩子和右孩子深度之差小于等于1。AVL树相比于二叉树，查找效率最差也是O(logn)。")]),v._v(" "),_("ul",[_("li",[v._v("红黑树")])]),v._v(" "),_("p",[v._v("特点是树根为黑；不能有连续红节点相连接；每个节点到所有叶子节点的黑高都相等；所有叶子节点都是黑。相比于AVL树，"),_("strong",[v._v("插入删除效率红黑树更好一些")]),v._v("(因为AVL树要更多的旋转次数来保证其特性，而红黑树相当于不是那么严苛的AVL树，算是一种折中方案)而"),_("strong",[v._v("查询效率是AVL树更好一些")]),v._v("(比如对于这样一个红黑树，左子树只有五个直接相连的黑节点，而右子树我可以让五个黑节点当中每两个中间就插入一个红节点，这样树左右子树节点个数就非常不平衡，导致查询时间增加)。")]),v._v(" "),_("ul",[_("li",[v._v("n阶B树")])]),v._v(" "),_("p",[v._v("非叶子节点中的关键字个数至少要等于⌈n/2⌉-1，最多等于n-1；而每个节点的子节点数目等于该节点中关键字个数加一。"),_("strong",[v._v("所有叶子节点都是在同一层")]),v._v("。相比于红黑树，有两个优点："),_("strong",[v._v("一根据局部性原理，B树一个节点最多可以获得n-1个关键字的信息；二树高相比于红黑树更小，效率更高")]),v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("n阶B+树")])]),v._v(" "),_("p",[v._v("根节点至少有两个关键字，非叶子节点至少⌈n/2⌉，最多n个；每个关键字作为子节点中最小的值；"),_("strong",[v._v("非叶子节点只进行索引，所有数据都存在叶子节点中。每个叶子节点含有相邻叶子节点的指针，叶子节点按照关键字从小到大顺序排列")]),v._v("。B+树有两种有两种遍历方式，从树根遍历到叶子或者是数据从小到大。")]),v._v(" "),_("p",[v._v("2.MySQL选择B+树而不选择B树的原因在于，它B+树扫库只需要扫一遍叶子节点即可，并且因为它每个叶子节点都含有相邻叶子节点的指针，因此比较适合"),_("strong",[v._v("范围查询")]),v._v("和"),_("strong",[v._v("区间查询")]),v._v("。而对于B树遍历效率比较低。")]),v._v(" "),_("p",[v._v("3.主索引("),_("strong",[v._v("索引覆盖")]),v._v(")是指按照该表的主键key建立索引；而辅助索引是指按照表中非主键key进行索引。"),_("strong",[v._v("辅助索引一般要搜索两边索引，第一次查复辅助索引获得主键，然后再在主索引中查找该主键。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/ba25c74459ff449dbfd8091bc3b5ef98%5B1%5D.13q3volwf4g0.webp",alt:"d"}})]),v._v(" "),_("p",[v._v("非聚簇索引指(MyISAM)叶子节点存放的是该条记录"),_("strong",[v._v("在数据文件中的物理地址")]),v._v("；聚簇索引指(InnoDB)叶子节点存放的是"),_("strong",[v._v("整行记录")]),v._v("。InnoDB中如果表设置了主键，那么主索引就是聚簇索引，如果没有主键就选择一个非空unique作为聚簇索引。否则会创建一个隐藏的row-id作为聚簇索引。")]),v._v(" "),_("p",[v._v("4.索引覆盖是指把非主键索引改为和"),_("strong",[v._v("包含主键多字段的联合索引")]),v._v("，这样就可以在一个索引树上直接找到数据，而不需要再去主索引进行二次查找。")]),v._v(" "),_("p",[v._v("5.如果SQL语句全部命中，则当前索引已经包含所要查询信息，就不需要进行回表。比如说id是主键，对于select age from xx where age>20就不需要回表查询。")]),v._v(" "),_("h2",{attrs:{id:"五、什么是mysql主从集群-主从不一致如何解决-什么是半同步复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、什么是mysql主从集群-主从不一致如何解决-什么是半同步复制"}},[v._v("#")]),v._v(" 五、什么是MySQL主从集群？主从不一致如何解决？什么是半同步复制？")]),v._v(" "),_("p",[v._v("1.首先主节点先把MySQL更新操作写到binlog中，然后把binlog同步发送给从节点，并把内容写入到relaylog中，再创建一个线程把更新内容同步到从节点。")]),v._v(" "),_("p",[_("strong",[v._v("写操作只能在主库进行，而读操作可以在主库或者从库进行，从库可以帮主库分担读请求，进行负载均衡，提升读性能")]),v._v("。这就是MySQL的主从复制，读写分离。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/d7ffa870347a4fa9a4056a92e9927e57%5B1%5D.6jqc0hqm96k0.webp",alt:"在这里插入图片描述"}})]),v._v(" "),_("p",[v._v("2.主库把数据同步到从库中还没有完成时，这时候有一个读请求就会导致主从不一致。解决方案如下：")]),v._v(" "),_("p",[v._v("①业务强制接受，因为毕竟一般的业务都是读多写少。")]),v._v(" "),_("p",[v._v("②强制性读主库，但其实这样的话从库的利用率就大大降低，仅仅只是在主库挂时，作为一个备份。")]),v._v(" "),_("p",[v._v("③可以设置一个延时，写操作一定时间内读只能读主库，之后才可以读主或者从。")]),v._v(" "),_("p",[v._v("3.半同步复制指的是主节点"),_("strong",[v._v("等待至少一个从节点")]),v._v("接受并记录事件后，才完成本事务的提交。不需要向同步复制一样等待所有从节点的确认。可以保证如果主节点崩溃，那么至少已经发送给了一个从节点。")]),v._v(" "),_("h2",{attrs:{id:"六、什么是水平分片和垂直分片-分库分表后sql如何执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、什么是水平分片和垂直分片-分库分表后sql如何执行"}},[v._v("#")]),v._v(" 六、什么是水平分片和垂直分片？分库分表后SQL如何执行？")]),v._v(" "),_("p",[v._v("1.当表中的数据量比较大时，需要对数据进行分片。")]),v._v(" "),_("p",[v._v("垂直分片是指根据业务场景需求把"),_("strong",[v._v("一个库中的多张表")]),v._v("拆分到不同的库中，或者是根据数据相关性把"),_("strong",[v._v("一张表中的不同列")]),v._v("拆分到不同表中。")]),v._v(" "),_("p",[v._v("水平分片是指把一张表按照行拆分到不同表中，可以从"),_("strong",[v._v("根本上解决表中数据量过大的问题")]),v._v("。策略如按取模，时间，范围进行行分片。阿里建议一个表中的数据超过500w或者数据文件超过2G就需要分库分表。")]),v._v(" "),_("p",[v._v("2.SQL语句解析->SQL路由->SQL语句改写->结果归并。")]),v._v(" "),_("h2",{attrs:{id:"七、什么是mysql的左连接-右连接-内连接-外连接-交叉连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七、什么是mysql的左连接-右连接-内连接-外连接-交叉连接"}},[v._v("#")]),v._v(" 七、什么是MySQL的左连接，右连接，内连接，外连接，交叉连接？")]),v._v(" "),_("p",[v._v("左连接left join：获得左表中匹配的记录。")]),v._v(" "),_("p",[v._v("右连接right join：获得右表中的匹配记录。")]),v._v(" "),_("p",[v._v("内连接inner join：获得"),_("strong",[v._v("两张表中拼接起来的匹配的记录")]),v._v("。")]),v._v(" "),_("p",[v._v("外连接outer join：获得两张表中匹配的记录，以及"),_("strong",[v._v("某张表中不匹配的记录")]),v._v("。")]),v._v(" "),_("p",[v._v("交叉连接：两个表中记录两两进行笛卡尔积。")]),v._v(" "),_("h2",{attrs:{id:"八、什么是数据库死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#八、什么是数据库死锁"}},[v._v("#")]),v._v(" 八、什么是数据库死锁？")]),v._v(" "),_("p",[v._v("有两个事务并发执行时，事务A先锁住了行a，接下来要对行b进行修改；事务B锁住了行b，要对行a进行修改。这时候就会因为请求保持而导致死锁。")]),v._v(" "),_("p",[v._v("解决：通过设置一个"),_("strong",[v._v("定时器")]),v._v("，过一段时间发起死锁检测，如果发现有事务超时则"),_("strong",[v._v("进行事务回滚，让其他事务继续执行")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"九、最左匹配原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#九、最左匹配原则"}},[v._v("#")]),v._v(" 九、最左匹配原则？")]),v._v(" "),_("p",[v._v("最左匹配原则是针对"),_("strong",[v._v("联合索引")]),v._v("来说的。\n最左匹配原则是指按照最左边的索引key来构建B+树。比如按照(a,b)构建联合索引，它的B+树如下：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/7e51a19acc3d45eb89137cc49c428adb%5B1%5D.68ittdmuj6s0.webp",alt:"在这里插入图片描述"}})]),v._v(" "),_("p",[v._v("可以看到叶子节点数据时按照最左边索引a进行排列的，"),_("strong",[v._v("只有当a的值相等时此时的最左索引就会变成b，往后找新的索引")]),v._v("。因此a=2时，b是有序的。\n"),_("strong",[v._v("遇到最左索引的范围查询时，后面的索引就会失效，停止匹配")]),v._v("。比如我按照(a,b,c)构建联合索引，那么查询条件是a=1 and b>2 and c=8时，首先如果a=1有多个匹配数据，此时最左索引就会变成b,而此时b进行的是范围查询，因此后面c索引字段就会失效。")]),v._v(" "),_("h2",{attrs:{id:"十、范围查询如何进行的-不走索引如何进行查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十、范围查询如何进行的-不走索引如何进行查询"}},[v._v("#")]),v._v(" 十、范围查询如何进行的？不走索引如何进行查询？")]),v._v(" "),_("p",[v._v("1.假设有一个以a为字段的索引树,执行select * from t1 where a>6  会先走"),_("strong",[v._v("索引树")]),v._v("进行查询"),_("strong",[v._v("找到a=6数据节点位置")]),v._v("。然后再把a=6节点后面的结果("),_("strong",[v._v("通过相邻叶子节点指针")]),v._v(")返回即可。")]),v._v(" "),_("p",[v._v("2.若执行select * from t1 where b=5 则会进行全表查询，"),_("strong",[v._v("从数据节点(叶子节点)从小到大遍历")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"十一、范围索引失效原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十一、范围索引失效原理"}},[v._v("#")]),v._v(" 十一、范围索引失效原理？")]),v._v(" "),_("p",[v._v("建立b,c,d字段联合索引，create index idx_t1_bcd on t1(b,c,d)；然后执行select  *  from  t1 where  b>1，实际上有两种查找方式：")]),v._v(" "),_("p",[v._v("①是联合索引找到b=1d的数据节点位置，然后读出该节点后面的所有节点的主键，"),_("strong",[v._v("每个节点再去主键索引树进行一次回表查询")]),v._v("。")]),v._v(" "),_("p",[v._v("②直接对主键索引树的叶子节点进行全表扫描。")]),v._v(" "),_("p",[v._v("MySQL会根据这两种方式查询效率进行比较和优化，如果是b>1可能是②方式查找效率高一些，而如果是b>100或者是"),_("strong",[v._v("select a,b,c,d(覆盖索引")]),v._v(")可能就是①快一些。")]),v._v(" "),_("h2",{attrs:{id:"十二、order-by为什么会导致索引失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十二、order-by为什么会导致索引失效"}},[v._v("#")]),v._v(" 十二、order by为什么会导致索引失效？")]),v._v(" "),_("p",[v._v("执行select * from t1 order by b,c,d有两种方式：")]),v._v(" "),_("p",[v._v("①主键叶子节点全表扫描，"),_("strong",[v._v("读入磁盘后再排序")]),v._v("。")]),v._v(" "),_("p",[v._v("②b,c,d索引树的"),_("strong",[v._v("叶子节点顺序就是所要排序的顺序")]),v._v("，"),_("strong",[v._v("每个节点按照叶子节点顺序依次读出主键值，再回表查询")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"十三、innodb和myisam的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十三、innodb和myisam的区别是什么"}},[v._v("#")]),v._v(" 十三、InnoDB和MyISAM的区别是什么？")]),v._v(" "),_("p",[v._v("1.InnoDB支持事务，而MyISAM不支持事务。"),_("strong",[v._v("InnoDB最小锁粒度是行锁，而MyISAM最小锁粒度是表锁")]),v._v("。")]),v._v(" "),_("p",[v._v("2.InnoDB是聚簇索引，数据文件和索引文件都存储在ibd文件。而MyISAM是非聚簇索引，数据文件和索引文件分开存储。")]),v._v(" "),_("p",[v._v("3.InnoDB不保存表的具体行数，select count(*) from table是"),_("strong",[v._v("全表查询")]),v._v("。"),_("strong",[v._v("MyISAM用一个变量保存整个表的行数")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"十四、mysql索引类型-什么情况下索引失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十四、mysql索引类型-什么情况下索引失效"}},[v._v("#")]),v._v(" 十四、MySQL索引类型？什么情况下索引失效？")]),v._v(" "),_("ul",[_("li",[v._v("MySQL索引类型")])]),v._v(" "),_("p",[v._v("1.普通索引")]),v._v(" "),_("p",[v._v("2.唯一索引unique，"),_("strong",[v._v("该索引列下的值必须唯一，但允许有空值")]),v._v("，一个表可以有多个唯一索引")]),v._v(" "),_("p",[v._v("3.主键索引primary key，一个表只能有一个主键索引，索引列下值必须唯一"),_("strong",[v._v("且不允许为空")])]),v._v(" "),_("p",[v._v("4.联合索引")]),v._v(" "),_("p",[v._v("5.全文索引")]),v._v(" "),_("ul",[_("li",[v._v("索引失效")])]),v._v(" "),_("p",[v._v("1.不符合最左前缀原则")]),v._v(" "),_("p",[v._v("2.走索引没有走全库查询效率快。")]),v._v(" "),_("h2",{attrs:{id:"十五、介绍redo-log和undo-log"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十五、介绍redo-log和undo-log"}},[v._v("#")]),v._v(" 十五、介绍redo log和undo log？")]),v._v(" "),_("p",[v._v("Inno DB有这么两个日志，redo log和undo log。其中redo log是用于"),_("strong",[v._v("日志回放")]),v._v("，"),_("strong",[v._v("把已经commit的事务重新做一遍")]),v._v("。而undo log用于回滚数据，"),_("strong",[v._v("主要用于记录数据被修改前的日志")]),v._v("，当事务回滚时需要按照undo log来进行数据复原。")]),v._v(" "),_("p",[v._v("事务原子性：在进行数据修改前先把历史数据保存到undo log，当事务成功commit时，通过redo log保证修改的数据全部同步到数据库中；当需要回滚时就通过undo log。")]),v._v(" "),_("h2",{attrs:{id:"十六、inno-db如何解决判断读未提交"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十六、inno-db如何解决判断读未提交"}},[v._v("#")]),v._v(" 十六、Inno DB如何解决判断读未提交？")]),v._v(" "),_("p",[v._v("首先每行数据会有一个版本号id，"),_("strong",[v._v("Inno DB为每一个事务创造了一个动态数组")]),v._v("，用来"),_("strong",[v._v("保存当前事务启动瞬间活跃的的所有事务id")]),v._v(",然后事务每次修改完数据，就会把修改的事务id赋值给该行记录的版本号id。所以事务A读某行数据时，发现它的版本id在当前活跃事务数组中，则说明该行数据修改未提交。")]),v._v(" "),_("h2",{attrs:{id:"十七、inno-db可重复读会不会产生幻读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十七、inno-db可重复读会不会产生幻读"}},[v._v("#")]),v._v(" 十七、Inno DB可重复读会不会产生幻读？")]),v._v(" "),_("p",[v._v("RR隔离级别时普通的查询是快照读，因此"),_("strong",[v._v("快照读能解决读操作产生的幻读")]),v._v("。而因为更新操作直接使用的是"),_("strong",[v._v("当前读的最新的数据(不管事务是否提交)")]),v._v("，因此更新操作可能会产生幻读。")]),v._v(" "),_("p",[v._v("解决方案：使用for update添加间隙锁。")]),v._v(" "),_("h2",{attrs:{id:"十八、mysql如果对记录修改-是否会读到修改的值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十八、mysql如果对记录修改-是否会读到修改的值"}},[v._v("#")]),v._v(" 十八、MySQL如果对记录修改，是否会读到修改的值？")]),v._v(" "),_("p",[v._v("会。如果判断数据未改变，则不会真正执行更新操作。")]),v._v(" "),_("h2",{attrs:{id:"十九、mysql聚合函数和group-by-count-字段-和count-区别-sql语句执行顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十九、mysql聚合函数和group-by-count-字段-和count-区别-sql语句执行顺序"}},[v._v("#")]),v._v(" 十九、MySQL聚合函数和group by？count(字段)和count(*)区别？SQL语句执行顺序？")]),v._v(" "),_("p",[v._v("1.先看一个例子，找出每个部门中分数最高的同学并按照姓名升序返回表：select *,max(score) as max from student group by  depy order by name desc;")]),v._v(" "),_("p",[v._v("按照group by A根据A列key分组后，对于每个组中所有行的数据"),_("strong",[v._v("根据不同聚合函数进行处理并返回一条记录")]),v._v("。(max，min，avg，count)")]),v._v(" "),_("p",[v._v("2.count(字段)统计的是"),_("strong",[v._v("字段值不为NULL")]),v._v("的记录数。而count(*)统计行数。")]),v._v(" "),_("p",[v._v("3."),_("strong",[v._v("select 字段名(一般需要和group by字段一致) from 表名(使用join) where 条件名 group by 分组字段 having 分组条件 order by  排序字段 limit 分页")])]),v._v(" "),_("p",[v._v("①"),_("strong",[v._v("where是用来过滤行数据，在分组前过滤；而having用来过滤分组，在分组后过滤")]),v._v("。")]),v._v(" "),_("p",[v._v("②distinct对字段的value去重")]),v._v(" "),_("h2",{attrs:{id:"二十、mysql中char和varchar区别-删除语句"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二十、mysql中char和varchar区别-删除语句"}},[v._v("#")]),v._v(" 二十、MySQL中CHAR和VARCHAR区别？删除语句？")]),v._v(" "),_("p",[v._v("1.CHAR是定长字符串类型；而VARCHAR是存储"),_("strong",[v._v("可变长类型")]),v._v("。")]),v._v(" "),_("p",[v._v("2.drop用来删库删表。delete用来删除某行数据 delete from stu where id=10")]),v._v(" "),_("h2",{attrs:{id:"二十一、mysql的hash索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二十一、mysql的hash索引"}},[v._v("#")]),v._v(" 二十一、MySQL的Hash索引？")]),v._v(" "),_("p",[v._v('哈希索引优点在于索引效率高，可以一次定位。但是仅仅只能够满足"="的等值查询，不能满足范围查询。')])])}),[],!1,null,null,null);_.default=r.exports}}]);