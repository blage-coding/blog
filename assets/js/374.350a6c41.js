(window.webpackJsonp=window.webpackJsonp||[]).push([[374],{692:function(t,_,r){"use strict";r.r(_);var n=r(4),v=Object(n.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"count"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#count"}},[t._v("#")]),t._v(" count")]),t._v(" "),_("p",[t._v("MyISAM：将表的行数"),_("strong",[t._v("存储在磁盘")]),t._v("中，查询时直接取，速度快。")]),t._v(" "),_("p",[t._v("InnoDB：MVCC机制导致不同行记录对于不同事务的可见性都是不同的，因此InnoDB只能将"),_("strong",[t._v("一行一行读出来进行判断和计数")]),t._v("，效率低。")]),t._v(" "),_("p",[t._v("InnoDB扫描表时会进行相应的优化，会选择"),_("strong",[t._v("普通索引树")]),t._v("下的记录进行扫描，而不会选择"),_("strong",[t._v("主键索引树")]),t._v("，因为相较之下主键索引叶子节点的数据量要大于普通索引，"),_("font",{attrs:{color:"red"}},[_("strong",[t._v("这样可以减少扫描的数据量")])]),t._v("。")],1),t._v(" "),_("h2",{attrs:{id:"_1-count-实现方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-count-实现方式"}},[t._v("#")]),t._v(" 1.count(*)实现方式")]),t._v(" "),_("p",[_("strong",[t._v("逻辑一致")]),t._v("：插入数据后，"),_("strong",[t._v("表记录行数count")]),t._v("和"),_("strong",[t._v("select读取到的记录")]),t._v("是相互匹配的。不能出现行数增加了，但是这条数据查不到；或者是这条插入的记录可以被读取到，但是表记录数没有更新。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("Redis存放count(*)表的行数")])])]),t._v(" "),_("p",[t._v("存在问题：插入数据时，redis更新行数与数据库插入记录这两个操作不具有"),_("font",{attrs:{color:"red"}},[_("strong",[t._v("原子性")])]),t._v("，因此如果在redis更新和数据库表更新之间有并发读操作，那么得到的结果就会出现逻辑不一致。")],1),t._v(" "),_("ul",[_("li",[_("strong",[t._v("将count(*)行数存入数据库中的一张单独的表")])])]),t._v(" "),_("p",[t._v("利用MySQL事务的特性，当前事务只有"),_("strong",[t._v("同时完成insert插入记录，以及表行数加一这两个操作后才提交事务")]),t._v("，从而使插入操作和加一操作其它事务都可见。保证了两个操作的一致性。")]),t._v(" "),_("p",[t._v("💡考虑性能的话，"),_("strong",[t._v("先插入数据，再update更新计数表")]),t._v("。因为在并发场景下，"),_("strong",[t._v("更新操作冲突时会加行锁")]),t._v("，而"),_("strong",[t._v("计数表冲突的概率")]),t._v("比"),_("strong",[t._v("行记录冲突的概率")]),t._v("更高，"),_("font",{attrs:{color:"red"}},[_("strong",[t._v("因此把更新操作放在最后,可以减少更新表行记录锁的持有时间，从而最大程度减少锁等待。")])])],1),t._v(" "),_("h2",{attrs:{id:"_2-不同count的用法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-不同count的用法"}},[t._v("#")]),t._v(" 2.不同count的用法")]),t._v(" "),_("p",[t._v("InnoDB引擎返回数据给server层时，遵循以下原则："),_("font",{attrs:{color:"red"}},[_("strong",[t._v("server层要什么就给什么，并且InnoDB只会给必要的数据")])])],1),t._v(" "),_("h3",{attrs:{id:"_2-1count-主键id"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1count-主键id"}},[t._v("#")]),t._v(" 2.1count(主键id)")]),t._v(" "),_("ul",[_("li",[t._v("InnoDB引擎将每行的id都取出来，返回给server层")]),t._v(" "),_("li",[t._v("server层判断如果不为空，则按行累加")])]),t._v(" "),_("h3",{attrs:{id:"_2-2count-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2count-1"}},[t._v("#")]),t._v(" 2.2count(1)")]),t._v(" "),_("ul",[_("li",[t._v("InnoDB引擎直接放回每行记录给server层（相比于count(主键)更快，因为少了解析取出id值这个过程）")]),t._v(" "),_("li",[t._v("server层将“1”放进每一行数据，不为空则累加")])]),t._v(" "),_("h3",{attrs:{id:"_2-3count-字段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3count-字段"}},[t._v("#")]),t._v(" 2.3count(字段)")]),t._v(" "),_("ul",[_("li",[t._v("InnoDB取出每行该字段的值给server层")]),t._v(" "),_("li",[t._v("无论该字段定义为null或者时not null。计算时"),_("strong",[t._v("只有字段的值非null才会进行累加")]),t._v("。")])]),t._v(" "),_("h3",{attrs:{id:"_2-4count"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4count"}},[t._v("#")]),t._v(" 2.4count(*)")]),t._v(" "),_("p",[_("strong",[t._v("InnoDB对count(*)进行了优化，不需要把全部字段取出来一个个判断是否为空，直接记录行数")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"_2-5总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-5总结"}},[t._v("#")]),t._v(" 2.5总结")]),t._v(" "),_("p",[_("font",{attrs:{color:"red"}},[_("strong",[t._v("性能效率上，count(*)≈count(1)>count(id)>count(字段")])]),t._v(")")],1)])}),[],!1,null,null,null);_.default=v.exports}}]);