(window.webpackJsonp=window.webpackJsonp||[]).push([[373],{697:function(t,s,r){"use strict";r.r(s);var a=r(4),_=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"数据库表的空间回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库表的空间回收"}},[t._v("#")]),t._v(" 数据库表的空间回收")]),t._v(" "),s("p",[s("strong",[t._v("innodb_file_per_table")]),t._v("：控制表数据的存在形式。设置为ON表示数据存放在.ibd为后缀的文件中。"),s("strong",[t._v("设置为OFF表示数据存放在共享表空间，这种情况下即使表删除了空间不会回收")]),t._v("。因此一般情况下"),s("strong",[t._v("推荐设置为ON")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"_1-数据删除插入流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据删除插入流程"}},[t._v("#")]),t._v(" 1.数据删除插入流程")]),t._v(" "),s("p",[t._v("无论是删除还是插入，"),s("strong",[t._v("数据更新后表空间处于可复用但是还未被使用的空间")]),t._v("，都属于“空洞”。这些空洞尚未被InnoDB释放回收，从而导致数据页空间利用率比较低。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("删除")])])]),t._v(" "),s("p",[s("strong",[t._v("复用")]),t._v("：无论是删除innoDB索引树上的一条记录，还是删除一个数据页上的所有记录。"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("InnoDB并不会直接将整行记录或者整个数据页都删除，而是在这条记录的位置或者这个数据页上标记为“可复用")])]),t._v("”，这样新的数据插入后直接使用原本的空间即可。")],1),t._v(" "),s("p",[t._v("其中行复用和页复用的区别在于，"),s("strong",[t._v("新插入行复用位置的记录ID，会受到原先位置记录的约束")]),t._v("。而页复用则不受任何数据索引或者是主键的限制。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("插入")])])]),t._v(" "),s("p",[t._v("举个例子，原先数据页中"),s("strong",[t._v("某条记录")]),t._v("，由于插入新的记录导致数据页分裂，与新记录合并存放到新的数据页。此时该条数据原先所在的位置就是数据空洞。")]),t._v(" "),s("h2",{attrs:{id:"_2-重建表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-重建表"}},[t._v("#")]),t._v(" 2.重建表")]),t._v(" "),s("p",[t._v("重建表：新建一张表，将旧的存在多个空洞的表数据全部一行一行拷贝到新表当中。显然得到的新表中"),s("strong",[t._v("数据页利用率更高，并且主键索引更加紧凑")]),t._v("。下面介绍三种重建表的策略。")]),t._v(" "),s("p",[t._v("DDL：由于执行DDL语句后可能会修改表的结构，因此"),s("strong",[t._v("会触发“重建表”整个过程")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_2-1copy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1copy"}},[t._v("#")]),t._v(" 2.1COPY")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("engine")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("innodb")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ALGORITHM")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("copy\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("在"),s("strong",[t._v("service层")]),t._v("创建一个临时表来对数据进行拷贝，最后用临时表替换原表。")]),t._v(" "),s("p",[t._v("在整个过程中"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("表A仅允许读操作，阻塞所有DML更新写操作")])]),t._v("。由于需要消耗额外的数据空间，因此仅适用于数据量比较小的场景。")],1),t._v(" "),s("h3",{attrs:{id:"_2-2inplace"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2inplace"}},[t._v("#")]),t._v(" 2.2Inplace")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("engine")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("innodb")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ALGORITHM")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("inplace\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("在"),s("strong",[t._v("InnoDB内部")]),t._v("创建"),s("strong",[t._v("临时文件tmp_file")]),t._v("进行修改复制(这里可以近似看作是"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("原地修改")])]),t._v("表的字段)，"),s("strong",[t._v("整个DDL过程都是在InnoDB内部进行")]),t._v("。对于server层而言并没有将数据挪动到临时表，相当于"),s("strong",[t._v("原地操作")]),t._v("。")],1),t._v(" "),s("p",[t._v("这里要注意，说是“原地修改”，实际上临时文件也需要占用一定的磁盘空间。适用于大表修改的场景。")]),t._v(" "),s("h3",{attrs:{id:"_2-3online-ddl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3online-ddl"}},[t._v("#")]),t._v(" 2.3Online DDL")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230630/image.6c8xpd18vfw0.webp",alt:""}})]),t._v(" "),s("p",[t._v("重建表时如果有新的数据要写入，会导致数据丢失，因此引入Online DDL对操作流程进行优化，整个过程如下：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("执行DDL语句前，获取MDL写锁。")])]),t._v(" "),s("li",[s("p",[t._v("🔥"),s("strong",[t._v("拷贝数据之前，MDL写锁退化为MDL读锁，从而保证在执行DDL和拷贝时，不会阻塞其它线程的DML增删改操作")]),t._v("。这就是Online名称的由来。")])]),t._v(" "),s("li",[s("p",[t._v("创建一个临时文件，"),s("strong",[t._v("根据A表中主键数据页的有效记录生成B+树，记录到临时文件中")]),t._v("。此时表是最紧凑的。")])]),t._v(" "),s("li",[s("p",[t._v("此时如果要写入数据，写入到旧的A表后，"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("统一将所有操作记录在一个row log文件当中")])]),t._v("。")],1)]),t._v(" "),s("li",[s("p",[t._v("临时文件生成完后，按顺序进行以下两个步骤：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("①"),s("strong",[t._v("将MDL读锁升级到MDL写锁")]),t._v("，为接下来重放更新操作做准备，此时一定要控制多并发DML。")])]),t._v(" "),s("li",[s("p",[t._v("②"),s("strong",[t._v("将row log所有写操作应用到临时文件中")]),t._v("。此时临时文件表数据时最新的，但是"),s("strong",[t._v("并不一定是最紧凑的，因为往表中插入新的数据后可能产生新的空洞")]),t._v("。")])])])]),t._v(" "),s("li",[s("p",[t._v("将临时文件代替表A的数据文件。")])])]),t._v(" "),s("p",[t._v("区别与联系：显然online DDL用到了临时文件，"),s("strong",[t._v("因此online一定是inplace的")]),t._v("。"),s("strong",[t._v("反之inplace不一定是online可多并发DML的，比如全文索引")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"_3-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结"}},[t._v("#")]),t._v(" 3.总结")]),t._v(" "),s("p",[t._v("要想达到真正的删除表并且释放空间，需要delete+alter，或者truncate(drop+create)")])])}),[],!1,null,null,null);s.default=_.exports}}]);