(window.webpackJsonp=window.webpackJsonp||[]).push([[370],{690:function(s,t,r){"use strict";r.r(t);var a=r(4),e=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[s._v("#")]),s._v(" 索引")]),s._v(" "),t("h2",{attrs:{id:"_1-索引模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-索引模型"}},[s._v("#")]),s._v(" 1.索引模型")]),s._v(" "),t("ul",[t("li",[s._v("哈希表")])]),s._v(" "),t("p",[s._v("使用哈希函数将key换算成一个确定的位置，对于出现碰撞的key，则在每一个索引上接一个链表。")]),s._v(" "),t("p",[s._v("缺点：因为key不是递增的，因此"),t("strong",[s._v("做范围查询需要全表扫描")]),s._v("。仅适用于"),t("strong",[s._v("等值查询")]),s._v("。")]),s._v(" "),t("ul",[t("li",[s._v("有序数组")])]),s._v(" "),t("p",[s._v("在等值查询和范围查询场景中性能比较好。所有key按序保存在数组中。")]),s._v(" "),t("p",[s._v("缺点：插入新数据需要挪动整个数组，成本高。因此有序数组只适用于静态存储引擎，比如2017年人口信息。")]),s._v(" "),t("ul",[t("li",[s._v("二叉搜索树")])]),s._v(" "),t("p",[s._v("查询效率快。")]),s._v(" "),t("p",[s._v("缺点：为了保证log(N)的查询复杂度，需要保证这棵搜索树是一棵平衡二叉树。但是二叉搜索树的问题在于维护起来比较麻烦。")]),s._v(" "),t("ul",[t("li",[s._v("N叉树")])]),s._v(" "),t("p",[s._v("因为二叉树保存的数据量比较大时，"),t("strong",[s._v("树的层数比较高，导致需要频繁访问磁盘(一层树高对应一个索引块")]),s._v(")。因此"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("使用N叉树可以让查询流程尽量少走磁盘，减少树高，读更少的数据块")])]),s._v("。读写性能好。")],1),s._v(" "),t("p",[t("strong",[s._v("注意N叉树的N实际上等于一个页的大小除以一个索引字段的大小，因此可以通过设置数据页的大小来改变N的值")]),s._v("。")]),s._v(" "),t("h2",{attrs:{id:"_2-innodb索引模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-innodb索引模型"}},[s._v("#")]),s._v(" 2.InnoDB索引模型")]),s._v(" "),t("p",[s._v("InnoDB采用B+树存储索引节点，"),t("strong",[s._v("每一个索引字段对应一棵B+树")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230601/image.280dtt4o3pj4.webp",alt:""}})]),s._v(" "),t("p",[s._v("索引分为"),t("strong",[s._v("主键索引")]),s._v("和"),t("strong",[s._v("非主键索引")]),s._v("。查询语句根据使用的索引不同，索引树搜索树次数也不同：")]),s._v(" "),t("ul",[t("li",[s._v("如果用到主键索引，那么直接根据主键索引值搜索主键B+树，在叶子节点拿到对应的行记录")]),s._v(" "),t("li",[s._v("如果使用非主键索引，那么会"),t("strong",[s._v("先查找该字段的B+树")]),s._v("，在叶子节点获取到对应主键索引值之后，"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("再根据主键索引值去主键B+树搜索行记录")])]),s._v("。【🔑"),t("strong",[s._v("回表")]),s._v("】")],1)]),s._v(" "),t("h2",{attrs:{id:"_3-索引维护"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-索引维护"}},[s._v("#")]),s._v(" 3.索引维护")]),s._v(" "),t("p",[s._v("B+树在维护过程中，会涉及到"),t("strong",[s._v("页分裂")]),s._v("与"),t("strong",[s._v("合并")]),s._v("的情况。根据添加记录的主键值包含两种情况：")]),s._v(" "),t("ul",[t("li",[s._v("添加的主键值递增插入  (  "),t("strong",[s._v("自增主键AUTO_INCREMENT")]),s._v("  )  ，那么只需要进行追加操作，不涉及挪动其他的记录，也不会触发叶子节点的分裂。")]),s._v(" "),t("li",[s._v("当添加的主键值是乱序的（ 业务逻辑字段作为主键 ），往B+树插入新的记录时，可能会导致叶子节点的分裂，从而需要申请新的数据页，并将数据挪动过去。")])]),s._v(" "),t("p",[t("strong",[s._v("自增字段作为主键的性能分析")]),s._v("：从"),t("strong",[s._v("性能")]),s._v("上分析，使用自增主键在维护时开销比较小；从"),t("strong",[s._v("存储空间")]),s._v("考虑，如果选择的主键的字段比较长，那么对于所有二级索引B+树的叶子节点来说，就需要开辟更大空间保存每一个主键索引值。")]),s._v(" "),t("p",[t("strong",[s._v("业务字段直接作为索引")]),s._v("：①"),t("strong",[s._v("只存在一个索引字段")]),s._v("(不需要考虑其它索引叶子节点大小的问题)②该索引必须是唯一索引——kv场景。直接将该索引设置为主键。")]),s._v(" "),t("h2",{attrs:{id:"_4-删除索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-删除索引"}},[s._v("#")]),s._v(" 4.删除索引")]),s._v(" "),t("ul",[t("li",[s._v("为什么要删除索引")])]),s._v(" "),t("p",[s._v("在不断的往数据库插入新的数据过程中，一旦出现页分裂情况，就会导致数据页空间存在空洞。因此重新创建索引会将所有数据重新按照索引插入，"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("从而节省空间，使索引更加紧凑")])]),s._v("。")],1),s._v(" "),t("ul",[t("li",[s._v("重建主键索引")])]),s._v(" "),t("p",[s._v("一张表重建主键索引时，"),t("strong",[s._v("不仅需要重建主键的B+树")]),s._v("，"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("同时对于所有其它的二级索引的B+树也会重新构建")])]),s._v("，从而导致较大的开销。")],1),s._v(" "),t("h2",{attrs:{id:"_5-覆盖索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-覆盖索引"}},[s._v("#")]),s._v(" 5.覆盖索引")]),s._v(" "),t("p",[s._v("数据表中ID是主键，k是非主键索引。有两条查询语句如下：")]),s._v(" "),t("div",{staticClass:"language-sql line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" T "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" k "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("between")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" ID "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" T "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" k "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("between")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("如果查找的是整个行记录，那么每次查询完k的B+树之后，还会查询ID的主键B+树，因此每条记录会搜索两次树。P.S最后还会查找一次K的索引树，判断k超出范围搜索结束。")]),s._v(" "),t("p",[t("strong",[s._v("覆盖索引优化")]),s._v("：如果直接查主键ID，因为在k的索引树的叶子节点中，已经包含ID主键字段的值，所以就不需要进行回表，大大减少B+树的查询次数。")]),s._v(" "),t("p",[t("font",{attrs:{color:"red"}},[t("strong",[s._v("覆盖索引可以减少树的搜索次数，显著提升查询性能。覆盖索引是一种特殊的联合索引。")])]),s._v("。")],1),s._v(" "),t("p",[s._v("💡"),t("strong",[s._v("建立联合索引使用覆盖索引")]),s._v("：如果有一个索引字段k1，还有一个数据库字段k2，有一个高频请求需要根据k1字段查找k2字段的值。如果是普通的做法先查k1然后进行回表，总共需要查询两次；而如果是建立(k1,k2)两个字段的联合索引，那么只需要查一次二级索引的B+树就可以得到k2字段的值。")]),s._v(" "),t("p",[s._v("💡"),t("strong",[s._v("二级索引比主键索引更快")]),s._v("：仅限于使用覆盖索引的情况。")]),s._v(" "),t("h2",{attrs:{id:"_6-最左前缀原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-最左前缀原则"}},[s._v("#")]),s._v(" 6.最左前缀原则")]),s._v(" "),t("p",[s._v("最左前缀原则：不仅包括联"),t("strong",[s._v("合索引中最左N个索引字段")]),s._v("；同时还包括"),t("strong",[s._v("模糊查询字符串索引最左n个字符")]),s._v("。细节如下：")]),s._v(" "),t("ul",[t("li",[s._v("如果已经建立了联合索引(a,b)，那么就没有必要单独在a字段上建立索引。它们两个都可以走同一个联合索引。")]),s._v(" "),t("li",[s._v("联合索引多个字段顺序的安排：①第一原则是调整顺序后，根据上述规则可以少维护一个索引字段②根据具体业务和热点字段③字段存储空间大小。")])]),s._v(" "),t("h2",{attrs:{id:"_7-索引下推"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-索引下推"}},[s._v("#")]),s._v(" 7.索引下推")]),s._v(" "),t("p",[s._v("假设存在联合索引(name,age)，如果有以下SQL查询语句：")]),s._v(" "),t("div",{staticClass:"language-sql line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" tuser "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" name "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("like")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'张%'")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" age"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" ismale"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("根据使不使用索引下推可能会存在两种情况：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("不使用索引下推：首先会在联合索引树搜索匹配到所有姓张的叶子节点("),t("font",{attrs:{color:"red"}},[t("strong",[s._v("age因为遇到范围查询不会匹配")])]),s._v("),然后对于剩余没有匹配的字段，则会根据叶子节点匹配的主键索引去主键索引树拿到每个数据行，然后"),t("strong",[s._v("再对比非索引字段是否符合条件")]),s._v("。"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("因此每个非索引字段的条件判断都需要进行一次回表，并交给server层进行判断")])]),s._v("。")],1)]),s._v(" "),t("li",[t("p",[s._v("索引下推：联合索引树中已经存在age字段的值，因此对age的WHERE条件判断直接交给"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("InnoDB存储引擎")])]),s._v("进行，不需要回表。对于索引B+树不存在的字段，才会通过回表拿到行数据再进行条件判断。")],1),s._v(" "),t("p",[t("strong",[s._v("对于所有索引字段的条件判断，无论是否命中都会使用索引下推在存储引擎完成。")])])])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230601/image.1nffxgdfwqqo.webp",alt:""}})]),s._v(" "),t("h2",{attrs:{id:"_8-联合主键"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-联合主键"}},[s._v("#")]),s._v(" 8.联合主键")]),s._v(" "),t("p",[s._v("联合字段(a,b)作为主键，同时在c字段上建立索引，则在c的索引B+树木中，"),t("strong",[s._v("叶子节点需要同时保存联合主键字段a和b的值")]),s._v("。如果此时又建立了联合索引(c,b)，那么"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("索引树叶子节点只需要保存a的值(b已经在索引字段存在")])]),s._v(")。无论是联合索引还是联合主键本质上都是"),t("strong",[s._v("按照最左原则对字段进行排序")]),s._v("。")],1),s._v(" "),t("p",[t("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230601/image.4iud6ygpggs0.webp",alt:""}})]),s._v(" "),t("p",[s._v("那么考虑如下SQL语句，"),t("font",{attrs:{color:"red"}},[t("strong",[s._v("c索引叶子节点会根据最左前缀原则保存联合主键的值")])]),s._v("，因此下列语句的c,a索引不需要另外添加创建，直接走c索引。")],1),s._v(" "),t("div",{staticClass:"language-sql line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" geek "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" c"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("N "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("order")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("by")]),s._v(" a "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("limit")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("而对于如下语句，在c字段没有重复的情况下，不需要建立(c,b)索引，直接走c索引得到的最终结果准确。如果重复值比较多则需要建立联合索引。")]),s._v(" "),t("div",{staticClass:"language-sql line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" geek "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" c"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("N "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("order")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("by")]),s._v(" a "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("limit")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])])])}),[],!1,null,null,null);t.default=e.exports}}]);