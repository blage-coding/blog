(window.webpackJsonp=window.webpackJsonp||[]).push([[367],{687:function(t,_,s){"use strict";s.r(_);var r=s(4),v=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"事务隔离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离"}},[t._v("#")]),t._v(" 事务隔离")]),t._v(" "),_("h2",{attrs:{id:"_1-隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-隔离级别"}},[t._v("#")]),t._v(" 1.隔离级别")]),t._v(" "),_("p",[t._v("读未提交：当前事务能够读取到其它事务"),_("strong",[t._v("提交之前")]),t._v("的所有变更。没有视图的概念。")]),t._v(" "),_("p",[t._v("读已提交：当前事务能够读取到其它事务提交之后的所有变更。"),_("font",{attrs:{color:"red"}},[_("strong",[t._v("每次执行sql语句都会重新创建一次视图，刷新快照")])]),t._v("。")],1),t._v(" "),_("p",[t._v("可重复读：一个事务执行过程中，能够看到的数据和"),_("font",{attrs:{color:"red"}},[_("strong",[t._v("该事务启动时的数据状态保持一致")])]),t._v("。当前这份数据不受其它事务的影响。"),_("font",{attrs:{color:"red"}},[_("strong",[t._v("视图会在启动时就创建好了，启动时会创建一个全局快照")])]),t._v("。")],1),t._v(" "),_("p",[t._v("串行化：对于数据库表中同一行记录，“写”之前会加上“写锁”，“读”之前会加上“读锁”，"),_("strong",[t._v("读写锁冲突时，必须等待前一个事务执行完毕释放锁之后才能进行")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"_2-事务隔离实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务隔离实现"}},[t._v("#")]),t._v(" 2.事务隔离实现")]),t._v(" "),_("p",[t._v("长事务：运行时间比较长，长时间未提交(执行了很多语句忘记commit)的事务称为长事务。不使用长事务的原因①只要当前长事务未提交，那么与它相关的所有回滚记录都会保留，占据大量存储空间。②长期占用锁资源。")]),t._v(" "),_("p",[_("font",{attrs:{color:"red"}},[_("strong",[t._v("数据库多版本并发控制MVCC")])]),t._v("：查询一条记录时，同一条记录会存在多个不同的版本，"),_("strong",[t._v("每个版本数据对应一个事务id")]),t._v("。")],1),t._v(" "),_("p",[t._v("回滚日志：记录每个值被修改过的所有状态值。当系统判定没有事务(视图)用到这些回滚日志时，就会删除对应的回滚日志。就会如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230531/image.5pnfcvtxrpk0.webp",alt:""}})]),t._v(" "),_("h2",{attrs:{id:"_3-事务启动方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-事务启动方式"}},[t._v("#")]),t._v(" 3.事务启动方式")]),t._v(" "),_("p",[t._v("启动事务一般有两种方式：")]),t._v(" "),_("ul",[_("li",[t._v("显示开启事务：begin transaction")]),t._v(" "),_("li",[t._v("设置"),_("strong",[t._v("set autocommit")]),t._v("=0，"),_("strong",[t._v("每次自动事务，将线程的自动提交关闭")]),t._v("。这个事务启动后会一直存在，"),_("strong",[t._v("持续到你显式调用commit才会断开事务连接")]),t._v("。")])]),t._v(" "),_("p",[t._v("建议使用commit work and chain语法，提交事务后自动启动下一个事务。")]),t._v(" "),_("h2",{attrs:{id:"_4-如何避免长事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何避免长事务"}},[t._v("#")]),t._v(" 4.如何避免长事务")]),t._v(" "),_("ul",[_("li",[t._v("检查set autocommit是否被设置为0，如果设置为0那么所有SQL语句执行完毕之后，不会自动提交事务。因此需要把它改成1。")]),t._v(" "),_("li",[_("font",{attrs:{color:"red"}},[_("strong",[t._v("只读事务select不需要放到事务中执行")])]),t._v("。")],1),t._v(" "),_("li",[t._v("根据业务本身估计，通过set max_execution 设置每个SQL语句执行的最长时间，避免单个语句执行过长时间。")]),t._v(" "),_("li",[t._v("从数据库端来看：①监控innoDB数据表，设置长事务阈值，超过报警。②设置回滚日志的表空间个数innodb_undo_tablespaces。")])])])}),[],!1,null,null,null);_.default=v.exports}}]);