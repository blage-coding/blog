(window.webpackJsonp=window.webpackJsonp||[]).push([[341],{661:function(t,v,_){"use strict";_.r(v);var a=_(4),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"并发机制初识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发机制初识"}},[t._v("#")]),t._v(" 并发机制初识")]),t._v(" "),v("p",[t._v("java代码编译成java字节码后，会被加载到JVM中执行，并转换成汇编指令在CPU上执行。因此java所有并发机制依赖于JVM的实现和CPU指令。")]),t._v(" "),v("p",[t._v("本章节主要介绍：")]),t._v(" "),v("ul",[v("li",[t._v("volatile底层处理器实现原理")]),t._v(" "),v("li",[t._v("synchronized的几种锁")])]),t._v(" "),v("h2",{attrs:{id:"_1-volatile"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-volatile"}},[t._v("#")]),t._v(" 1.volatile")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("可见性")]),t._v(" "),v("p",[t._v("共享变量的可见性指的是，当一个线程修改一个共享变量后，其它的线程能够读取到这个修改的值。")])]),t._v(" "),v("h3",{attrs:{id:"volatile修饰的变量如何保证可见性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#volatile修饰的变量如何保证可见性"}},[t._v("#")]),t._v(" volatile修饰的变量如何保证可见性？")]),t._v(" "),v("p",[t._v("为了提高处理效率，CPU不会直接和内存进行通信，而是通过CPU—缓存—内存的方式进行。对于多核处理器而言，每个处理器都有自己专门的缓存区，所有缓存区共享一个系统内存。")]),t._v(" "),v("p",[t._v("在对volatile修饰的变量执行写操作时，生成的汇编代码会多一个"),v("strong",[t._v("Lock指令")]),t._v("，这个Lock指令只要做了两件事：")]),t._v(" "),v("ol",[v("li",[v("font",{staticStyle:{background:"rgb(255, 240, 102)"}},[v("strong",[t._v("当前处理器缓存行的数据会写回到系统内存中")])])],1),t._v(" "),v("li",[v("font",{staticStyle:{background:"rgb(255, 240, 102)"}},[v("strong",[t._v("其它CPU缓存的该地址的数据失效")])])],1)]),t._v(" "),v("p",[t._v("其它CPU会使用嗅探技术，保证"),v("strong",[t._v("CPU内部缓存、其它CPU内部缓存、系统内存")]),t._v("的数据在总线上保持一致。")]),t._v(" "),v("h3",{attrs:{id:"volatile使用优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#volatile使用优化"}},[t._v("#")]),t._v(" volatile使用优化")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("缓存行填充")]),t._v(" "),v("p",[t._v("多个变量占据的字节小于缓冲行的大小，那么CPU会将多个变量读到同一个高速缓存行。")]),t._v(" "),v("p",[t._v("而如果个别处理器支持“缓存行填充”，那么不满足缓存行大小的变量会自动扩充，单独填满占据一个缓存行。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230929/image.1hhz0imgwgm8.webp",alt:""}})]),t._v(" "),v("p",[t._v("不支持“缓存行填充”的CPU，在读写某个变量时，"),v("strong",[t._v("可能会导致同一个缓存行内的其它变量同时被锁住")]),t._v("，如上图CPU1在对head节点操作时，会导致其它多处理器都不能访问缓存行1其它变量。")]),t._v(" "),v("p",[v("strong",[t._v("字节追加")]),t._v("：通过扩充volatile变量的字节大小，保证每个节点变量只占据一个缓存行存储。解决了"),v("strong",[t._v("多个共享变量在频繁写的过程中产生的锁定问题")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"_2-synchronized"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-synchronized"}},[t._v("#")]),t._v(" 2.synchronized")]),t._v(" "),v("p",[t._v("synchronized用于实现代码同步：每个线程在访问同步代码块时，首先需要获取锁，执行完退出或者抛出异常时需要释放锁。")]),t._v(" "),v("p",[t._v("synchronized用的锁保存在"),v("strong",[t._v("java对象头")]),t._v("中，java对象头包括以下几个部分：")]),t._v(" "),v("ul",[v("li",[t._v("Mark Word：存储对象的锁信息、hashcode。具体会根据"),v("strong",[t._v("锁标志位")]),t._v("进行变化，不同的锁对应不同的Mark Word信息。")]),t._v(" "),v("li",[t._v("Class Metadata：存储对象元信息、数据、地址")]),t._v(" "),v("li",[t._v("(数组对象)")])]),t._v(" "),v("p",[t._v("Java SE 1.6中，锁等级从低到高一共可以分为4种状态：无锁状态、偏向锁状态、轻量级锁、重量级锁。"),v("strong",[t._v("锁可以升级，但不能降级")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"_2-1偏向锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1偏向锁"}},[t._v("#")]),t._v(" 2.1偏向锁")]),t._v(" "),v("p",[t._v("为了使"),v("strong",[t._v("同一个线程多次访问同步块获取锁")]),t._v("时，获取锁的代价更小，引入了偏向锁。")]),t._v(" "),v("p",[t._v("线程第一次获取锁时，"),v("strong",[t._v("在对象头中存储偏向锁的线程ID")]),t._v("，以后该线程再次访问时，无需进行CAS操作加锁解锁(修改Mark Word)。")]),t._v(" "),v("p",[v("strong",[t._v("偏向锁撤销")]),t._v("：当其它线程想要访问同步块，尝试通过CAS竞争获取偏向锁时，当前持有偏向锁的线程才会释放锁，将偏向锁偏向于其它线程，或是变为无锁状态。")]),t._v(" "),v("h3",{attrs:{id:"_2-2轻量级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2轻量级锁"}},[t._v("#")]),t._v(" 2.2轻量级锁")]),t._v(" "),v("p",[t._v("轻量级加锁：线程首先将对象头的Mark Word复制到"),v("strong",[t._v("自己的栈帧")]),t._v("中，"),v("font",{staticStyle:{background:"rgb(255, 240, 102)"}},[v("strong",[t._v("然后通过CAS操作尝试将对象头的Mark Word修改为指向该锁记录栈帧的指针")])]),t._v("。如果成功，则当前线程获得轻量级锁，否则会不断"),v("strong",[t._v("自旋")]),t._v("尝试竞争获取锁。")],1),t._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20231009/image.37u2d7ltowo0.webp",alt:""}})]),t._v(" "),v("p",[t._v("轻量级解锁：通过CAS操作将栈帧的锁记录 Displaced Mark Word替换为对象头。如果失败则表示当前存在多个线程同时竞争获取锁和释放锁，膨胀为重量级锁。")]),t._v(" "),v("p",[v("strong",[t._v("自旋操作会消耗CPU")]),t._v("，如果当前锁处于重量级锁，那么试图获取锁的所有线程都会被阻塞住。直到获取锁的线程释放锁后，才会唤醒所有被阻塞的线程，进行新一轮的竞争。")]),t._v(" "),v("h3",{attrs:{id:"_2-3对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3对比"}},[t._v("#")]),t._v(" 2.3对比")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("偏向锁：适用于只有"),v("strong",[t._v("单个线程访问")]),t._v("同步块的情况。")])]),t._v(" "),v("li",[v("p",[t._v("轻量级锁：用于不同线程访问同步块的情况。每个线程都会"),v("strong",[t._v("自旋获取锁，性能高")]),t._v("，响应时间短。")])]),t._v(" "),v("li",[v("p",[t._v("重量级锁：用于解决锁竞争消耗CPU的情况。锁竞争不"),v("strong",[t._v("消耗CPU")]),t._v("，吞吐量高。但涉及线程阻塞和唤醒，进行上下文切换，响应时间长。")])])]),t._v(" "),v("h2",{attrs:{id:"_3-cas原子操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-cas原子操作"}},[t._v("#")]),t._v(" 3.CAS原子操作")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("CAS无锁算法")]),t._v(" "),v("p",[t._v("如果“当前地址的值”与“先前读到的该地址的值”是一致，那么可以判定人为该变量没有被修改过，可以赋予新的值。否则不做任何修改。")])]),t._v(" "),v("p",[t._v("循环CAS用于保证"),v("strong",[t._v("对共享变量操作时，是原子操作")]),t._v("。")]),t._v(" "),v("p",[t._v("ABA问题：解决方式通过加版本号，判断当前第二个变量A是否已经被修改过。")])])}),[],!1,null,null,null);v.default=s.exports}}]);