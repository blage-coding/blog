(window.webpackJsonp=window.webpackJsonp||[]).push([[358],{677:function(t,s,a){"use strict";a.r(s);var i=a(4),_=Object(i.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"redis网络模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis网络模型"}},[t._v("#")]),t._v(" Redis网络模型")]),t._v(" "),s("h2",{attrs:{id:"阻塞io-bio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阻塞io-bio"}},[t._v("#")]),t._v(" 阻塞IO(BIO)")]),t._v(" "),s("ul",[s("li",[t._v("用户进程向内核空间发起系统调用，等待网卡数据")]),t._v(" "),s("li",[t._v("内核空间等待数据，数据到来后写到内核缓冲区，然后再将数据拷贝到用户缓冲区，然后用户处理数据")]),t._v(" "),s("li",[t._v("整个过程用户进程一直在阻塞地等待数据。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/image-20230315141539103.635xqntwpww0.webp",alt:"image-20230315141539103"}})]),t._v(" "),s("h2",{attrs:{id:"非阻塞io-nio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞io-nio"}},[t._v("#")]),t._v(" 非阻塞IO(NIO)")]),t._v(" "),s("ul",[s("li",[t._v("用户进程发起系统调用等待数据时，"),s("strong",[t._v("内核态直接向用户进程返回调用失败")]),t._v("。然后用户进程反复调用询问数据好了没有，因此"),s("strong",[t._v("等待数据阶段用户进程是非阻塞")]),t._v("的。但忙等会导致CPU空转。")]),t._v(" "),s("li",[t._v("内核态中，一旦数据准备好之后会将数据从内核缓冲区拷贝到用户缓冲区中，才会给用户进程返回OK。"),s("strong",[t._v("数据拷贝阶段进程依旧是阻塞")]),t._v("的。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/image-20230315142339070.2ss4b6u85lc0.webp",alt:"image-20230315142339070"}})]),t._v(" "),s("h2",{attrs:{id:"io多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[t._v("#")]),t._v(" IO多路复用")]),t._v(" "),s("ul",[s("li",[t._v("select")])]),t._v(" "),s("p",[t._v("①首先创建一个fd集合，以bitmap的形式标记要监听的fd，然后"),s("strong",[t._v("将fd集合从用户态拷贝到内核态")]),t._v("。")]),t._v(" "),s("p",[t._v("②内核监听每个fd对应的设备状态，如果有就绪的保留1，未就绪则变成0。然后会把"),s("strong",[t._v("fd集合从内核空间拷贝到用户空间")]),t._v("中。")]),t._v(" "),s("p",[t._v("③用户空间需要遍历fd集合，找到对应就绪的fd。")]),t._v(" "),s("ul",[s("li",[t._v("poll")])]),t._v(" "),s("p",[t._v("fd数组监听的数量没有上限。整个数组拷贝到内核空间后转链表存储。")]),t._v(" "),s("ul",[s("li",[t._v("epoll")])]),t._v(" "),s("p",[t._v("epoll_ctl：将FD从用户空间拷贝到"),s("strong",[t._v("内核空间的红黑树")]),t._v("中，并关联callback，当fd就绪触发callback就会把就绪的fd加入到一个专门的"),s("strong",[t._v("链表集合")]),t._v("中。(相比于select每次都要拷贝到内核空间，epoll每个fd只需要执行一次epoll_ctl添加到红黑树中)")]),t._v(" "),s("p",[t._v("epoll_wait：返回就绪链表集合fd数量，并拷贝就绪的fd到用户空间。")]),t._v(" "),s("p",[t._v("ET模式：当FD有数据可读时，进程只会被通知一次。可以避免LT的惊群现象")]),t._v(" "),s("p",[t._v("LT模式：当FD有数据可读时，会重复通知多次，直至数据被处理完成。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/image-20230315193330626.4l2wrdwc8hi0.webp",alt:"image-20230315193330626"}})]),t._v(" "),s("h2",{attrs:{id:"信号驱动io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#信号驱动io"}},[t._v("#")]),t._v(" 信号驱动IO")]),t._v(" "),s("p",[t._v("用户进程和内核建立信号关联，用户进程在等待数据期间可以执行其它业务，无需阻塞等待，当数据就绪后内核会通过信号通知用户。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/image-20230315160427231.cizcb7oom5s.webp",alt:"image-20230315160427231"}})]),t._v(" "),s("h2",{attrs:{id:"异步io-aio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步io-aio"}},[t._v("#")]),t._v(" 异步IO(AIO)")]),t._v(" "),s("p",[t._v("用户只需要发送系统调用后，进程不阻塞，等待内核等待数据、拷贝数据后发给用户处理数据信号。")]),t._v(" "),s("h2",{attrs:{id:"redis网络模型-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis网络模型-2"}},[t._v("#")]),t._v(" Redis网络模型")]),t._v(" "),s("p",[t._v("Redis核心业务部分是"),s("strong",[t._v("单线程")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("Redis是纯内存操作，执行速度非常快")]),t._v("，性能瓶颈是网络延迟而不是执行速度。多线程会导致上下文切换，带来不必要的开销；并且多线程会面临线程安全问题。")]),t._v(" "),s("h3",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);s.default=_.exports}}]);