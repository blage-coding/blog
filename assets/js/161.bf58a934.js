(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{481:function(t,_,s){"use strict";s.r(_);var v=s(4),o=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_5-最长回文子串"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-最长回文子串"}},[t._v("#")]),t._v(" 5.最长回文子串")]),t._v(" "),_("p",[t._v("给你一个字符串 "),_("code",[t._v("s")]),t._v("，找到 "),_("code",[t._v("s")]),t._v(" 中最长的回文子串。")]),t._v(" "),_("blockquote",[_("p",[t._v('输入：s = "babad"\n输出："bab"\n解释："aba" 同样是符合题意的答案。')])]),t._v(" "),_("ol",[_("li",[t._v("双for循环，外层for循环"),_("strong",[t._v("固定回文子串的中心")]),t._v("，内层for循环"),_("strong",[t._v("从中心向左右两侧扩展直")]),t._v("。需要注意的是要分两种情况，第一种中心只有一个字符(回文子串长度为奇数)，第二种情况中心有两个字符(回文子串长度为偶数)。")]),t._v(" "),_("li",[t._v("动规。"),_("strong",[t._v("dp[i][j]表示下标i到j是否是回文子串")]),t._v("，状态转移方程是:"),_("strong",[t._v("if(s[i]=s[j]&&dp[i+1][j-1]==1)    dp[i][j]=1")]),t._v(";需要注意的一个地方是要求出dp[i][j]需要提前求出dp[i+1][j-1]的值，而"),_("strong",[t._v("后者在前者的左下方")]),t._v("，因此"),_("strong",[t._v("遍历顺序是从下到上，从左到右")]),t._v("。而且只需要求出dp的上三角矩阵。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);