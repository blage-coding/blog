(window.webpackJsonp=window.webpackJsonp||[]).push([[425],{743:function(_,v,t){"use strict";t.r(v);var r=t(4),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"网关系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网关系统"}},[_._v("#")]),_._v(" 网关系统")]),_._v(" "),v("p",[_._v("项目核心模块分为三块内容：")]),_._v(" "),v("ul",[v("li",[_._v("Center注册中心")]),_._v(" "),v("li",[_._v("Assist-Engine-Core网关算力")]),_._v(" "),v("li",[_._v("Provider-SDK服务提供方")])]),_._v(" "),v("h1",{attrs:{id:"网关算力core"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网关算力core"}},[_._v("#")]),_._v(" 网关算力Core")]),_._v(" "),v("p",[_._v("整个网关流程（启动服务器、监听连接、请求处理）如下：")]),_._v(" "),v("ol",[v("li",[_._v("创建线程任务：在调用的线程任务当中，启动Netty服务器")]),_._v(" "),v("li",[_._v("服务器请求Handler：根据 uri 从 map 获取对应 httpstatement 映射规则，并存入通道会话")]),_._v(" "),v("li",[_._v("鉴权Handler：请求头拿到 uid 和 token 进行鉴权")]),_._v(" "),v("li",[_._v("方法调用Handler：解析请求参数，根据 uri 拿到泛化调用，执行、封装、返回调用结果\n"),v("ul",[v("li",[_._v("①获取数据源，建立连接。默认实现以下两种数据源：\n"),v("ul",[v("li",[_._v("HTTP：由网关向另一个url发送HTTP请求，调用接口")]),_._v(" "),v("li",[_._v("Dubbo：根据方法名获取对应的泛化调用实例，执行RPC方法")])])]),_._v(" "),v("li",[_._v("②连接对象根据配置信息，包括"),v("strong",[_._v("应用配置+配置中心配置+服务引用配置")]),_._v("，获取泛化调用实例")]),_._v(" "),v("li",[_._v("③执行器根据映射规则，封装被调用"),v("strong",[_._v("方法名+参数类型+参数")]),_._v("，并通过泛化实例执行。")])])])]),_._v(" "),v("p",[_._v("关键配置对象：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Configuration")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Netty服务端参数，包括IP端口、boss线程、worker线程。")])]),_._v(" "),v("li",[v("p",[_._v("三个Dubbo重实例对象，并配置有缓存Map，"),v("strong",[_._v("key为对应应用ID和接口ID")]),_._v("。")])]),_._v(" "),v("li",[v("p",[_._v("网关映射HttpStatement缓存集合，"),v("strong",[_._v("key设置为uri")]),_._v("。")])]),_._v(" "),v("li",[v("p",[_._v("泛化调用IGenericReference实例对象缓存，"),v("strong",[_._v("key设置为uri")]),_._v("。")])])])]),_._v(" "),v("li",[v("p",[_._v("HttpStatement")]),_._v(" "),v("ul",[v("li",[_._v("应用ID和接口ID")]),_._v(" "),v("li",[_._v("方法名、入参类型、鉴权、uri")])])])]),_._v(" "),v("h1",{attrs:{id:"center注册中心"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#center注册中心"}},[_._v("#")]),_._v(" Center注册中心")]),_._v(" "),v("p",[_._v("数据库表设计：")]),_._v(" "),v("ul",[v("li",[_._v("方法信息表；"),v("strong",[_._v("应用ID+接口ID+方法信息")]),_._v("（uri，请求方式，参数类型）")]),_._v(" "),v("li",[_._v("接口信息表：应用ID+接口名称+接口版本")]),_._v(" "),v("li",[_._v("应用信息表：应用ID+注册中心")]),_._v(" "),v("li",[_._v("网关服务组表：网关服务ID+地址，对应一个Core实例")]),_._v(" "),v("li",[_._v("网关分配表："),v("strong",[_._v("网关服务ID <= 绑定 = > 应用ID")]),_._v("，一个applicationID下所有接口和方法都交给一个Core核心进行处理")])]),_._v(" "),v("p",[_._v("docker挂载和刷新Nginx服务：")]),_._v(" "),v("ol",[v("li",[_._v("在Center程序运行的容器内部，重写一个conf配置文件，该文件地址挂载在容器外部（阿里云服务器）Nginx配置文件的地址。"),v("strong",[_._v("因此只要容器内部的文件发生变动，那么外部Nginx配置文件也会同步更新")]),_._v("。")]),_._v(" "),v("li",[_._v("Nginx刷新reload使配置生效。通过docker-java包，可以在当前容器调用其它容器的服务。具体来说，可以通过容器名拿到该容器的ID，从而exec进入容器内部，执行reload -s指令。")])]),_._v(" "),v("p",[_._v("注册节点流程：")]),_._v(" "),v("ol",[v("li",[_._v("插表：向网关算力表插入记录")]),_._v(" "),v("li",[_._v("查表：查出所有运行的算力节点，组成代理上游服务器")]),_._v(" "),v("li",[_._v("更新刷新Nginx配置")])]),_._v(" "),v("p",[_._v("Redis事件通知机制：")]),_._v(" "),v("ul",[v("li",[_._v("通道名称为"),v("font",{attrs:{color:"red"}},[v("strong",[_._v("网关地址ID")])]),_._v("，发送的消息内容为"),v("strong",[_._v("应用名称ID")]),_._v("。")],1),_._v(" "),v("li",[_._v("每次应用-接口-方法注册成功后，通过redis向通道发送事件。")])]),_._v(" "),v("h1",{attrs:{id:"assist"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#assist"}},[_._v("#")]),_._v(" Assist")]),_._v(" "),v("p",[_._v("ContextClosedEvent上下文关闭扩展点：")]),_._v(" "),v("ol",[v("li",[_._v("容器关闭时，需要将core的Netty服务也一并关闭")])]),_._v(" "),v("p",[_._v("ApplicationContextAware上下文扩展点：")]),_._v(" "),v("ol",[v("li",[_._v("首先根据yml配置的网关信息，向“注册中心”注册网关节点。")]),_._v(" "),v("li",[v("strong",[_._v("查出该网关ID下的所有的接口和方法")]),_._v("，加入configuration中的缓存：\n"),v("ul",[v("li",[_._v("Dubbo三大变量：applicaiton+registry+reference")]),_._v(" "),v("li",[_._v("方法映射HttpStatement，key为对应请求的uri")])])])]),_._v(" "),v("p",[_._v("通过spring.factories文件，指定GatewayAutoConfig作为外部Bean导入容器管理，通过注解@Configuration与@Bean创建更多Bean对象，其中对于方法@Bean：")]),_._v(" "),v("ul",[v("li",[_._v("方法形参会从Bean容器中找")]),_._v(" "),v("li",[_._v("Bean注解的方法返回的对象会作为Bean纳入容器管理")])]),_._v(" "),v("p",[v("strong",[_._v("通过Bean方法自动创建的Bean对象")]),_._v("如下：")]),_._v(" "),v("ul",[v("li",[_._v("Configuration：全局配置信息对象")]),_._v(" "),v("li",[_._v("Channel：初始化Netty服务器通道，监听网络请求")]),_._v(" "),v("li",[_._v("GatewayApplication：spring拓展点的对象，用于初始化configuration对象")])]),_._v(" "),v("h1",{attrs:{id:"sdk"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sdk"}},[_._v("#")]),_._v(" SDK")]),_._v(" "),v("p",[_._v("核心流程如下：")]),_._v(" "),v("ol",[v("li",[_._v("通过BeanPost增强方法，获取每个带有自定义注解的接口和方法，并插入数据库。")]),_._v(" "),v("li",[_._v("向Center发送Redis事件")])]),_._v(" "),v("h1",{attrs:{id:"q-a"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[_._v("#")]),_._v(" Q&A")]),_._v(" "),v("h2",{attrs:{id:"问题一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题一"}},[_._v("#")]),_._v(" 问题一")]),_._v(" "),v("p",[_._v("Netty启动服务端绑定监听的IP地址时，试了两个IP地址都启动失败：")]),_._v(" "),v("ul",[v("li",[_._v("服务器公网IP：直接在服务器上运行正常，但是通过docker运行失败")]),_._v(" "),v("li",[_._v("127.0.0.1：可以正常启动，但是外部无法通过公网IP进行网关通信")])]),_._v(" "),v("p",[_._v("经排查了解到，Netty的bind只能绑定本机能感知到的网卡IP。通过docker exec进入容器内部进行ifconfig，发现确实无法感知到外部的公网IP，只能查到"),v("strong",[_._v("虚拟网卡")]),_._v("以及"),v("strong",[_._v("127.0.0.1")]),_._v("这两个地址。")]),_._v(" "),v("p",[_._v("而对于127.0.0.1外网不能访问，是因为本地环回地址只能在本地访问，只能在容器内通过127.0.0.1进行访问，而在外部其它机器上通过该地址请求不能打到该机器上。")]),_._v(" "),v("p",[_._v("最终解决方案是绑定地址是"),v("strong",[_._v("0.0.0.0")]),_._v("，相当于监听该机器上的所有网卡，无论是docker的虚拟网卡还是机器上的网卡，外部发送的数据包都可以监听到。")]),_._v(" "),v("h2",{attrs:{id:"问题二"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题二"}},[_._v("#")]),_._v(" 问题二")]),_._v(" "),v("p",[_._v("如何解决网关启动后，后启动的RPC服务加入到Assist网关的缓存？Redis的事件发布通知机制如何进行设计？")]),_._v(" "),v("ol",[v("li",[_._v("Assist首先向center注册中心拉取Redis配置，创建Jedis客户端监听通道消息；创建监听器适配器，指定消息处理函数；将Topic通道与消息处理函数进行绑定。")]),_._v(" "),v("li",[_._v("Center中心提供发送消息的接口")])]),_._v(" "),v("p",[_._v("整体流程如下：")]),_._v(" "),v("ol",[v("li",[_._v("Provider：启动时，通过spring拓展点BeanPostProcessor，获取每个注解的Bean对象方法名，将当前服务的“应用、接口、方法”向注册中心注册，最后"),v("font",{attrs:{color:"red"}},[v("strong",[_._v("调用注册中心的Redis事件发送")])]),_._v("。")],1),_._v(" "),v("li",[_._v("Assist：Jedis客户端接收到事件后，获取"),v("font",{attrs:{color:"red"}},[v("strong",[_._v("应用ID")])]),_._v("，重新拉取该应用ID的所有接口和方法"),v("strong",[_._v("加入缓存")]),_._v("。")],1)]),_._v(" "),v("p",[_._v("所有向Center注册中心发送的接口请求，都是通过"),v("strong",[_._v("Hutool的HttpUtil工具")]),_._v("发送请求。")]),_._v(" "),v("h1",{attrs:{id:"面试问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面试问题"}},[_._v("#")]),_._v(" 面试问题")]),_._v(" "),v("h3",{attrs:{id:"_1、网关数据库表的qps问题-性能瓶颈在哪儿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、网关数据库表的qps问题-性能瓶颈在哪儿"}},[_._v("#")]),_._v(" 1、网关数据库表的QPS问题？性能瓶颈在哪儿？")]),_._v(" "),v("p",[_._v("网关的数据库表主要功能是进行服务注册，以及接口分配，因此一般来说并发量并不会很大，除非真的同时有很多个接口进行注册，那么可以采用分库分表，或者进行分布式部署。")]),_._v(" "),v("p",[_._v("性能瓶颈：网关包含多条链路，比如服务拉取，服务注册，用户请求。其中性能瓶颈主要在这一条链路：用户请求->协议转换->接口获取->泛化调用。包括几个方面：")]),_._v(" "),v("ul",[v("li",[_._v("网络IO：大量请求堆积，超时会导致对应的网络性能问题。可以通过修改Netty网络模型，零拷贝技术提高"),v("strong",[_._v("系统IO性能")]),_._v("。")]),_._v(" "),v("li",[_._v("Dubbo服务性能：Dubbo服务性能也会影响到API网关整体的性能。提高每个RPC接口的服务性能方法，比如Dubbo的异步调用、负载均衡等")]),_._v(" "),v("li",[_._v("线程池：网关需要处理大量的请求，因此如何设置好线程池参数是关键。也就是Netty的EventLoop线程对象，主要分为两大类，分别是boss和worker线程，"),v("font",{attrs:{color:"red"}},[v("strong",[_._v("每个线程都会维护多个任务队列")])]),_._v("。\n"),v("ul",[v("li",[_._v("boss线程主要处理连接accept事件，一般bind几个IP端口则设置几个boss线程。boss线程会将连接的客户端注册到worker的注册队列中。")]),_._v(" "),v("li",[_._v("worker线程主要负责处理用户请求。"),v("strong",[_._v("每个worker线程会不断select查看是否有客户端读写事件，如果没有则不会运行")]),_._v("。因此worker线程并不是一直工作的，为了提高CPU的使用效率，一般设置为CPU核心数*2")]),_._v(" "),v("li",[v("strong",[_._v("每个客户端的所有事件都会交由同一个worker进行处理")]),_._v("，worker会串行执行所有handler，从而避免线程上下文切换。")])])],1),_._v(" "),v("li",[_._v("内存使用：Netty线程池需要维护多个客户端的队列，因此使用不当可能出现内存溢出、内存泄漏等问题。可以采用减少对象创建等方法进行优化，同时对于网关而言，朝生夕灭的对象比较多，"),v("font",{attrs:{color:"red"}},[v("strong",[_._v("因此JVM的初始新生代需要设置大一些")])]),_._v("，让大部分对象都直接在新生代存储和消亡，不需要进入老年代。")],1),_._v(" "),v("li",[_._v("Handler线程池分离：线程池默认使用NIO的线程池。如果自定义的Handler业务处理开销过大，那么可以自定义一个线程池，"),v("font",{attrs:{color:"red"}},[v("strong",[_._v("为Handler指定特定的线程池进行处理，防止业务任务与IO任务同时抢占资源")])]),_._v("。")],1)]),_._v(" "),v("h3",{attrs:{id:"_2、netty如何实现断线重连"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、netty如何实现断线重连"}},[_._v("#")]),_._v(" 2、Netty如何实现断线重连?")]),_._v(" "),v("p",[_._v("一般是在worker添加一个定时任务，重新执行客户端连接的逻辑即可。")]),_._v(" "),v("p",[_._v("该网关中，客户端并不需要处理数据，因此无需编写客户端代码，客户端仅通过网络连接与服务端进行通信。")]),_._v(" "),v("h3",{attrs:{id:"_3、网关的高可用可以做哪些处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、网关的高可用可以做哪些处理"}},[_._v("#")]),_._v(" 3、网关的高可用可以做哪些处理？")]),_._v(" "),v("p",[_._v("方案如下：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("异地多机房")]),_._v("拓展部署多个"),v("strong",[_._v("网关算力")]),_._v("实例，本质上只是负责协议转发，失败了需要配置超时重试。")]),_._v(" "),v("li",[_._v("负载均衡：LVS配置前端负载均衡+ F5硬件负载均衡+ Nginx")])]),_._v(" "),v("h3",{attrs:{id:"_4、注册中心负责什么部分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、注册中心负责什么部分"}},[_._v("#")]),_._v(" 4、注册中心负责什么部分？")]),_._v(" "),v("p",[_._v("注册中心主要负责服务注册、服务拉取、算力分配等功能，提供给网关操作数据库的功能。而其它网关指的是用于RPC服务的注册中心。")]),_._v(" "),v("h3",{attrs:{id:"_5、该网关与springcloud网关有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、该网关与springcloud网关有什么区别"}},[_._v("#")]),_._v(" 5、该网关与SpringCloud网关有什么区别？")]),_._v(" "),v("p",[_._v("网关这个名词实际上叫的比较大。个人理解的话，SpringCloud主要是侧重于不同微服务之间的HTTP通信问题，包括超时、限流、负载。")]),_._v(" "),v("p",[_._v("而API网关主要是侧重于不同RPC的调用管理，以及协议转换。")]),_._v(" "),v("h3",{attrs:{id:"_6、系统想要使用该网关-需要做哪些步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6、系统想要使用该网关-需要做哪些步骤"}},[_._v("#")]),_._v(" 6、系统想要使用该网关，需要做哪些步骤？")]),_._v(" "),v("p",[_._v("如果需要对RPC接口到HTTP协议进行转换，统一管理，可以使用这套网关。"),v("font",{attrs:{color:"red"}},[v("strong",[_._v("本质上是通过编程式控制，向不同RPC接口以及HTTP接口发送请求")])]),_._v("。看是哪套RPC接口，如果是Dubbo正好本系统进行了开发，将外部的HTTP请求通过网关，打到Dubbo接口，将调用结果通过HTTP协议返回。")],1),_._v(" "),v("ul",[v("li",[_._v("Dubbo协议：将RPC接口导入SDK，使用相应的注解对接口和方法进行标注，然后启动程序暴露接口，并进行服务注册。另外需要统一外部的HTTP请求路径与对应的RPC接口。")]),_._v(" "),v("li",[_._v("HTTP协议：实现一个http到http的协议转换，Spring服务端接口不需要修改。只需注意对应的映射规则。")])]),_._v(" "),v("h3",{attrs:{id:"_7、网关为什么需要自研-和市面上的区别在哪儿"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7、网关为什么需要自研-和市面上的区别在哪儿"}},[_._v("#")]),_._v(" 7、网关为什么需要自研？和市面上的区别在哪儿？")]),_._v(" "),v("p",[_._v("市面上有一些网关，个别大厂也有在自研，经过调研主要是一下几个核心问题：")]),_._v(" "),v("ul",[v("li",[_._v("兼容性：市面上开源的网关，系统升级时比较麻烦，可能会出现网关服务依赖包的版本不兼容问题，使用自研的可以减少维护成本。此外，使用的依赖包全程可控，可以减少安全问题。")]),_._v(" "),v("li",[_._v("拓展性：自研最大的好处，在于可以自定义扩展功能，"),v("strong",[_._v("接入处理")]),_._v("不同内部自研的协议，同时在调用过程拓展对应的功能。")])]),_._v(" "),v("h2",{attrs:{id:"_8、同一套网关系统怎么映射到不同的后端dubbo服务上面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8、同一套网关系统怎么映射到不同的后端dubbo服务上面"}},[_._v("#")]),_._v(" 8、同一套网关系统怎么映射到不同的后端Dubbo服务上面？")]),_._v(" "),v("p",[_._v("每个HTTP请求路径，都映射一个Dubbo服务接口方法。")]),_._v(" "),v("p",[_._v("每个网关实例启动时，会向数据库拉取对应的映射关系，并加入缓存。")]),_._v(" "),v("h2",{attrs:{id:"_9、部署多套网关-如何进行区分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9、部署多套网关-如何进行区分"}},[_._v("#")]),_._v(" 9、部署多套网关，如何进行区分？")]),_._v(" "),v("p",[_._v("网关系统配置了网关<==>Dubbo服务的映射，每个网关ID与服务的映射关系会存入数据库。一个服务下的所有接口对应由同一个网关进行协议转换和转发。")]),_._v(" "),v("p",[_._v("网关启动时，会拉取网关与接口的映射关系，存入"),v("strong",[_._v("映射表缓存")]),_._v("当中。")]),_._v(" "),v("h2",{attrs:{id:"_10、rpc服务上报过后-协议变了-网关应该如何处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10、rpc服务上报过后-协议变了-网关应该如何处理"}},[_._v("#")]),_._v(" 10、RPC服务上报过后，协议变了，网关应该如何处理？")]),_._v(" "),v("p",[_._v("协议改变后，需要改动如下：")]),_._v(" "),v("ul",[v("li",[_._v("修改注册中心上报信息，包括RPC服务协议类型")]),_._v(" "),v("li",[_._v("网关需要拓展从HTTP协议到该协议的转换方法，保证该RPC服务能够正确被网关转发和调用")])]),_._v(" "),v("h2",{attrs:{id:"_11、服务降级方案怎么设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11、服务降级方案怎么设计"}},[_._v("#")]),_._v(" 11、服务降级方案怎么设计")]),_._v(" "),v("p",[_._v("服务降级主要包括：限流、熔断、降级，可以通过插件实现。在RPC服务启动注册的时候，同时启动"),v("strong",[_._v("服务治理配置")]),_._v("，配置相应的操作，比如降级之后直接返回错误码。")])])}),[],!1,null,null,null);v.default=s.exports}}]);