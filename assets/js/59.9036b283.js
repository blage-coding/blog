(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{379:function(t,r,s){"use strict";s.r(r);var a=s(4),n=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_498-对角线遍历"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_498-对角线遍历"}},[t._v("#")]),t._v(" 498.对角线遍历")]),t._v(" "),r("p",[t._v("给你一个大小为 "),r("code",[t._v("m x n")]),t._v(" 的矩阵 "),r("code",[t._v("mat")]),t._v(" ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。")]),t._v(" "),r("blockquote",[r("p",[t._v("输入：mat = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,4,7,5,3,6,8,9]")])]),t._v(" "),r("ol",[r("li",[t._v("遍历方向分为两种，右上方遍历和左下方遍历。向上遍历时，碰到上边界时横坐标加一，碰到右边界时纵坐标加一；向下遍历碰到左边界纵坐标加一，碰到下边界横坐标加一。")])]),t._v(" "),r("ul",[r("li",[t._v("保存结果时如果先用容器保存，则"),r("strong",[t._v("ArrayList.toArray()会直接返回Object[],强转类型会报异常")]),t._v("，如果采用带形参方法，ArrayList.toArray(new E[])形参数组只能是"),r("strong",[t._v("对象数组")]),t._v("，而不能是基本类型数组，因此要从ArrayList转换成int[]只能通过get方法一个个取出来。")])])])}),[],!1,null,null,null);r.default=n.exports}}]);