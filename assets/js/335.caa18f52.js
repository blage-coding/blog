(window.webpackJsonp=window.webpackJsonp||[]).push([[335],{654:function(t,s,a){"use strict";a.r(s);var _=a(4),v=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"hashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[t._v("#")]),t._v(" HashMap")]),t._v(" "),s("h2",{attrs:{id:"_1-简述hashmap扩容原理和多线程不安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-简述hashmap扩容原理和多线程不安全"}},[t._v("#")]),t._v(" 1.简述HashMap扩容原理和多线程不安全")]),t._v(" "),s("p",[t._v("JDK1.7：开辟一个更大的数组，并通过一个双层循环(有链表节点需要第二层循环，"),s("strong",[t._v("链表插入是头插法")]),t._v("，因此拷贝过去后"),s("strong",[t._v("整个新链表会翻转")]),t._v(")把原数组的节点完整拷贝过去。")]),t._v(" "),s("p",[t._v("多线程下可能会导致"),s("strong",[t._v("链表成环")]),t._v("，出现while死循环。"),s("strong",[t._v("根本原因在于使用头插法")]),t._v("。")]),t._v(" "),s("p",[t._v("JDK1.8：同1.7,区别在于链表插入使用了尾插法，且要拷贝的节点正好是一棵红黑树的根，那么要重新计算红黑树下每个节点对应在新数组下的"),s("strong",[t._v("索引下标位置")]),t._v("(数组容量不同，下标不一定相同)。")]),t._v(" "),s("p",[t._v("并发执行put操作时，如果线程A"),s("strong",[t._v("未插入时就挂起")]),t._v("，则当A重新获得时间片后直接插入，会出现"),s("strong",[t._v("数据覆盖")]),t._v("情况。")])])}),[],!1,null,null,null);s.default=v.exports}}]);