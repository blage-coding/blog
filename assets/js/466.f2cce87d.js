(window.webpackJsonp=window.webpackJsonp||[]).push([[466],{785:function(t,r,a){"use strict";a.r(r);var s=a(4),n=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"api-gateway-sdk"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#api-gateway-sdk"}},[t._v("#")]),t._v(" Api-gateway-sdk")]),t._v(" "),r("h2",{attrs:{id:"_1-rpc应用接口自动注册sdk"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-rpc应用接口自动注册sdk"}},[t._v("#")]),t._v(" 1.RPC应用接口自动注册SDK")]),t._v(" "),r("p",[t._v("功能：实现RPC服务接口Spring启动后自动注册功能。")]),t._v(" "),r("p",[t._v("可以预见到后续也需要有一个SDK注册引擎(Dubbo服务Provider)，启动后拿到所有RPC接口的信息，并向注册中心的RPC服务注册接口发送请求。")]),t._v(" "),r("h4",{attrs:{id:"springboot-starter最佳实践-启动前"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#springboot-starter最佳实践-启动前"}},[t._v("#")]),t._v(" SpringBoot-starter最佳实践：启动前")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("参数读取并加载")])])]),t._v(" "),r("p",[t._v("①application.yml参数："),r("strong",[t._v("通过@ConfigurationProperties注解的属性配置类获取")]),t._v("，并在配置类中@Enable加入Spring容器管理。")]),t._v(" "),r("p",[t._v("②@Annotation注解型参数：在"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("实现BeanPostProcessor的初始化服务类中解析获取")])]),t._v("。在"),r("strong",[t._v("每个Bean的初始化后置增强方法postProcessAfterInitialization中，拦截每一个Bean(包含service,component..注解并交给spring管理的类)，进行类注解和方法注解的判断，最后取出注解中的参数")]),t._v("。")],1),t._v(" "),r("ul",[r("li",[r("strong",[t._v("执行初始化方法与处理逻辑")])])]),t._v(" "),r("p",[t._v("最关键的一点，"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("执行初始化方法处理的对象一定只能是@Bean注解的交给Spring容器管理的对象。")])])],1),t._v(" "),r("p",[t._v("①BeanPostProcessor：在初始化前置后置方法实现初始化。")]),t._v(" "),r("p",[t._v("②ApplicationListener：通过Bean生命周期事件的发布触发监听器处理方法。")]),t._v(" "),r("p",[t._v("③ApplicationContextAware：容器感知扩展点，本质是执行初始化前置增强beanPostProcessorsBeforeInitialization。")]),t._v(" "),r("p",[t._v("④@Bean："),r("strong",[t._v("以Bean方法的形式执行处理方法")]),t._v("，最终返回值作为Bean交给容器管理。")]),t._v(" "),r("h4",{attrs:{id:"springboot-starter最佳实践-启动后"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#springboot-starter最佳实践-启动后"}},[t._v("#")]),t._v(" SpringBoot-starter最佳实践：启动后")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("AOP切面")])])]),t._v(" "),r("p",[t._v("对切面类添加增强方法，用户"),r("strong",[t._v("调用切面AOP代理对象的方法")]),t._v("时，触发切面处理逻辑。")]),t._v(" "),r("h2",{attrs:{id:"_2-enableconfigurationproperties加载时机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-enableconfigurationproperties加载时机"}},[t._v("#")]),t._v(" 2.EnableConfigurationProperties加载时机")]),t._v(" "),r("p",[r("strong",[t._v("ConfigurationPropertiesBeanRegistrar")]),t._v("：找到@ConfigurationProperties注解的类，并创建对应的BeanDefinition，注册bean定义。")]),t._v(" "),r("p",[r("strong",[t._v("ConfigurationPropertiesBindingPostProcessor")]),t._v("：首先在成员属性复制后afterPropertiesSet获取bingder。"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("在postProcessBeforeInitialization初始化前增强方法中")])]),t._v("，通过bind方法将@ConfigurationProperties注解bean和配置文件属性绑定。")],1),t._v(" "),r("h2",{attrs:{id:"_3-httputil-post"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-httputil-post"}},[t._v("#")]),t._v(" 3.HttpUtil#post")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("HttpUtil#post")])])]),t._v(" "),r("p",[t._v("Hutool工具包发送Post请求，其中入参接收一个封装了所有请求参数的"),r("strong",[t._v("Map对象")]),t._v("。这种方式的Content-Type为"),r("strong",[t._v("application/x-www-form-urlencoded")]),t._v("，controller可以直接"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("使用自定义对象接收")])]),t._v("(不能用@RequestBody接收)。")],1),t._v(" "),r("ul",[r("li",[r("strong",[t._v('@RequestMapping(consumes="application/json",produces="")')])])]),t._v(" "),r("p",[r("strong",[t._v("produces")]),t._v("用来指明controller方法"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("返回响应")])]),t._v("的编码类型是json格式。")],1),t._v(" "),r("p",[r("strong",[t._v("consumes")]),t._v("指定处理"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("请求")])]),t._v("的提交内容类型（Content-Type）")],1),t._v(" "),r("h2",{attrs:{id:"_4-算力关联、接口上报、调用反馈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-算力关联、接口上报、调用反馈"}},[t._v("#")]),t._v(" 4.算力关联、接口上报、调用反馈")]),t._v(" "),r("ul",[r("li",[t._v("算力关联")])]),t._v(" "),r("p",[t._v("功能："),r("strong",[t._v("注册中心gateway-center")]),t._v("给"),r("strong",[t._v("后台管理系统gateway-admin")]),t._v("提供算力分配表的数据插入方法，手动将"),r("strong",[t._v("网关算力节点")]),t._v("与"),r("strong",[t._v("RPC服务接口")]),t._v("关联起来。")]),t._v(" "),r("ul",[r("li",[t._v("接口上报")])]),t._v(" "),r("p",[t._v("功能："),r("strong",[t._v("RPC服务gateway-sdk")]),t._v("如果重复启动多次扫描注册接口，会因为插入重复索引键的行记录报错。此处提供一个按钮配置，当"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("sdk启动后不会扫描所有接口方法")])]),t._v("。")],1),t._v(" "),r("p",[t._v("@ConditionalOnproperty："),r("strong",[t._v("类注解，用于设置是否加载当前Bean")]),t._v("。")]),t._v(" "),r("p",[t._v("从application.yml文件中，读取配置文件的prefix+name值，"),r("strong",[t._v("并和havingValue的值进行比较，如果一样则Spring容器加载Bean")]),t._v("，否则不加载当前Bean。matchIdMissing字段为true表示如果配置文件"),r("strong",[t._v("找不到该prefix+name字段")]),t._v("(无法进行比对)，那么加载当前Bean，否则不加载，相当于"),r("strong",[t._v("默认")]),t._v("配置。")]),t._v(" "),r("div",{staticClass:"language-java line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[r("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@ConditionalOnProperty")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prefix "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"api-gateway-sdk"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("name "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"enabled"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("havingValue "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"true"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("matchIfMissing "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")])]),r("p",[t._v("在"),r("strong",[t._v("api-gateway-sdk")]),t._v("的配置文件中，设置enabled为false，RPC服务启动后就不会自动装配配置类(不会扫描所有服务接口)，服务接口就不会被重复注册进数据库当中。")]),t._v(" "),r("ul",[r("li",[t._v("调用反馈")])]),t._v(" "),r("p",[r("strong",[t._v("网关算力gateway-core在Netty")]),t._v("服务端进行handler处理逻辑时，无论泛化调用成功与否，都"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("需要在封装的HTTP响应对象的结果中，加入当前通信的算力节点IP节点信息，便于排查bug。")])])],1),t._v(" "),r("p",[t._v("core-ProtocolDataHandler#node：从配置对象中，取出当前Netty通信的服务端算力节点IP与端口。")]),t._v(" "),r("p",[t._v("core-GatewayResultMessage：添加node字符串作为成员属性，保存算力节点的IP信息。")])])}),[],!1,null,null,null);r.default=n.exports}}]);