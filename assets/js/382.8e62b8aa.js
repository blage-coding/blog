(window.webpackJsonp=window.webpackJsonp||[]).push([[382],{700:function(t,r,o){"use strict";o.r(r);var _=o(4),s=Object(_.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"全表扫描与内存占用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#全表扫描与内存占用"}},[t._v("#")]),t._v(" 全表扫描与内存占用")]),t._v(" "),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),r("p",[t._v("内存只有100G，要对磁盘里一张200G的表进行全表扫描，内存会不会爆？")])]),t._v(" "),r("p",[t._v("结论：MySQL的策略是“"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("边读边发")])]),t._v("”。表数据会分段发给客户端，服务端buffer被阻塞就暂停发送。")],1),t._v(" "),r("ol",[r("li",[t._v("首先InnoDB会搜集数据并将数据页分段加入buffer pool中。")]),t._v(" "),r("li",[t._v("server层每次读取一行记录，并放到MySQL内存"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("net_buffer")])]),t._v("中，"),r("strong",[t._v("当"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[t._v("net_buffer")]),t._v("写满后再调用网络接口将部分结果集发送出去")],1),t._v("。")],1),t._v(" "),r("li",[t._v("发送函数会将"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("net_buffer")])]),t._v("的内容写到"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("socket send buffer")])]),t._v("本地网络栈，然后发送到客户端。如果发送函数返回"),r("strong",[t._v("EAGAIN")]),t._v("或"),r("strong",[t._v("WASEWOULDBLOCK")]),t._v("，则说明"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("socket send buffer")])]),t._v("写满了，进入等待，然后重新发送。")],1)]),t._v(" "),r("p",[r("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230709/image.3jt52ub8ske0.webp",alt:""}})]),t._v(" "),r("h2",{attrs:{id:"_1-server层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-server层"}},[t._v("#")]),t._v(" 1.server层")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230709/image.2a2x64m8j42s.webp",alt:""}})]),t._v(" "),r("p",[t._v("客户端请求数据时，在服务端查看执行查询线程id可能存在两种状态：")]),t._v(" "),r("h3",{attrs:{id:"_1-1sending-to-client"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1sending-to-client"}},[t._v("#")]),t._v(" 1.1sending to client")]),t._v(" "),r("p",[t._v("表示"),r("strong",[t._v("本地网络栈当前已经写满了")]),t._v("，线程处于"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("等待客户端接收结果")])]),t._v("的状态。比如客户端使用"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("-quick")])]),t._v("参数就会出现这种情况，此时会调用"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("mysql_use_result")])]),t._v("方法请求数据。客户端取出一条数据后可能会进行较长时间的处理步骤，从而导致server端的buffer被“阻塞”不能立刻将所有数据发送出去。")],1),t._v(" "),r("p",[t._v("✨因此一般情况下，如果返回的整个结果集并不是很大，不会占用太多内存，那么可以使用"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("mysql_store_result")])]),t._v("接口，"),r("strong",[t._v("直接将查询结果保存在本地内存再处理")]),t._v("。")],1),t._v(" "),r("p",[t._v("如果依旧发现多个线程处于"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("sending to client")])]),t._v("状态，那么优化方法如下：")],1),t._v(" "),r("ul",[r("li",[t._v("评估是否可以减小返回的结果集。")]),t._v(" "),r("li",[t._v("将"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("net_buffer")])]),t._v("设置的更大一些。一般来说"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("net_buffer")])]),t._v("会比"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("socket send buffer")])]),t._v("大很多。而对于执行器来说，只要当前结果都读到"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("net_buffer")])]),t._v("则相当于”已经写出去“了，所以"),r("strong",[t._v("优先确保server层尽快把数据从InnoDB读出来")]),t._v("，再利用网络栈慢慢发送。")],1)]),t._v(" "),r("h3",{attrs:{id:"_1-2sending-data"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2sending-data"}},[t._v("#")]),t._v(" 1.2sending data")]),t._v(" "),r("p",[t._v("表示当前查询线程处于“"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("收集+发送数据")])]),t._v("”的状态，具体来说当前线程可能处在以下任意一个状态：")],1),t._v(" "),r("ul",[r("li",[t._v("当前SQL语句在InnoDB层需要进行锁等待。")]),t._v(" "),r("li",[t._v("InnoDB层需要收集数据，包括查找索引，回表。")]),t._v(" "),r("li",[t._v("server层将数据发送给客户端。")])]),t._v(" "),r("p",[t._v("因此如果服务端的线程出现大量的"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("sending data")])]),t._v("状态，那么需要进一步仔细排查索引、回表等问题。")],1),t._v(" "),r("h2",{attrs:{id:"_2-innodb层与buffer-pool"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-innodb层与buffer-pool"}},[t._v("#")]),t._v(" 2.InnoDB层与buffer pool")]),t._v(" "),r("p",[t._v("InnoDB"),r("strong",[t._v("内存数据页")]),t._v("是在"),r("strong",[t._v("buffer pool")]),t._v("进行管理，因此要理解全表查询时的执行步骤和优化，关键就看在buffer pool里发生了什么。")]),t._v(" "),r("p",[t._v("buffer pool作为InnoDB的"),r("strong",[t._v("缓冲池")]),t._v("，它的核心机制如下：")]),t._v(" "),r("h3",{attrs:{id:"_2-1加速更新"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1加速更新"}},[t._v("#")]),t._v(" 2.1加速更新")]),t._v(" "),r("p",[t._v("执行更新语句时，如果数据页在buffer pool(不在就从磁盘读出来)，那么"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("只需要在buffer pool的数据页上进行更新，不需要将脏页刷到磁盘")])]),t._v("。如果遇到崩溃丢失内存更新数据，"),r("strong",[t._v("直接配合redo log进行恢复")]),t._v("即可。")],1),t._v(" "),r("p",[t._v("因此buffer pool+redo log共同保证了加速更新。(反过来说如果没有redolog，那么每次更新就要刷盘，否则崩溃内存就会丢失更新数据)")]),t._v(" "),r("h3",{attrs:{id:"_2-2加速查询"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2加速查询"}},[t._v("#")]),t._v(" 2.2加速查询")]),t._v(" "),r("p",[t._v("buffer pool中的数据页肯定保证是最新的，查询请求到来时，"),r("strong",[t._v("如果buffer pool有那就直接读，不需要读磁盘")]),t._v("。但如果buffer pool没有命中，就还是需要读磁盘。因此加速查询的效果取决于buffer pool的命中率。InnoDB通过采用不同的淘汰页算法，从而提高buffer pool的"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("内存页命中率")])]),t._v("。")],1),t._v(" "),r("h4",{attrs:{id:"lru"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lru"}},[t._v("#")]),t._v(" LRU")]),t._v(" "),r("p",[t._v("InnoDB管理的LRU算法基于链表实现。越靠近头结点位置的节点越新，靠近尾节点的节点越旧。")]),t._v(" "),r("ul",[r("li",[t._v("访问某个节点时如果命中，则将该节点取出来放到"),r("strong",[t._v("头结点")]),t._v("位置。")]),t._v(" "),r("li",[t._v("如果内存不命中，则从磁盘将数据页读到buffer pool，作为新的头结点，同时"),r("strong",[t._v("将尾节点删除")]),t._v("。")])]),t._v(" "),r("p",[t._v("💣存在的问题：如果当前业务1正在利用buffer pool的内存命中给用户快速返回数据，这时候有另外一个事务需要进行全表扫描"),r("strong",[t._v("访问历史数据")]),t._v("，并且表数据很大200G，那么就会依次从磁盘将新的数据页读到内存，并淘汰掉当前业务1的数据页。")]),t._v(" "),r("p",[t._v("这么一来①业务1的本来可以命中的数据页都需要重新读磁盘，增加了磁盘压力")]),t._v(" "),r("p",[t._v("②历史数据一般来说读了一次后，就不会再读了，因此会霸占整个buffer pool的资源，直到新的数据页把它们刷掉。")]),t._v(" "),r("h4",{attrs:{id:"优化版本lru"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优化版本lru"}},[t._v("#")]),t._v(" 优化版本LRU")]),t._v(" "),r("p",[t._v("InnoDB将"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("整个LRU链表按照5：3分成了young区域和old区域")])]),t._v("。添加了一个LRU_old指针，其中head到pre_LRU_old之间为young区域，而LRU_old到tail之间为old区域。")],1),t._v(" "),r("p",[r("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230709/image.30qcrmnmhks0.webp",alt:""}})]),t._v(" "),r("ul",[r("li",[t._v("如果内存命中，分为以下两种情况：\n"),r("ul",[r("li",[t._v("命中young区域，则将数据页提出来作为新的head节点")]),t._v(" "),r("li",[t._v("如果命中old区域，则根据内存数据页存活时间与"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("innodb_old_blocks_time")])]),t._v("(默认1s)比较的结果决定:\n"),r("ul",[r("li",[t._v("如果数据页在LRU链表存在的时间大于1s，则将他提到head位置")]),t._v(" "),r("li",[t._v("如果数据页在LRU链表存在的时间小于1s，则原地不动。")])])],1)])]),t._v(" "),r("li",[t._v("如果内存没有命中，"),r("strong",[t._v("从磁盘读新的数据页，并放在LRU_old指针位置")]),t._v("。同时删除tail数据页。")])]),t._v(" "),r("p",[t._v("因此虽然大表也会用到buffer pool，但因为它每个数据页读得快，"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("只会扫描一次")])]),t._v("，所以只会老老实实呆在old区域。"),r("font",{attrs:{color:"red"}},[r("strong",[t._v("对整个young区域没有影响，从而保证正常业务的buffer pool命中率")])]),t._v("。")],1),t._v(" "),r("p",[t._v("显然如果"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("innodb_old_blocks_time")])]),t._v("越小，则表示对所有的表数据一视同仁，内存淘汰算法退化为上面的普通LRU。而如果"),r("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[r("strong",[t._v("innodb_old_blocks_time")])]),t._v("越大，则“LRU算法性”越弱，退化为普通内存。")],1),t._v(" "),r("p",[t._v("总结：old区域放冷数据历史数据，短时间内会被优先清除。而young则存放真正最近访问的数据，短时间内不会被清除。")]),t._v(" "),r("h2",{attrs:{id:"_3-客户端阻塞会给服务端造成什么影响"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-客户端阻塞会给服务端造成什么影响"}},[t._v("#")]),t._v(" 3.客户端阻塞会给服务端造成什么影响")]),t._v(" "),r("p",[t._v("客户端请求数据时如果因为阻塞导致一直不接受服务端数据，那么当前这个事务就是”长事务“。")]),t._v(" "),r("ul",[r("li",[t._v("当前事务因为占据锁资源，因此导致其它语句被锁住。")]),t._v(" "),r("li",[t._v("如果频繁执行更新事务，undolog不断变大由于服务端阻塞无法被回收，磁盘爆满。")])])])}),[],!1,null,null,null);r.default=s.exports}}]);