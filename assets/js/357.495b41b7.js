(window.webpackJsonp=window.webpackJsonp||[]).push([[357],{676:function(t,s,i){"use strict";i.r(s);var a=i(4),v=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),s("h2",{attrs:{id:"简单动态字符串sds"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简单动态字符串sds"}},[t._v("#")]),t._v(" 简单动态字符串SDS")]),t._v(" "),s("p",[t._v("①字符串长度②申请的总的内存大小")]),t._v(" "),s("p",[t._v("内存预分配扩容机制：追加新的字符串时，如果新字符串小于1M，则新的空间扩展为字符串长度2倍+1")]),t._v(" "),s("h2",{attrs:{id:"intset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#intset"}},[t._v("#")]),t._v(" IntSet")]),t._v(" "),s("p",[t._v("①编码方式②数组长度")]),t._v(" "),s("p",[t._v("编码方式动态升级：当添加的数字超过出int16的范围，那么IntSet会自动升级编码方式存储数组，然后"),s("strong",[t._v("倒序")]),t._v("依次将数组元素拷贝到扩容后的位置，"),s("strong",[t._v("如果插入的数小于0，则他比所有元素都小，插入数组头部；如果他大于0则添加的元素添加到数组的尾部")]),t._v("。整个数组保证"),s("strong",[t._v("有序")]),t._v("，底层是"),s("strong",[t._v("二分查找")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"dict"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dict"}},[t._v("#")]),t._v(" Dict")]),t._v(" "),s("p",[t._v("添加键值对时，首先根据key计算出hash值，然后通过hash&(size-1)计算元素存储到的索引位置。")]),t._v(" "),s("p",[t._v("有两个哈希表ht[2]，一个平常用，另一个rehash用")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/image-20230315084117947.3oeycxbnfdo0.webp",alt:"image-20230315084117947"}})]),t._v(" "),s("p",[t._v("添加元素时，根据负载因子(used/size)触发哈希扩容(扩容大小比当前size大1的最近的2的倍数)；删除元素时会检查是否收缩。无论是扩容还是收缩，"),s("strong",[t._v("当哈希表的大小变化时，需要计算所有key的索引，并插入到新的哈希表中。数据迁移时采用渐进式rehash，仅在每次增删改查时迁移一个角标的元素到ht[1]上")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"ziplist-quicklist-listpack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ziplist-quicklist-listpack"}},[t._v("#")]),t._v(" ZipList-quicklist-listpack")]),t._v(" "),s("ul",[s("li",[t._v("ZipList")])]),t._v(" "),s("p",[t._v("双端链表每个节点结构：①"),s("strong",[t._v("前一个节点长度prevlen")]),t._v("②编码方式③节点数据")]),t._v(" "),s("p",[t._v("问题：新增或者修改某个元素时，会导致内存占用空间重新分配，并且后续元素的prevlen占用空间发生变化，引起"),s("strong",[t._v("连锁更新")]),t._v("问题。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/image-20230315193053244.2wiity9rkyw0.webp",alt:"image-20230315193053244"}})]),t._v(" "),s("ul",[s("li",[t._v("QuickList")])]),t._v(" "),s("p",[t._v("解决ZipList存储大量数据，同时内存申请效率比较低。")]),t._v(" "),s("p",[t._v("使用QuickList双端链表来将所有ZipList串起来，每个节点包含一个前向指针，后向指针，ZipList指针。每个节点还可以设置是否对ZipList压缩。")]),t._v(" "),s("h2",{attrs:{id:"skiplist跳表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#skiplist跳表"}},[t._v("#")]),t._v(" SkipList跳表")]),t._v(" "),s("ul",[s("li",[t._v("元素按照得分score升序排列存储")]),t._v(" "),s("li",[t._v("每个节点包含多个指针，指针跨度不同。查找时根据不同指针跨度的score和要查询的score进行比较，如果比所要查询的score小，那就找跨度更大的指针。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/image-20230315110303172.37ojuxbs8880.webp",alt:"image-20230315110303172"}})]),t._v(" "),s("ul",[s("li",[s("p",[t._v("跳表中，每个节点出了包含下个节点的指针外，还可能包含多个后面节点的指针，"),s("strong",[t._v("越高层的指针跨越的节点数越多")]),t._v("。跳表一个重要性质是一个节点如果在"),s("strong",[t._v("第i层链表")]),t._v("出现，那么在"),s("strong",[t._v("第1到i-1层链表中也会出现")]),t._v("。比如要在一个有序链表中查找元素，可以通过跳表跳过查找一些中间元素，从而减少查找时间。其实是一种空间换时间的做法。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/1370c676b28a48dc827e378895471560.lptjq5kzg9c.webp",alt:"Snipaste_2022-02-27_10-22-08"}})])])]),t._v(" "),s("h2",{attrs:{id:"redisobject"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redisobject"}},[t._v("#")]),t._v(" RedisObject")]),t._v(" "),s("ul",[s("li",[t._v("set：HT，Intset(如果是数值类型)")])]),t._v(" "),s("p",[t._v("使用HT的"),s("strong",[t._v("key存储元素")]),t._v("，"),s("strong",[t._v("value统一设置为null")]),t._v("，底层跟java的hashmap和hashset一致。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Zset：HT+SkipList,ZipList(数据量少时"),s("strong",[t._v("节省内存")]),t._v("使用ziplist，让element和score紧挨保存在相邻的entry中)。通过一个哈希表(维护姓名->分数的一个映射关系)和一个跳表(存储分数)来实现，"),s("strong",[t._v("查找某个节点排名时，只需从高层到底层把跨度相加起来，得到排名结果。它的查询次数是远比普通链表要小的。")])])]),t._v(" "),s("li",[s("p",[t._v("Hash：HT，ZipList")])])])])}),[],!1,null,null,null);s.default=v.exports}}]);