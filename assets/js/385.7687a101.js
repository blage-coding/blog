(window.webpackJsonp=window.webpackJsonp||[]).push([[385],{705:function(t,s,a){"use strict";a.r(s);var n=a(4),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"自增主键"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自增主键"}},[t._v("#")]),t._v(" 自增主键")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("自增主键：")]),t._v(" "),s("p",[t._v("能够保证新数据能够按照主键递增的顺序进行插入。")])]),t._v(" "),s("h2",{attrs:{id:"自增值保存在哪"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自增值保存在哪"}},[t._v("#")]),t._v(" 自增值保存在哪？")]),t._v(" "),s("p",[t._v("每次执行insert语句之后，id+=1，那么这个id的值保存在哪？")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("MyISAM引擎的表自增值保存在数据文件中。")])]),t._v(" "),s("li",[s("p",[t._v("InnoDB引擎中的id自增值保存在内存中。根据MySQL版本号存在如下区别：")]),t._v(" "),s("ul",[s("li",[t._v("MySQL5.7及之前的版本：保存在内存中，并且"),s("strong",[t._v("不会进行持久化")]),t._v("，每次插入新的数据都会加1。如果遇上重启则内存的最大自增值会丢失，开机后会扫描表获取当前所有行记录id的最大值max(id)，并把max(id)+1作为下一个记录的自增值。\n"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("重启可以刷新最准确的max(id)值，填补空洞")])]),t._v("(但为了保证有序性，中间的id空洞并不能解决)。")],1)])]),t._v(" "),s("li",[s("p",[t._v("MySQL8.0版本：将自增值的变更记录在redolog当中，如果发生重启就直接依靠redolog进行恢复。")])])]),t._v(" "),s("h2",{attrs:{id:"自增值修改机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自增值修改机制"}},[t._v("#")]),t._v(" 自增值修改机制")]),t._v(" "),s("p",[s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[t._v("auto_increment_offset")]),t._v("：自增的初始值")],1),t._v(" "),s("p",[s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[t._v("auto_increment_increment")]),t._v("：自增的步长")],1),t._v(" "),s("p",[t._v("假设的当前表的自增值为"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("，执行insert语句时，自增字段的值根据以下规则决定：")],1),t._v(" "),s("ul",[s("li",[t._v("insert(null,4)插入时自增字段为0，null或未指定值，那么就把当前行的自增字段值设置为"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("，然后"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("自增。")],1),t._v(" "),s("li",[t._v("insert(X,3)插入行记录时指定自增字段的值X：\n"),s("ul",[s("li",[t._v("X>="),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("：则将当前自增值"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("更新为X+1，当前行的自增字段值为X")],1),t._v(" "),s("li",[t._v("X<"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("：则只需要将当前行的自增字段值为X")],1)])])]),t._v(" "),s("h2",{attrs:{id:"自增值空洞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自增值空洞"}},[t._v("#")]),t._v(" 自增值空洞")]),t._v(" "),s("p",[t._v("假设表t主键id字段自增，c字段作为"),s("strong",[t._v("唯一索引")]),t._v("。以下几种情况可能会导致出现自增值不连续的情况：")]),t._v(" "),s("h3",{attrs:{id:"场景一、唯一性约束导致自增值插入失败"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景一、唯一性约束导致自增值插入失败"}},[t._v("#")]),t._v(" 场景一、唯一性约束导致自增值插入失败")]),t._v(" "),s("p",[t._v("此时数据库中的表t已经存在一行记录(1,1,1)")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ol",[s("li",[t._v("执行器调用InnoDB引擎写入(0，1，1)这行新的数据")]),t._v(" "),s("li",[t._v("InnoDB发现自增的字段为0、则获取当前表t的自增字段"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("=2")],1),t._v(" "),s("li",[t._v("传入的数据变成(2,1,1)")]),t._v(" "),s("li",[s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("字段自增")],1),t._v(" "),s("li",[s("strong",[t._v("执行(2,1,1)数据插入操作")]),t._v("。此时才发现表中c字段值1已经出现，因此报Duplicate key错误，返回")])]),t._v(" "),s("p",[t._v("可以发现上面的过程中id=2这行数据并没有插入，因此存在“空洞”，主键值不连续。")]),t._v(" "),s("p",[t._v("而造成空洞的主要原因在于，"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("先进行表自增值自增，然后才会执行语句判断唯一性约束")])]),t._v("。")],1),t._v(" "),s("h3",{attrs:{id:"场景二、事务回滚"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景二、事务回滚"}},[t._v("#")]),t._v(" 场景二、事务回滚")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("begin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("rollback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("ol",[s("li",[t._v("第二个insert语句插入(2,2,2)后，"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("=3")],1),t._v(" "),s("li",[t._v("回滚后，表中会删除(2,2,2)这条数据，"),s("strong",[t._v("但是"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[t._v("AUTO_INCREMENT")]),t._v("自增值并不会回滚")],1),t._v("。")]),t._v(" "),s("li",[t._v("第三个insert语句插入(3,2,2)")])]),t._v(" "),s("p",[t._v("而这里MySQL之所以不将自增值回滚，主要是为了提升性能。这里如果将“允许自增值回滚”这一条件带入以下多并发线程的场景，分析如下：")]),t._v(" "),s("ol",[s("li",[t._v("A线程插入id=2,B线程插入id=3，当前"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("=4")],1),t._v(" "),s("li",[t._v("B线程成功提交，而A线程违反唯一键约束，事务回滚，此时根据上面的条件"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),t._v("会回滚变成2")],1),t._v(" "),s("li",[t._v("接下来，C线程连续插入两条insert语句，分别插入id=2，id=3，就会导致出现"),s("strong",[t._v("主键冲突")]),t._v("。")]),t._v(" "),s("li",[t._v("而要解决上述主键冲突，要么就是每次生成id时判断表中是否已经存在，要么就是按照事务提交顺序释放自增值的锁。无论是哪一种无疑都非常影响MySQL的性能。")])]),t._v(" "),s("p",[t._v("综上，"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("如果MySQL允许自增值随着redolog进行回滚，那么在多并发情况下，就不能够保证")])]),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("AUTO_INCREMENT")])]),s("font",{attrs:{color:"red"}},[s("strong",[t._v("一定大于当前表中的max(id")])]),t._v(")。")],1),t._v(" "),s("h3",{attrs:{id:"场景三、批量数据插入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景三、批量数据插入"}},[t._v("#")]),t._v(" 场景三、批量数据插入")]),t._v(" "),s("p",[t._v("MySQL5.1.22引入一个自增锁的策略，通过设置"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("innodb_autoinc_lock_mode")])]),t._v("参数值，采用不同的自增锁：")],1),t._v(" "),s("ul",[s("li",[t._v("设置为0：表示语句执行结束后才会释放锁")]),t._v(" "),s("li",[t._v("设置为1：\n"),s("ul",[s("li",[t._v("如果是普通insert语句：申请完毕后直接释放")]),t._v(" "),s("li",[t._v("如果是insert ... select这样的批量插入语句，自增锁会等待语句执行完毕后才被释放")])])]),t._v(" "),s("li",[t._v("设置为2：所有自增值申请完毕后立即释放")])]),t._v(" "),s("h4",{attrs:{id:"inert-into"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#inert-into"}},[t._v("#")]),t._v(" inert into (),()")]),t._v(" "),s("p",[t._v("insert插入多个value的情况下，因为MySQL可以计算出需要多少个id，因此一次性申请完后多个id后，直接释放锁。")]),t._v(" "),s("h4",{attrs:{id:"insert-select批量插入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#insert-select批量插入"}},[t._v("#")]),t._v(" insert ... select批量插入")]),t._v(" "),s("p",[t._v("insert ... select语句执行时，如果是申请完一个id就释放锁，那么在多并发情况下这条批量语句生成的id并"),s("strong",[t._v("不一定连续")]),t._v("，因为可能会受到其它session的影响。而"),s("strong",[t._v("binlog为statement在恢复时可以保证连续")]),t._v("，这样就会造成主备不一致。")]),t._v(" "),s("p",[t._v("解决方案有两种：")]),t._v(" "),s("p",[t._v("✨将"),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("innodb_autoinc_lock_mode")])]),t._v("设置为1，让自增锁执行完语句再释放。")],1),t._v(" "),s("p",[t._v("✨在生产上，从"),s("strong",[t._v("并发角度考虑")]),t._v("更多会采取这种做法："),s("font",{staticStyle:{background:"rgb(240, 240, 236)"},attrs:{color:"#d94a33"}},[s("strong",[t._v("innodb_autoinc_lock_mode")])]),s("strong",[t._v("设置为2")]),t._v("，同时"),s("font",{attrs:{color:"red"}},[s("strong",[t._v("binlog设置为row")])]),t._v("。这样保证备库应用binlog时直接利用主库记录的id值插入数据("),s("strong",[t._v("允许乱序插入id+主备一致")]),t._v(")。")],1),t._v(" "),s("h4",{attrs:{id:"mysql批量申请自增id策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql批量申请自增id策略"}},[t._v("#")]),t._v(" MySQL批量申请自增id策略")]),t._v(" "),s("p",[t._v("批量申请自增id策略："),s("font",{attrs:{color:"red"}},[s("strong",[t._v("每一次申请到的id个数是上一次申请的两倍，当前申请的id用完后才会进行下一轮的申请")])]),t._v("。")],1),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("d "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t2 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("假设当前t表只有四行数据：那么执行过程如下：")]),t._v(" "),s("ol",[s("li",[t._v("首先执行批量插入语句：\n"),s("ul",[s("li",[t._v("第一行数据，第一次申请i一个id，id=1;并将id=1分配给第一行数据")]),t._v(" "),s("li",[t._v("第二行数据，"),s("strong",[t._v("由于第一次申请的id已经用完")]),t._v("，因此第二次申请两个id，id=2,3。并将id=2分配给第二行数据")]),t._v(" "),s("li",[t._v("第三行数据，第二次申请的id还没用完，不申请新的id。将id=3分配给第三行")]),t._v(" "),s("li",[t._v("第四行数据，由于第二次申请的id用完了，因此第三次申请四个id，id=4,5,6,7。并将id=4分配给第四行数据")]),t._v(" "),s("li",[t._v("剩余id=5,6,7在insert...select批量语句已经用不到了，因此直接丢弃")])])]),t._v(" "),s("li",[t._v("执行当行插入insert，此时申请到的id就是id=8。导致出现自增值空洞。")])]),t._v(" "),s("div",{attrs:{align:"left"}},[s("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230711/image.4h6zqkac2ps0.webp"}})]),t._v(" "),s("h2",{attrs:{id:"自增值的主备同步问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自增值的主备同步问题"}},[t._v("#")]),t._v(" 自增值的主备同步问题")]),t._v(" "),s("p",[t._v("场景：多并发情况下线程A先执行insert(null)，后写binlog；线程B后执行insert(null)，先写binlog。那么binlog恢复时，先恢复执行B线程的插入记录，那么这个自增id会不会与主库不一致？")]),t._v(" "),s("p",[t._v("每个insert语句执行之前，"),s("strong",[t._v("会固定有一句SET INSERT_ID=2,提前设置好当前的自增值")]),t._v("，而这个设置自增ID的语句"),s("strong",[t._v("也会同时记录进binlog")]),t._v("。")]),t._v(" "),s("p",[t._v("因此binlog恢复时，"),s("strong",[t._v("每个insert语句前都会紧跟着一个记录使用到的自增id的设置语句")]),t._v("。")])])}),[],!1,null,null,null);s.default=r.exports}}]);