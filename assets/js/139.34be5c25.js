(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{457:function(t,n,l){"use strict";l.r(n);var s=l(4),a=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_662-二叉树最大宽度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_662-二叉树最大宽度"}},[t._v("#")]),t._v(" 662.二叉树最大宽度")]),t._v(" "),n("p",[t._v("给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。")]),t._v(" "),n("p",[t._v("输入:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("     1\n   /   \\\n  3     2\n / \\     \\ \n5   3     9 \n")])])]),n("p",[t._v("输出: 4")]),t._v(" "),n("p",[t._v("解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。")]),t._v(" "),n("ol",[n("li",[t._v("遍历一趟二叉树，"),n("strong",[t._v("把每个节点的线性表存储节点序号保存在节点val值上(合理利用资源)")]),t._v("，用一个双端队列Deque实现层次遍历，记录每层第一个节点和最后一个节点的序号差，相减即为该层的宽度。")])])])}),[],!1,null,null,null);n.default=a.exports}}]);