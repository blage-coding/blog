(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{332:function(t,n,s){"use strict";s.r(n);var a=s(4),r=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_1-两数之和"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-两数之和"}},[t._v("#")]),t._v(" 1.两数之和")]),t._v(" "),n("p",[t._v("给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。")]),t._v(" "),n("blockquote",[n("p",[t._v("输入：nums = [3,2,4], target = 6\n输出：[1,2]")])]),t._v(" "),n("ol",[n("li",[t._v("双for时间复杂O(n^2)，要想O(n)用哈希表。"),n("strong",[t._v("哈希表中存放的value是数组的索引下标")]),t._v("，但是用哈希表有一个问题，如果数组中有两个相同值则只能保存一个索引下标。实际上这点并不影响我们做题，遍历时只需要判断索引值不同即可。")]),t._v(" "),n("li",[t._v("这里哈希表的巧妙的用法在于存储了"),n("strong",[t._v("数组每个元素的存在性信息")]),t._v("，通过hashmap.containsKey(target-nums[i])来判断另一半是不是在数组中。")])])])}),[],!1,null,null,null);n.default=r.exports}}]);