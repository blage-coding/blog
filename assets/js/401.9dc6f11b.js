(window.webpackJsonp=window.webpackJsonp||[]).push([[401],{720:function(e,r,t){"use strict";t.r(r);var o=t(4),a=Object(o.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"dubbo泛化调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo泛化调用"}},[e._v("#")]),e._v(" Dubbo泛化调用")]),e._v(" "),r("h2",{attrs:{id:"_1-泛化调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-泛化调用"}},[e._v("#")]),e._v(" 1.泛化调用")]),e._v(" "),r("h4",{attrs:{id:"dubbobootstrap-start"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbobootstrap-start"}},[e._v("#")]),e._v(" DubboBootstrap#start()")]),e._v(" "),r("p",[e._v("①初始化")]),e._v(" "),r("p",[e._v("②暴露服务exportServices："),r("strong",[e._v("ConfigManager配置管理者把所有配置(包括应用、注册中心、服务)存放在Map容器中，暴露服务时会取出所有ServiceConfig执行export进行暴露")]),e._v("。")]),e._v(" "),r("p",[e._v("③引用服务referServices：首先先从configManager中取出所有的"),r("strong",[e._v("ReferenceConfig")]),e._v("，执行get方法初始化。首先根据引用配置对象生成key然后从缓存中取代理，如果没有则通过调用ReferenceConfig的init方法创建代理对象。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.cn/post/7040443915983388703#heading-12",target:"_blank",rel:"noopener noreferrer"}},[e._v("DubboBootstrap启动流程"),r("OutboundLink")],1)]),e._v(" "),r("h4",{attrs:{id:"referenceconfigcache"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#referenceconfigcache"}},[e._v("#")]),e._v(" ReferenceConfigCache")]),e._v(" "),r("p",[e._v("ReferenceConfig实例是一个比较重的实例，其中init初始化方法里，实现了通过与注册中心与提供者连接创建代理的过程。因此需要ReferenceConfigCache作为缓存，"),r("strong",[e._v("根据referenceConfig对象生成的key")]),e._v("获取对应的泛化代理对象。最终Dubbo代理是通过Javassist字节码增强技术创建动态代理。")]),e._v(" "),r("p",[e._v("此处key的生成规则是group/版本/接口，可以根据业务和场景需求通过SPI修改生成策略。")]),e._v(" "),r("h2",{attrs:{id:"_2-dubbo缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-dubbo缓存"}},[e._v("#")]),e._v(" 2.Dubbo缓存")]),e._v(" "),r("ul",[r("li",[e._v("referenceConfig获取GenericService泛化调用对象时，会先从缓存取出实例化对象")])]),e._v(" "),r("p",[e._v("①根据实验结果分析，这里"),r("font",{attrs:{color:"red"}},[r("strong",[e._v("服务提供方接口缓存是持久化的缓存，也就是说Dubbo每向zk暴露一个泛化接口，都会保存在本地，无论zk与Dubbo启动还是关闭都存在。")])])],1),e._v(" "),r("p",[e._v("②从缓存Map中取出泛化服务引用的key，是"),r("strong",[e._v("根据分组+版本号+接口全限定名来生成")]),e._v("。")]),e._v(" "),r("p",[e._v("这也就解释了为什么后面改了一个版本号就又不能进行泛化调用了。")]),e._v(" "),r("ul",[r("li",[e._v('如果缓存没有实例化过，则会调用init根据Dubbo连接传入的配置，实例化"服务引用"')])]),e._v(" "),r("p",[e._v('实例化"服务引用"过程默认要check服务提供者是否存在，不存在则抛异常导致实例化失败(此时已经在zookeeper上创建了消费者节点)。下一次通过ReferenceConfig获取"服务引用"又会失败(也会创建消费者节点，消费者节点上会带上时间戳所以每次都会创建新的节点)。可能会出现无限重复创建zk消费者节点。')])])}),[],!1,null,null,null);r.default=a.exports}}]);