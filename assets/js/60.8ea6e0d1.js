(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{378:function(_,t,v){"use strict";v.r(t);var n=v(4),o=Object(n.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_59-螺旋矩阵ii"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_59-螺旋矩阵ii"}},[_._v("#")]),_._v(" 59.螺旋矩阵Ⅱ")]),_._v(" "),t("p",[_._v("给你一个正整数 "),t("code",[_._v("n")]),_._v(" ，生成一个包含 "),t("code",[_._v("1")]),_._v(" 到 "),t("code",[_._v("n2")]),_._v(" 所有元素，且元素按顺时针顺序螺旋排列的 "),t("code",[_._v("n x n")]),_._v(" 正方形矩阵 "),t("code",[_._v("matrix")]),_._v(" 。")]),_._v(" "),t("blockquote",[t("p",[_._v("输入：n = 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]")])]),_._v(" "),t("ol",[t("li",[_._v("首先"),t("strong",[_._v("定义四个变量表示上下左右四个边界,矩阵上界为low，下界为high")]),_._v("。生成时有两种思路，一种是从外层生成到内层，每次生成一层;另一种是每次在一个方向上生成，到头后开始下一个方向。按照一层层来生成的话，往右方向生成碰到右边界后，下边界加一，并且"),t("strong",[_._v("把当前坐标置为往下遍历生成的第一个坐标")]),_._v("(i坐标加一，j坐标减一)，其他几个方向同理。注意能否进入右方向生成的判断条件：")])]),_._v(" "),t("ul",[t("li",[_._v("除了j坐标没有碰到右边界外，还需要用已生成元素数量来约束(只要没生成满，那么右和下方向只要对应坐标没触碰到边界，坐标肯定是合法的；"),t("strong",[_._v("否则仅限制一个坐标，另一个方向的坐标可能已经越界导致生成地址非法")]),_._v(")，"),t("strong",[_._v("if(ele<n*n+1&&j<right)")]),_._v("。")]),_._v(" "),t("li",[_._v("也可以直接限制当前两个坐标是否合法来判断能否继续生成，"),t("strong",[_._v("if(i>low&&i<high&&j>left&&j<right)")]),_._v("。")])])])}),[],!1,null,null,null);t.default=o.exports}}]);