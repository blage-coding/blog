(window.webpackJsonp=window.webpackJsonp||[]).push([[339],{658:function(t,n,e){"use strict";e.r(n);var o=e(4),r=Object(o.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"netty原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty原理"}},[t._v("#")]),t._v(" Netty原理")]),t._v(" "),n("h2",{attrs:{id:"_1、事件传播"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、事件传播"}},[t._v("#")]),t._v(" 1、事件传播")]),t._v(" "),n("ul",[n("li",[t._v("pipeline初始化")])]),t._v(" "),n("p",[t._v("①所有channelHandler由channelPipeline统一管理，"),n("strong",[t._v("pipeline维护一个双向链表结构")]),t._v("。")]),t._v(" "),n("p",[t._v("②channelPipeline初始化时，会默认"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("创建两个哨兵channelHandler，即HeadContext、TailContext，HeadContext在链表头部，TailContext在尾部")])]),t._v("，我们添加的channelHandler总是处于二者之间。")],1),t._v(" "),n("p",[t._v("③以fineXXX命名的方法都是从IO线程向用户业务handler的"),n("strong",[t._v("inBound事件")]),t._v("。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230515/2020060922065856%5B1%5D.31clva57g8k0.webp",alt:"img"}})]),t._v(" "),n("ul",[n("li",[t._v("传播方式")])]),t._v(" "),n("p",[t._v("①通过当前通道"),n("strong",[t._v("ctx.channel()传播")]),t._v("，实际上就是通过"),n("strong",[t._v("pipeline传播")]),t._v("。")]),t._v(" "),n("p",[n("strong",[t._v("channel")]),t._v("传播"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("inbound")])]),t._v("入站事件时，起点为"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("HeadContext")])]),t._v("，"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("从左向右")])]),t._v("触发遇到的"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("第一个inbound事件")])]),t._v("。")],1),t._v(" "),n("p",[n("strong",[t._v("channel")]),t._v("传播"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("outbound")])]),t._v("出站事件时，起点为"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("TailContext")])]),t._v("，"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("从右向左")])]),t._v("触发遇到的"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("第一个outbound事件")])]),t._v("。")],1),t._v(" "),n("p",[t._v("②通过"),n("strong",[t._v("ChannelHandlerContext上下文传播")]),t._v("。")]),t._v(" "),n("p",[n("strong",[t._v("ctx")]),t._v("传播"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("inbound")])]),t._v("入站事件时，起点为"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("当前channelHandler")])]),t._v("，"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("从左向右")])]),t._v("触发遇到的"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("第一个inbound事件")])]),t._v("。")],1),t._v(" "),n("p",[n("strong",[t._v("ctx")]),t._v("传播"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("outbound")])]),t._v("出站事件时，起点为"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("当前channelHandler")])]),t._v("，"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("从右向左")])]),t._v("触发遇到的"),n("font",{attrs:{color:"red"}},[n("strong",[t._v("第一个outbound事件")])]),t._v("。")],1),t._v(" "),n("ul",[n("li",[t._v("举例")])]),t._v(" "),n("p",[t._v("①ByteToMessageDecoder#channelRead调用了channel.writeAndFlush，那么会依次触发MessageToByteEncoder#write事件、HeadContext#write事件；而如果是调用ctx.writeAndFlush那么只会触发HeadContext#write事件。")]),t._v(" "),n("p",[t._v("②BizHandler#channelRead调用了channel.fireChannelRead，那么会依次触发HeadContext#channelRead事件、ByteToMessageDecoder#channelRead事件、BizHandler#channelRead事件...，并会"),n("strong",[t._v("造成读事件的死循环")]),t._v("。因此一般传播读事件时会通过ctx.fireChannelRead进行，只会触发TailContext#channelRead事件并结束。")])])}),[],!1,null,null,null);n.default=r.exports}}]);