(window.webpackJsonp=window.webpackJsonp||[]).push([[371],{689:function(r,_,v){"use strict";v.r(_);var t=v(4),s=Object(t.a)({},(function(){var r=this,_=r._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[_("h1",{attrs:{id:"索引深入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引深入"}},[r._v("#")]),r._v(" 索引深入")]),r._v(" "),_("h2",{attrs:{id:"_1-普通索引和唯一索引的选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-普通索引和唯一索引的选择"}},[r._v("#")]),r._v(" 1.普通索引和唯一索引的选择")]),r._v(" "),_("p",[r._v("对于表中的字段k，在不同业务下考虑添加什么类型的索引可以提高性能。")]),r._v(" "),_("h3",{attrs:{id:"_1-1查询读操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1查询读操作"}},[r._v("#")]),r._v(" 1.1查询读操作")]),r._v(" "),_("p",[r._v("考虑如下语句(假设k不作为主键)：")]),r._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("select")]),r._v(" id "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("from")]),r._v(" T "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("where")]),r._v(" k"),_("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[r._v("5")]),r._v("；\n")])]),r._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[r._v("1")]),_("br")])]),_("ul",[_("li",[r._v("唯一索引：首先去k的二级索引树搜索，因为"),_("strong",[r._v("唯一索引保证了索引字段列数据的唯一性")]),r._v("，因此找到(k=5,id=500)这一条记录后，直接进行回表。")]),r._v(" "),_("li",[r._v("普通索引：首先去k的二级索引树搜索，查询到(k=5,id=500)这一条记录后，"),_("strong",[r._v("会继续查找下一个k的记录，直到碰到第一个k不等于5的记录")]),r._v("。最后进行回表。")])]),r._v(" "),_("p",[r._v("普通索引因为没有唯一性，因此多了一个继续往后查找，直到不满足查询条件的操作。这里假设业务代码已经控制了k字段的唯一性，并且所查询记录出现在内存数据页的概率较低。")]),r._v(" "),_("p",[r._v("因此"),_("strong",[r._v("普通索引和唯一索引之间的在读操作上性能损耗几乎可以忽略不计")]),r._v("，几乎相同。")]),r._v(" "),_("h3",{attrs:{id:"_1-2更新写操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2更新写操作"}},[r._v("#")]),r._v(" 1.2更新写操作")]),r._v(" "),_("p",[r._v("InnoDB无论是进行读还是写，读取记录时都会将"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("该记录所在的数据页从磁盘读到内存")])]),r._v("，然后在该数据页上再通过"),_("strong",[r._v("二分法")]),r._v("找到具体行的数据。")],1),r._v(" "),_("ul",[_("li",[_("strong",[r._v("change buffer介绍")])])]),r._v(" "),_("p",[r._v("change buffer本质上是一个"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("更新操作专属的缓冲区")])]),r._v("，因为在进行更新操作时，并不需要将数据读取并返回客户，因此change buffer解决了"),_("strong",[r._v("更新操作导致的磁盘数据页频繁IO的问题")]),r._v("，更新操作时不需要将数据页读到内存中，只需要记录在内存中change buffer(事务提交后通过后台持久化到磁盘)。")],1),r._v(" "),_("p",[r._v("具体来说，更新时如果数据页已经在内存当中，那么直接更新。如果数据页不在内存中，更新时InnoDB只需要将更新操作记录在change buffer中，下一次"),_("strong",[r._v("查询操作")]),r._v("到来时会触发"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("merge操作")])]),r._v("，把数据页读入内存后"),_("strong",[r._v("执行change buffer中与这个页相关的操作")]),r._v("，然后写redo log(数据页变更)，merge结束。而此时内存中的数据页和change buffer都属于"),_("strong",[r._v("脏页")]),r._v("，后续需要刷盘。")],1),r._v(" "),_("p",[r._v("因此往往希望merge之前，change buffer存的更改操作越多越好，最后一次性写入到数据页中。好处：①减少磁盘IO，提升语句"),_("strong",[r._v("执行速度")]),r._v("②提高内存利用率，减少内存占用。")]),r._v(" "),_("ul",[_("li",[_("strong",[r._v("change buffer使用条件")])])]),r._v(" "),_("p",[r._v("对于唯一索引而言，因为每次执行插入语句都"),_("strong",[r._v("需要判断是否破坏唯一性约束")]),r._v("(并且马上将结果返回给调用方)，而这必须要将数据页读入内存中才能进行判断，因此就破坏了change buffer的延迟性。既然已经将数据写到内存了，那就没必要再用change buffer，直接修改内存的数据页即可。")]),r._v(" "),_("p",[r._v("因此"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("只有普通索引能够使用change buffer,唯一索引不能使用")])]),r._v("。业务能够接受的场景下使用普通索引，比如对于线上数据库和归档库，归"),_("strong",[r._v("档库相当于历史数据，已经确保不存在唯一键冲突")]),r._v("，因此可以将归档库索引改成普通索引，提高归档效率。")],1),r._v(" "),_("ul",[_("li",[_("strong",[r._v("change buffer更新操作与使用场景")]),r._v(" "),_("ul",[_("li",[r._v("唯一索引\n"),_("ul",[_("li",[r._v("数据页不在内存中：将数据页读入内存，判断是否存在字段冲突，没有冲突则插入数据，语句结束。")]),r._v(" "),_("li",[r._v("数据页在内存中：判断是否存在字段冲突，若没有冲突则写入内存数据页，语句结束。")])])]),r._v(" "),_("li",[r._v("普通索引(使用change buffer)\n"),_("ul",[_("li",[r._v("数据页不在内存中："),_("strong",[r._v("在change buffer中记录更新操作")]),r._v("，语句结束。")]),r._v(" "),_("li",[r._v("数据页在内存中：直接修改内存中的数据页，语句结束。")])])])])])]),r._v(" "),_("p",[r._v("✨"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("change buffer机制大大减少了普通索引下，更新操作带来的磁盘IO次数")])]),r._v("。因此对于"),_("strong",[r._v("写多读少")]),r._v("的场景(日志，账单类)，使用change buffer的效果最好。而对于"),_("strong",[r._v("更新之后马上需要进行查询")]),r._v("的场景效果比较差，此时多了change buffer的维护成本。")],1),r._v(" "),_("h3",{attrs:{id:"_1-3redo-log与change-buffer下的更新事务流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3redo-log与change-buffer下的更新事务流程"}},[r._v("#")]),r._v(" 1.3redo log与change buffer下的更新事务流程")]),r._v(" "),_("p",[r._v("为了便于区分与描述，"),_("strong",[r._v("将内存数据持久化到磁盘的过程称之为“写”，而将磁盘的数据读入到内存的过程称为“读")]),r._v("”。")]),r._v(" "),_("p",[_("strong",[r._v("redo log")]),r._v("分为两部分一部分在内存(redo log buffer)，一部分在磁盘(redo log file)。它的作用主要分为两个：")]),r._v(" "),_("ul",[_("li",[_("p",[r._v("保证数据一致性。通过redo log恢复数据库，进行备份。")])]),r._v(" "),_("li",[_("p",[r._v("将"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("随机写")])]),r._v("转换成"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("顺序写")])]),r._v("，"),_("strong",[r._v("减少随机写产生的磁盘IO性能消耗(组提交机制)")]),r._v("。首先明白一点，"),_("strong",[r._v("无论是redo log还是数据页，在内存还是磁盘中都各有一份备份")]),r._v("。以一个包含多个更新操作的事务提交过程为例，对于有无redo log可以分为两种情况：")],1),r._v(" "),_("ul",[_("li",[_("p",[r._v("如果没有使用redo log，"),_("strong",[r._v("那么每做一次更新操作，就需要立刻将内存中的数据页写到磁盘中")]),r._v("。而每个更新操作的数据页不一定是连续的，因此“随机写”产生的磁盘IO会非常"),_("strong",[r._v("耗时")]),r._v("。")])]),r._v(" "),_("li",[_("p",[r._v("如果使用redo log，那么整个更新事务会按顺序执行以下步骤：")]),r._v(" "),_("ul",[_("li",[_("p",[r._v("首先先更新内存中的数据页，根据是否使用change buffer，操作方式有所不同。")])]),r._v(" "),_("li",[_("p",[r._v("然后将上述更新操作记录到内存中的redo log buffer。")])]),r._v(" "),_("li",[_("p",[_("font",{attrs:{color:"red"}},[_("strong",[r._v("在内存中提交更新操作事务")])]),r._v("。")],1)]),r._v(" "),_("li",[_("p",[r._v("写日志：将内存中的redo log buffer持久化到磁盘redo log file。其中"),_("font",{attrs:{color:"red"}},[_("strong",[r._v('将redo log从内存持久化到磁盘的这个过程就是"顺序IO写"')])]),r._v("。redo log只是按顺序记录了每一个操作记录，因此刷盘时只需要顺序在redo log file的尾部append添加操作记录。——prepare状态")],1)]),r._v(" "),_("li",[_("p",[r._v("写数据页：MySQL"),_("strong",[r._v("后台任务")]),r._v("将内存中的数据页"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("异步")])]),r._v("同步刷到磁盘中，此处也分为两种情况：")],1),r._v(" "),_("p",[r._v("①使用了change buffer，则不需要“真同步”②没有使用change buffer，则需要将数据页同步到磁盘。——commit状态")])])])])])])]),r._v(" "),_("p",[r._v("🔥综上，redo log性能提升的点在于，把"),_("strong",[r._v("数据页从内存随机写到磁盘")]),r._v("的过程，转化为"),_("strong",[r._v("将redo log里的更新操作从内存顺序写到磁盘")]),r._v("的过程，从而大大"),_("strong",[r._v("减少执行更新操作时的响应时间")]),r._v("。最后在后台异步执行数据页的持久化，相当于将这个过程"),_("strong",[r._v("延后")]),r._v("了。")]),r._v(" "),_("p",[r._v("总结：因此change buffer节省的是“更新操作”下"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("读磁盘")])]),r._v("的IO消耗；而redo log节省的实际上是"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("写磁盘")])]),r._v("的IO响应时间。")],1),r._v(" "),_("h2",{attrs:{id:"_2-索引选错异常"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-索引选错异常"}},[r._v("#")]),r._v(" 2.索引选错异常")]),r._v(" "),_("p",[r._v("MySQL在某些情况下受到更新语句和查询语句的影响，导致选错索引从而影响查询性能。")]),r._v(" "),_("p",[_("strong",[r._v("explain+SQL查询语句")]),r._v("：查看当前语句使用的索引，以及"),_("strong",[r._v("执行这条SQL语句扫描的行数rows")]),r._v("。")]),r._v(" "),_("p",[_("strong",[r._v("show index from t")]),r._v("：查看当前表中每个索引的基数。")]),r._v(" "),_("h3",{attrs:{id:"_2-1优化器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1优化器"}},[r._v("#")]),r._v(" 2.1优化器")]),r._v(" "),_("p",[r._v("查询语句时，影响优化器选择索引进行查询的因素有以下几个：")]),r._v(" "),_("ul",[_("li",[r._v("扫描行数rows")])]),r._v(" "),_("p",[_("strong",[r._v("基数(cardinality")]),r._v(")：一个索引字段上不同值的个数；基数越大，索引的区分度越好。")]),r._v(" "),_("p",[_("strong",[r._v("采样统计")]),r._v("：计算N个数据页上的不同值的平均数。")]),r._v(" "),_("p",[_("strong",[r._v("修正命令")]),r._v("："),_("font",{attrs:{color:"red"}},[_("strong",[r._v("analyze table t")])]),r._v(";重新统计表的索引信息。")],1),r._v(" "),_("ul",[_("li",[r._v("回表")])]),r._v(" "),_("p",[r._v("当前索引的扫描行数虽然少，但是如果是二级索引还需要进行回表操作，代价更大。")]),r._v(" "),_("ul",[_("li",[r._v("排序")])]),r._v(" "),_("p",[r._v("当前查询语句包含order by b字段，那么直接使用b作为索引则不需要后续的排序，因为索引b的B+树已经完成了。")]),r._v(" "),_("h3",{attrs:{id:"_2-2索引选择异常处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2索引选择异常处理"}},[r._v("#")]),r._v(" 2.2索引选择异常处理")]),r._v(" "),_("p",[r._v("如果线上出现某个查询速度变慢，索引选择异常导致性能降低，那么可以尝试以下几种方案：")]),r._v(" "),_("ul",[_("li",[r._v("✨采用force index在查询时手动指定采用哪个索引进行查询")])]),r._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("select")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[r._v("*")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("from")]),r._v(" t "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("force")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("index")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v("(")]),r._v("a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(")")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("where")]),r._v(" a "),_("span",{pre:!0,attrs:{class:"token operator"}},[r._v("between")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[r._v("1")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[r._v("and")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[r._v("2000")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\n")])]),r._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[r._v("1")]),_("br")])]),_("p",[r._v("存在的问题在于变更的及时性。如果优化器选择的索引没有问题，那么需要重新修改语句。")]),r._v(" "),_("ul",[_("li",[r._v("✨"),_("strong",[r._v("修改SQL语句，引导优化器使用正确的索引")])])]),r._v(" "),_("p",[r._v("举例来说，如果只使用order by b进行查询并排序，此时会选择索引b。而在不影响最终查询结果的情况下，如果将查询语句的排序条件修改为order by b,a；也就是说将a和b索引在排序上的代价都控制为相同的，那么此时优化器就会选择a，因为它的行数更少。")]),r._v(" "),_("p",[r._v("另外"),_("strong",[r._v("增加limit的查询数量")]),r._v("，也可以增加该字段的代价。")]),r._v(" "),_("ul",[_("li",[r._v("✨"),_("strong",[r._v("直接删除当前优化器误用的索引")])])]),r._v(" "),_("p",[r._v("方法简单暴力有效，在不影响该索引在其它业务查询性能的情况下，可以使用这种方式。")]),r._v(" "),_("h3",{attrs:{id:"_2-3事务版本与rows计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3事务版本与rows计算"}},[r._v("#")]),r._v(" 2.3事务版本与rows计算")]),r._v(" "),_("p",[r._v("假设有如下场景：")]),r._v(" "),_("ul",[_("li",[r._v("事务A当前开启了事务")]),r._v(" "),_("li",[r._v("事务B开启了事务")]),r._v(" "),_("li",[r._v("事务B删除某张表的所有数据，然后重新恢复生成所有数据。")]),r._v(" "),_("li",[r._v("事务B执行查询语句，并调用explain查看该条SQL语句执行情况。")]),r._v(" "),_("li",[r._v("事务B关闭，事务A关闭")])]),r._v(" "),_("p",[r._v("此时explain后会发现优化器计算得到的当前扫描行数rows"),_("strong",[r._v("翻了一倍")]),r._v("。具体原因在于，首先事务A没有提交，因此事务B的删除操作无效，也就是"),_("strong",[r._v("事务A那个版本的所有数据还存在原先索引a上")]),r._v("。此时B再重新创建恢复数据，就会导致优化器认为"),_("strong",[r._v("索引a有两个版本的数据")]),r._v("。只有事务A提交之后事务版本小于低水位，当前索引才不可见。")]),r._v(" "),_("p",[r._v("而如果对于主键而言，rows的计算值并不会因为存在多版本数据而受到影响。它会直接根据"),_("strong",[r._v("表的行数")]),r._v("进行估计，使用show table status的值。")]),r._v(" "),_("h2",{attrs:{id:"_3-给字符串字段添加索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-给字符串字段添加索引"}},[r._v("#")]),r._v(" 3.给字符串字段添加索引")]),r._v(" "),_("p",[r._v("对于email邮箱字符串类型的字段，可以在该字段上添加不同的索引，分析如下：")]),r._v(" "),_("h3",{attrs:{id:"_3-1前缀索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1前缀索引"}},[r._v("#")]),r._v(" 3.1前缀索引")]),r._v(" "),_("p",[r._v("在email字段上建立取前六个字节的前缀索引，如图所示：")]),r._v(" "),_("p",[_("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230619/image.6lwt56jwg8w0.webp",alt:""}})]),r._v(" "),_("p",[r._v("和全字符串索引相比，前缀索引特点在于以下几个方面：")]),r._v(" "),_("ul",[_("li",[_("strong",[r._v("索引存储")])])]),r._v(" "),_("p",[r._v("在索引树上可以很明显的看出，前缀索引每个节点存储的数据更小，从而"),_("strong",[r._v("节省空间")]),r._v("。")]),r._v(" "),_("ul",[_("li",[_("strong",[r._v("执行过程")])])]),r._v(" "),_("p",[r._v("SQL语句中包含email字段的查询语句，假设保证email是唯一字段。")]),r._v(" "),_("p",[_("strong",[r._v("全字符串索引")]),r._v("：在email索引B+树中拿到主键后回表一次拿到对应的记录。然后回到email索引树查找下一个叶子节点，发现不满足查询条件，立即返回。")]),r._v(" "),_("p",[_("strong",[r._v("前缀索引")]),r._v("：同样会在前缀索引树中找到主键，然后回表读取记录。唯一不同之处在于，"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("判断每条记录是否满足查询条件，是在回表时的主键树下进行")])]),r._v("。换而言之"),_("strong",[r._v("因为它是前缀索引，MySQL并不清楚这个字段上的所有内容")]),r._v("，因此每次只能在主键树的叶子节点读取该记录的字段值，直到不满足查询条件。")],1),r._v(" "),_("p",[_("strong",[r._v("前缀索引在查询语句中，回表次数明显增加,增加扫描行数，影响性能")]),r._v("。因此往往希望建立前缀索引时，能够将数据区分得更开一些，用最小的空间代价换取尽可能高的查询性能。然而不论如何，"),_("strong",[r._v("查询性能再怎么样也比不过全字符串索引")]),r._v("。")]),r._v(" "),_("ul",[_("li",[_("strong",[r._v("覆盖索引")])])]),r._v(" "),_("p",[r._v("考虑如下SQL语句:")]),r._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("select")]),r._v(" id"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(",")]),r._v("email "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("from")]),r._v(" SUser "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("where")]),r._v(" email"),_("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[r._v('"xxxx"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\n")])]),r._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[r._v("1")]),_("br")])]),_("p",[_("strong",[r._v("全字符串索引")]),r._v("：在email索引树下叶子节点包含主键，因此触发覆盖索引，不需要回表。")]),r._v(" "),_("p",[_("strong",[r._v("前缀索引")]),r._v("：MySQL不能通过前缀索引获取该字段上的所有信息，因此select email需要回表在主键树上读取记录。"),_("strong",[r._v("即使通过修改前缀索引字段长度已经包含所有信息，但是InnoDB还是会到id索引查")]),r._v("。因此"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("前缀索引会导致覆盖索引优化失效")])]),r._v("。")],1),r._v(" "),_("h3",{attrs:{id:"_3-2其它索引方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2其它索引方式"}},[r._v("#")]),r._v(" 3.2其它索引方式")]),r._v(" "),_("p",[r._v("以身份证号等值查询为例，介绍两种索引存储方式。注意它们都"),_("strong",[r._v("不适用于范围查询")]),r._v("。")]),r._v(" "),_("ul",[_("li",[_("strong",[r._v("倒序存储")])])]),r._v(" "),_("p",[r._v("存储身份证号时，将身份证号"),_("strong",[r._v("倒着")]),r._v("存储建立索引。以为对于身份证号而言，后几位不像前几位包含地址码这些信息，后六位就可以提供足够的区分度。等值查询时记得通过reverse('input')将输入的身份证号翻转，才能和数据库中的数据进行匹配。")]),r._v(" "),_("p",[r._v("本质上是"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("解决前缀索引区分度不够的问题")])]),r._v("。")],1),r._v(" "),_("ul",[_("li",[_("strong",[r._v("添加哈希字段")])])]),r._v(" "),_("p",[r._v("创建一个新的哈希字段并给该字段添加索引，"),_("font",{attrs:{color:"red"}},[_("strong",[r._v("这个哈希字段的值根据身份证来生成")])]),r._v("。因为可能存在"),_("strong",[r._v("哈希冲突")]),r._v("，因此对身份证号的等值查询，除了对当前哈希字段查询以外(最左原则)，还需要包括身份证号字段。通过两个字段同时约束保证查询结果的精确性。")],1),r._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("where")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("hash")]),_("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[r._v("''")]),r._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[r._v("and")]),r._v(" card"),_("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[r._v("''")]),r._v("\n")])]),r._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[r._v("1")]),_("br")])])])}),[],!1,null,null,null);_.default=s.exports}}]);