---
title: 1483. 二进制倍增算法
date: 2023-06-12 11:29:21
permalink: /pages/6efd65/
categories:
  - 算法
  - 手撕算法
tags:
  - Leetcode
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# [1483. 树节点的第 K 个祖先](https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/)

## 1.二叉树倍增

分析：使用<font color="red">**二进制思想**</font>保存每个节点的所有祖先，从而查找的时间复杂度O(log n)，并且保存祖先节点时，开辟的空间大小为O(n*log n)。倍增算法和二分法复杂度类似，但是两者之间是完全相反的算法，二分法每次都会缩小一半，而倍增法每次都会扩大一倍。

**定义祖先数组ancestors\[ i \]\[ j \]为第i个节点的第2^j个祖先节点的标号**。

**状态转移公式**为ancestors【 i 】【 j 】=ancestors【ancestors\[i\]\[j-1\]】【j-1】，表示第i个节点的第2\^j个祖先，等于第i个节点的第2\^(j-1)个祖先的第2\^(j-1)个祖先。

查找：查找第k个祖先时，<font color="red">**每次查找的祖先代数为不大于k的最大二进制数**</font>。具体来说如果要找第7个祖先，先找到当前节点第4个祖先，然后再找下一个节点第2个祖先，最后再找到第1个节点，

```java
class TreeAncestor {
    int[][] ancestors;
    static final int LOG = 16;
    public TreeAncestor(int n, int[] parent) {
        ancestors=new int[n][LOG];
        for(int j=0;j<16;j++){
            for(int i=0;i<n;i++){
                if(j==0)  ancestors[i][j]=parent[i];
                else{
                    int node=ancestors[i][j-1];
                    ancestors[i][j]=node!=-1?ancestors[node][j-1]:-1;
                }
            }
        }
    }
    public int getKthAncestor(int node, int k) {
        int index=node;
        while(k>0){
            int mul=1;
            for(int i=0;i<16;i++){
                if(mul*2>k){
                    index=ancestors[index][i];
                    if(index==-1) return -1;
                    k-=mul;
                    break;
                }
                mul=mul<<1;
            }
        }
        return index;
    }
}
```

