# 1079.活字印刷

## dfs+回溯

解题思路：dfs\(len,map,set\)表示返回值是长度为len的所有可能的序列数。输入序列tiles，**对应能够生成的序列的长度大小就有titles.length()种可能**。
另外在dfs搜索中，根据Set集合确定<font color="red">**当前长度为len的序列的首字母，确定当前位置后，再递归确定长度为len-1的序列的首字母**</font>。**使用的是Set，所以不需要考虑重复字母导致的重复序列问题**。

```java
class Solution {
    public int numTilePossibilities(String tiles) {
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < tiles.length(); i++) {
            map.put(tiles.charAt(i), map.computeIfAbsent(tiles.charAt(i), key -> 0) + 1);
        }
        Set<Character> set = new HashSet<>(map.keySet());
        int res = 0;
        for (int i = 1; i <= tiles.length(); i++) {
            res += dfs(i, map, set);
        }
        return res;
    }

    public int dfs(int len, Map<Character, Integer> map, Set<Character> set) {
        if (len == 0) {
            return 1;
        }
        int sum = 0;
        for (Character character : set) {
            Integer integer = map.get(character);
            if (integer == 0) {
                continue;
            }
            map.put(character, integer - 1);
            sum += dfs(len - 1, map, set);
            //回溯复原
            map.put(character, integer);
        }
        return sum;

    }
}
```

### DP

定义dp\[i\]\[j\]表示用前i种字符，构造长度为j的序列的方案数量。