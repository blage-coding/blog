---
title: 2762. 不间断子数组
date: 2023-07-07 22:36:21
permalink: /pages/c94360/
categories:
  - 算法
  - 堆栈队列
tags:
  - Leetcode
  - 堆栈队列
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# [2762. 不间断子数组](https://leetcode.cn/problems/continuous-subarrays/)

## 1.TreeMap+滑动窗口

分析：滑动窗口内使用**TreeMap**维护子数组的最大值，最小值。

TreeMap具有如下性质：

- <font color="red">**插入元素时，在内部会对Key进行排序**</font>，默认是升序。
- 通过<font color="red">**firstKey()和LastKey()两个API分别获取第一个key和最后一个key的值**</font>(最小key和最大key)
- cellingKey(K num)：返回大于等于num的最小key值；floorKey(K num)：返回小于等于num的最大key值
- pollFirstEntry()：删除key最小的元素。

在本题中，key存放nums数组元素，value存放每个元素出现的次数。**通过首尾元素的key判断当前子数组是否不间断**。每轮记录以left为左指针的最大子数组。

```java
class Solution {
    public long continuousSubarrays(int[] nums) {
       long res=0;
        int left=0;
        TreeMap<Integer,Integer> treemap=new TreeMap<>();
        for(int i=0;i<nums.length;i++){
            treemap.put(nums[i],treemap.getOrDefault(nums[i],0)+1);
            while(treemap.lastKey()-treemap.firstKey()>2){
                res+=i-left;
                if(treemap.get(nums[left])==1) treemap.remove(nums[left]);
                else treemap.put(nums[left],treemap.get(nums[left])-1);
                left++;

            }
        }
        for(int i=left;i<nums.length;i++){
            res+=nums.length-i;
        }
        return res;
    }
}
```

## 2.优先级队列

事实上在本题中，如果想不到使用TreeMap，那么需要设计实现一个数据结构A，并且满足①A中元素根据nums元素排好序，这样才能直接**以O(1)的复杂度拿到子数组的上下界**②窗口移动时，因为**需要移除边界元素，更新当前子数组的上下界**，因此访问元素或者是直接删除操作复杂度需要为O(1)。

这里采用<font color="red">**两个优先级队列PriorityQueue进行模拟，一个是递增队列，另一个是递减队列**</font>。