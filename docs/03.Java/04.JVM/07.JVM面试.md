---
title: JVM面试
date: 2023-05-16 16:22:11
permalink: /pages/8bf49a/
categories: 
  - Java
  - JVM
tags: 
  - JAVA基础
  - 面试
author: 
  name: phan
  link: https://gitee.com/blage-coding

---
## JVM面试

## 一、什么是JAVA类加载？什么是双亲委派机制？JAVA类加载过程是怎么样？

1.类加载是指将类的.class文件的二进制数据读入JVM内存中，放在数据区的方法区中，然后在堆内创建一个该类的对象，其中**封装了类在方法区中的数据结构**。

2.双亲委派机制就是在类加载的过程中，首先**自底向上检查**类是否已经被加载，按照Custom->App->Extension->Bootstrap ClassLoader 类加载器顺序查找对应的缓存(不是继承关系)，如果有则返回。否则会**自顶向下加载类**。目的是保证所有的类加载器只加载一次，**保护JAVA底层的类不会被应用程序写的类覆盖**。

3.类加载过程：加载->连接->初始化。

- 加载

把JAVA字节码数据加载到JVM内存中。

- 连接

验证：检验加载的字节码信息是否符合JVM规范。
准备：创建类或者接口的静态变量，并赋初值(还未初始化)。

**JDK8之前，静态变量，常量池存储在方法区中，JDK8之后都迁移到了堆中。原先方法区的永久代被替换为元空间，它并不在虚拟机中，而是使用本地内存，防止OOM**。

- 解析

符号引用转为直接引用，在栈中初始化该符号引用的指针，并使其指向堆中分配好的空间。

## 二、JVM内存划分区域？一个对象从加载到JVM，再到被GC清除，都经历了什么过程？

1.每个线程都有一个独立的虚拟机栈，线程中**每个方法**都在虚拟机栈中开辟一个新的**栈帧**。其中每个栈帧用于存储方法**局部变量，操作数，方法出口，动态连接**等信息。

本地方法栈为虚拟机调用Native方法(非JAVA代码实现的方法)服务。

堆则用来存放所有**对象实例和数组**。方法区则用来存储虚拟机加载的**类型信息**、**静态变量**，以及运行时的**常量池**。
**其中类的静态变量以及静态代码块都是在类加载时创建的，除此外类的其他属性都是在对象初始化创建的。**

<img src="https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/fe7227f01bab432497bc3ce42ba5a204.4580kdnfc3e0.webp" alt="Snipaste_2022-02-16_20-35-07" style="zoom:60%;" />

2.用户创建一个对象，首先通过内存中class point找到方法区中的类型信息(元数据区中的class)。
然后在JVM中实例化对象，在堆中开辟空间，半初始化对象(存在指令重排)。

**对象会分配在堆内存中新生代Eden**.然后经过一次**Minor GC**,**对象如果存活就会进入s区**，在后续每次GC中，如果**对象一直存活就会在S区来回拷贝**，每移动一次年龄加一，最大年龄为15，**超过一定年龄就会移入老年代**。

**直到方法执行结束后栈中指针先移除掉**；堆中的对象经过**Full GC**，则会被标记为垃圾，然后被GC进程清除。 

## 三、怎么确定一个对象到底是不是垃圾？什么是GC Root？

1.引用计数：给堆中的对象创建一个引用计数来记录该对象被多少个栈指针所引用，每被引用一次就加一，当引用计数为零没有指针指向它时，则判断该对象为垃圾。 
但是这种方法有一个缺点，无法解决循环引用。就是当两个对象相互引用对方时，那么双方引用计数都为1，永远都不会被GC清除，就会产生**内存泄露**，进而有可能造成**内存溢出**。

2.根可达算法：这种方法就是通过**从GC Root一直向下找引用，找不到的对象就是垃圾**。 
GC Root一般包括JVM Stack,Native Stack,常量池，以及静态变量。

## 四、JVM有哪些垃圾回收算法？

1.MarkSweep标记清除算法：分为两个 阶段，标记阶段先把垃圾内存标记出来， 然后再把标记的内存回收。缺点是**会产生内碎**。

<img src='https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/e48df0b4f3e5416a88d2e0dd8ac95709.12k9dpk7pbmo.webp'>

2.copying拷贝算法：将内存分为大小相等的两半，**只使用一半的内存空间创建对象**。垃圾回收时将这一半中存活的对象拷贝到另一半中，然后当前这一半就可以全部清除回收。好处是没有内碎片，因为复制回去时会复制到连续内存区域。缺点是**浪费内存空间**，最多只能利用内存一半的空间创建对象，**且GC效率和当前存活对象有关**。

<img src="https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/da266bb2b6624add8e1348d2e9e87a0f.56haixqrcjo0.webp" alt="Snipaste_2022-02-16_20-35-07" style="zoom:60%;" />

3.Markcompack标记压缩算法：GC时**将存活对象往一端移动**，端边界后面的可以直接回收。

这三种算法各有利弊，除了要考虑回收后内存中对象的分布，还要考虑每种算法的复杂度。

## 五、什么是STW?JVM有哪些垃圾回收器？他们是如何工作的？为什么要设计这么多垃圾回收器？

1.STW：Stop The World，在垃圾回收算法过程中，**将JVM内存冻结的一个状态**。STW状态下，所有的线程(除了GC)都停止执行，native可以执行但是不能和JVM交互。**GC算法优化的关键，就是减少STW，也是JVM调优关键**。

2.根据堆内存中是否分新生代和老年代，可以分为分代和不分代的垃圾回收器。

- 分代垃圾回收器：

①Serial串行垃圾回收器：需要执行GC时暂停置为STW状态，由**一个线程**负责GC，然后继续执行其他线程。缺点是**多CPU架构下性能下降严重，一个线程GC回收不过来**。

②Parallel并行垃圾回收器：GC时**增加多个线程进行垃圾回收**。PS+PO是JDK1.8默认的垃圾回收器。

![Snipaste_2022-02-16_22-55-28](https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/65e4d0b34a2f41e99c97e29c7e3f1bbd.3c6mfwzbpfw0.webp)

③CMS:Concurrent Mark Sweep,核心思想是**让线程和GC线程并行执行各自的任务**，基于**标记清除算法**实现。
初始标记阶段(STW)，**只标记出GC Root根对象直接引用关联的对象**(类似于儿子节点)。
并发标记阶段，多条并发标记线程进行可达性分析，标记出所有的废弃对象。此过程是和用户线程并发执行
重新标记阶段(STW)，将刚才并发标记阶段**用户线程新产生的废弃对象**标记出来。
最后并发清除过程中，会把标记的废弃对象回收清除。这个过程中会产生浮动垃圾，**此清除过程中用户线程产生的废弃对象由下一次GC清除**。

![Snipaste_2022-02-16_22-57-24](https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230516/cf4f36b7b8154e42bbb163098d26f1f0.44fr8huordq0.webp)

- 不分代垃圾回收器

①G1 Garbage First，堆内存中不再区分新生代和老年代，而是划分成一个个的region区域，虽然形式上不分代，但是逻辑上依旧分代。核心思想是**每次GC只会回收废弃对象最多的Region**,价值小的Region先放着。清理时可以使用**Copying算法**，直接将Region拷贝到另一个Region，避免内碎产生。

②ZGC完全不分代。

3.内存逐渐变大，因此需要更多更高效的垃圾回收器。

## 六、什么是三色标记？如何解决错标记和漏标记的问题？

1.三色标记是CMS垃圾回收器的核心算法。黑色表示**对象自己和成员对象**都已经标记完；灰色表示自己标记完，但是成员对象还没有标记；白色是指自己未标记完。

2.**由于CMS存在浮动垃圾并且GC线程和用户线程并发运行**，因此会出现错标记或者漏标记的情况(黑指向白)。CMS通过**增量标记**，把黑色的都标记为灰色，这样子黑色下的白色就可以被发现。
G1通过**原始快照**保存变化的引用关系,通过扫描STAT来修改对应对象的颜色。

## 七、如何打破双亲委派机制？

自底向上：用户定义classloader->Application ClassLoader->Extension ClassLoader->Bootstrap ClassLoader

<font color="red">**要打破双亲委派机制**</font>，只需要**重写loadClass方法**。

## 八、对象创建创建时JVM会经过哪三步？对象在内存中的存储布局是怎样的？

1.对象创建时经过以下三步：①先在内存堆中给对象分配空间②初始化对象③把栈中的引用对象指向堆中分配好的空间。

2.对象存储布局包括：①四个字节的Markword对象头，来标记对象的属性，包括锁状态等等②四字节的**类型指针**，指向方法区的class类 ③成员变量信息④字节填充，使得能被八字节整除。 

## 九、JVM内存屏障

内存屏障解决了硬件层面的可见性和重排问题。loadstore屏障就表示前面这个volatile变量读和后面的写操作是**不能进行指令重排**的。屏障分为四种屏障，loadstore,loadload,storeload,storestore

JVM规定volatile修饰的变量，写之前需要插入stroestore屏障，写之后加入storeload
读之前加入loadload屏障，读之后加入loadstore屏障。