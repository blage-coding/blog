---
title: JAVA并发机制底层实现
date: 2023-09-29 15:26:25
permalink: /pages/4d277b/
categories:
  - Java
  - JUC
tags:
  - JUC
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# JAVA并发机制底层实现

java代码编译成java字节码后，会被加载到JVM中执行，并转换成汇编指令在CPU上执行。

因此java所有并发机制依赖于JVM的实现和CPU指令。

## 1.volatile

::: tip 可见性
共享变量的可见性指的是，当一个线程修改一个共享变量后，其它的线程能够读取到这个修改的值。
:::

### volatile修饰的变量如何保证可见性？

为了提高处理效率，CPU不会直接和内存进行通信，而是通过CPU—缓存—内存的方式进行。对于多核处理器而言，每个处理器都有自己专门的缓存区，所有缓存区共享一个系统内存。

在对volatile修饰的变量执行写操作时，生成的汇编代码会多一个**Lock指令**，这个Lock指令只要做了两件事：

1. <font style="background: rgb(255, 240, 102)" >**当前处理器缓存行的数据会写回到系统内存中**</font>
2. <font style="background: rgb(255, 240, 102)" >**其它CPU缓存的该地址的数据失效**</font>

其它CPU会使用嗅探技术，保证**CPU内部缓存、其它CPU内部缓存、系统内存**的数据在总线上保持一致。

### volatile使用优化

::: tip 缓存行填充
多个变量占据的字节小于缓冲行的大小，那么CPU会将多个变量读到同一个高速缓存行。

而如果个别处理器支持“缓存行填充”，那么不满足缓存行大小的变量会自动扩充，单独填满占据一个缓存行。

:::

![](https://jsd.cdn.zzko.cn/gh/blage-coding/picx-images-hosting@master/20230929/image.1hhz0imgwgm8.webp)

不支持“缓存行填充”的CPU，在读写某个变量时，**可能会导致同一个缓存行内的其它变量同时被锁住**，如上图CPU1在对head节点操作时，会导致其它多处理器都不能访问缓存行1其它变量。

**字节追加**：通过扩充volatile变量的字节大小，保证每个节点变量只占据一个缓存行存储。解决了**多个共享变量在频繁写的过程中产生的锁定问题**。

## 2.synchronized

synchronized用于实现代码同步：每个线程在访问同步代码块时，首先需要获取锁，执行完退出或者抛出异常时需要释放锁。

