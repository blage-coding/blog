---
title: 散列与哈希算法
date: 2023-09-01 21:57:54
permalink: /pages/0f37ca/
categories:
  - 更多
  - 面试
  - 简历的面试问题
tags:
  - 面试
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# 散列与哈希算法

## 1.斐波那契散列

### ThreadLocal散列算法

- **ThreadLoacal**底层采用**数组**存储数据，并采用斐波那契散列计算元素存储的数组地址，**产生碰撞时采用开放寻址法+1向后寻址**。

- 斐波那契数列是描述黄金分割法则的最经典表达式，因为当n趋于无穷大时，前一项与后一项比值的极限如果存在，那么它就等于(根号5 - 1)/2，约等于0.618

- 在**平方散列**中，不再是利用value待散列值作为乘数，而是利用黄金分割法则生成，就得到了斐波那契散列中的**哈希魔数**:

  | 位数 | 散列乘方值            |
  | ---- | --------------------- |
  | 16   | 0.618*2^16=40503      |
  | 32   | 0.618*2^32=2654435769 |

- 对于32位整数，最终得到的斐波那契散列公式如下：<font color="red">**index = (value * 2654435769) >> 28**</font> 。其中右移28位相当于保留高4位，无特别意义。当然这里右移操作也可以改成取余计算&(length-1)，其中length表示ThreadLocal的容量大小。

### 抽奖场景应用

在抽奖场景中，使用斐波那契散列生成随机数：

```java
int hashcode = val * 0x61c88647 + 0x61c88647;
return hashcode&(128-1);
```

- 这里还进行一轮加法运算，目的是增加多种运算法则，既有乘法又有加法，从而散列更充分。
- 选择大于100的最近2的幂次方数进行**与运算**，实际上与取余运算等价，目的是为了提高运算效率。

## 2.HashMap散列



### 路由组件运用

```java
int idx = (size - 1) & (dbKeyAttr.hashCode() ^ (dbKeyAttr.hashCode() >>> 16));
```

- 这里路由场景中选择HashMap扰动函数的散列算法，**根据订单uID值散列到分库表的索引中**。
- 实际上大厂的路由策略基本都是除法散列。

