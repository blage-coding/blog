---
title: order by
date: 2023-06-24 16:17:23
permalink: /pages/b8f0e6/
categories:
  - 数据库
  - MySQL
  - 基础部分
tags:
  - 数据库
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# order by

![](https://cdn.staticaly.com/gh/blage-coding/picx-images-hosting@master/20230625/image.4z8k5f9sdgw0.webp)

## 1.全字段排序

分析以下SQL语句执行流程，city字段建立了索引。

```sql
select city,name,age from t where city='杭州' order by name limit 1000 ;
```

- 首先从city的索引B+树叶子节点，获取每行记录的主键ID，然后从主键索引树的每一行记录中，取出查询的三个字段。
- <font color="red">**在内存开辟一个用于排序的空间sort_buffer**</font>，并指定空间大小。
- **将每行记录的city,name,age三个字段都放入sort_buffer**，然后根据name字段进行快排(内部排序)。放入内存排序可能存在两种情况：
  - sort_buffer空间大小 > 所有要排序的数据量：此时需要进行**外部排序**，将所有数据分块并依次放入sort_buffer进行排序，每个有序的块排序好后会存放在“**临时文件**”中，最后将每块有序的临时文件通过**归并排序**合并成一个大的有序的文件。
  - sort_buffer空间大小 ＜ 所有要排序的数据量：直接在**内存**进行排序。
- 把排序后前1000条结果返回给客户端。

SQL语句排序时可以通过查看**OPTIMIZER_TRACE**结果，对执行排序的SQL语句进行分析，其中介绍几个字段的含义：

“number_of_tmp_files”：表示使用到了临时文件的数量，**内存开辟的排序空间越小，使用到的临时文件越多**。

“examined_rows”：参与排序的行数。

“sort_mode ”里面的packed_additional_fields：表示对字符串进行了紧凑处理，按照**实际字符串长度分配空间**。Varchar定义的长度无效。

缺点：<font color="red">**单行数据大或者sort_buffer分配内存空间小的情况下，效率比较低**</font>，不能充分利用内存进行排序。

## 2.rowId排序

**max_length_for_sort_data：单行数据的长度超过设定阈值，则更换rowId排序法**。

<font color="red">**rowId排序方法用于解决单行数据长度过大,排序效率低的问题**</font>，与全字段排序相比，区别如下：

- <font color="red">**sort_buffer内放入的字段，只有order by需要排序的字段name，以及主键ID**</font>。
- 最后根据排序结果的主键ID，**再进行一次回表**，从磁盘中取出查询的所有字段并返回。

## 3.优化

**MySQL设计思想：内存够就多用内存，减少磁盘访问。因此优先考虑全字段排序，然后才考虑rowId排序优化**。

### 3.1建立\<where字段，排序字段\>联合索引

建立联合索引之后，**在联合索引树根据where字段，查询到的每一条记录主键ID都是有序的**。因此直接根据ID回表读数据返回即可，直到不满足查询条件，或者是超过limit记录数。

explain结果可以发现extra字段没有using filesort，整个过程不需要排序。

### 3.2建立\<where字段，排序字段，select字段\>覆盖索引

只要当前联合索引已经覆盖了所有查询所需要的字段，那么就**不需要进行回表**。explain结果可以发现extra字段出现using index，表示使用了覆盖索引。

注意：如果where使用了in条件，可能会破坏有序性，导致虽然使用了联合索引，但依旧需要重新排序。<font color="red">**优化策略是分别单独读取每一个in字段的记录到内存，然后业务端再继续归并排序。这样可以避免MySQL的临时文件或者是rowId多一次回表**</font>。

### 3.3其它

减少select字段：为防止单行数据长度过大，导致创建过多的临时文件，**select查询时可以减少查询的字段**。

limit行数小于表记录数：此时优化器会认为全表扫描比用索引方式快。

## 4.临时表

**什么情况下排序时会使用临时表**？

SQL语句”所要操作排序的表“不是磁盘中的表，而是**进一步经过函数处理、表拼接等处理过后的表**。这些表称之为临时表。

### 4.1内存临时表

内存临时表：整个临时表的所有行数据存储在内存中。**使用的引擎默认是MEMORY**。

**对于内存表的排序，优化器会选择rowId排序**。因为回表时只需要在内存中读取数据，而不需要从磁盘读。

```java
select word from t order by rand() limit 3;
```

分析上述SQL语句的排序过程：

- 首先在磁盘中对t表进行全表扫描，调用rand()计算得到结果(称为字段A)，然后将select需要查询的字段word+字段A都存入内存的一个临时表中。扫描行数为10000。
- 采用rowId排序，从内存临时表中，把排序字段A与”位置信息“字段存入sort_buffer当中。扫描行数变为20000
- 对内存临时表进行排序
- 得到有序sort_buffer后，根据”位置信息“进行<font color="red">**在内存中回表**</font>，取出前三条记录。最后返回结果集。

其中”位置信息“用于定位标识每一行数据。MEMORY引擎中为数组的索引；而InnoDB引擎中为主键ID。

### 4.2磁盘临时表

**tmp_table_size：当内存临时表大小超过设定阈值时，就会转化为磁盘临时表**。默认使用InnoDB引擎。

**filesort_priority_queue_optimization中chosen=true：表示使用了优先队列排序算法**。

#### 🔥**归并排序VS优先队列算法(堆排序**)

上述SQL语句包含limit字段，只需要查出前3条记录，如果依旧使用归并排序，那么9997条记录也是有序的，而最后需要返回给用户的只有三条，因此就**浪费了非常多的计算量**。

而使用堆排序，维护一个大小为3的堆，最后只需要返回这个堆里的元素即可。剩余数据有序与否不需要关心。

如果SQL语句排序时<font color="red">**使用了优先队列算法，那么使用到的临时文件number_of_tmp_files为0**</font>。因为只有归并排序才会用到临时文件保存有序块。

最终具体采用哪种排序算法，取决于以下几点：

- 如果不存在limit，则对整个临时表进行归并排序
- 如果存在limit m，需要根据m的大小进一步确定：
  - **如果m条记录的长度(字节数)大于sort_buffer_size大小，那么说明内存不能维护这么大的堆**。只能采用归并排序。
  - 如果内存能够维护大小为m的堆，那么此时可以采用优先队列堆排序。

## 5.随机排序

