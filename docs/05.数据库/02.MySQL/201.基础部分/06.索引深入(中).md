---
title: 索引深入(中)
date: 2023-06-15 11:10:34
permalink: /pages/6fb183/
categories:
  - 数据库
  - MySQL
  - 基础部分
tags:
  - 数据库
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# 索引深入

## 1.普通索引和唯一索引的选择

对于表中的字段k，在不同业务下考虑添加什么类型的索引可以提高性能。

### 1.1查询读操作

考虑如下语句(假设k不作为主键)：

```sql
select id from T where k=5；
```

- 唯一索引：首先去k的二级索引树搜索，因为**唯一索引保证了索引字段列数据的唯一性**，因此找到(k=5,id=500)这一条记录后，直接进行回表。
- 普通索引：首先去k的二级索引树搜索，查询到(k=5,id=500)这一条记录后，**会继续查找下一个k的记录，直到碰到第一个k不等于5的记录**。最后进行回表。

普通索引因为没有唯一性，因此多了一个继续往后查找，直到不满足查询条件的操作。这里假设业务代码已经控制了k字段的唯一性，并且所查询记录出现在内存数据页的概率较低。

因此**普通索引和唯一索引之间的在读操作上性能损耗几乎可以忽略不计**，几乎相同。

### 1.2更新写操作

InnoDB无论是进行读还是写，读取记录时都会将<font color="red">**该记录所在的数据页从磁盘读到内存**</font>，然后在该数据页上再通过**二分法**找到具体行的数据。

- **change buffer介绍**

change buffer本质上是一个<font color="red">**更新操作专属的缓冲区**</font>，因为在进行更新操作时，并不需要将数据读取并返回客户，因此change buffer解决了**更新操作导致的磁盘数据页频繁IO的问题**，更新操作时不需要将数据页读到内存中，只需要记录在内存中change buffer(事务提交后通过后台持久化到磁盘)。

具体来说，更新时如果数据页已经在内存当中，那么直接更新。如果数据页不在内存中，更新时InnoDB只需要将更新操作记录在change buffer中，下一次**查询操作**到来时会触发<font color="red">**merge操作**</font>，把数据页读入内存后**执行change buffer中与这个页相关的操作**，然后写redo log(数据页变更)，merge结束。而此时内存中的数据页和change buffer都属于**脏页**，后续需要刷盘。

因此往往希望merge之前，change buffer存的更改操作越多越好，最后一次性写入到数据页中。好处：①减少磁盘IO，提升语句**执行速度**②提高内存利用率，减少内存占用。

- **change buffer使用条件**

对于唯一索引而言，因为每次执行插入语句都**需要判断是否破坏唯一性约束**(并且马上将结果返回给调用方)，而这必须要将数据页读入内存中才能进行判断，因此就破坏了change buffer的延迟性。既然已经将数据写到内存了，那就没必要再用change buffer，直接修改内存的数据页即可。

因此<font color="red">**只有普通索引能够使用change buffer,唯一索引不能使用**</font>。业务能够接受的场景下使用普通索引，比如对于线上数据库和归档库，归**档库相当于历史数据，已经确保不存在唯一键冲突**，因此可以将归档库索引改成普通索引，提高归档效率。

- **change buffer更新操作与使用场景**
  - 唯一索引
    - 数据页不在内存中：将数据页读入内存，判断是否存在字段冲突，没有冲突则插入数据，语句结束。
    - 数据页在内存中：判断是否存在字段冲突，若没有冲突则写入内存数据页，语句结束。
  - 普通索引(使用change buffer)
    - 数据页不在内存中：**在change buffer中记录更新操作**，语句结束。
    - 数据页在内存中：直接修改内存中的数据页，语句结束。

✨<font color="red">**change buffer机制大大减少了普通索引下，更新操作带来的磁盘IO次数**</font>。因此对于**写多读少**的场景(日志，账单类)，使用change buffer的效果最好。而对于**更新之后马上需要进行查询**的场景效果比较差，此时多了change buffer的维护成本。

### 1.3redo log与change buffer下的更新事务流程

为了便于区分与描述，**将内存数据持久化到磁盘的过程称之为“写”，而将磁盘的数据读入到内存的过程称为“读**”。

**redo log**分为两部分一部分在内存(redo log buffer)，一部分在磁盘(redo log file)。它的作用主要分为两个：

- 保证数据一致性。通过redo log恢复数据库，进行备份。

- 将<font color="red">**随机写**</font>转换成<font color="red">**顺序写**</font>，**减少随机写产生的磁盘IO性能消耗**。首先明白一点，**无论是redo log还是数据页，在内存还是磁盘中都各有一份备份**。以一个包含多个更新操作的事务提交过程为例，对于有无redo log可以分为两种情况：

  - 如果没有使用redo log，**那么每做一次更新操作，就需要立刻将内存中的数据页写到磁盘中**。而每个更新操作的数据页不一定是连续的，因此“随机写”产生的磁盘IO会非常**耗时**。

  - 如果使用redo log，那么整个更新事务会按顺序执行以下步骤：

    - 首先先更新内存中的数据页，根据是否使用change buffer，操作方式有所不同。
    - 然后将上述更新操作记录到内存中的redo log buffer。
    - <font color="red">**在内存中提交更新操作事务**</font>。

    - 写日志：将内存中的redo log buffer持久化到磁盘redo log file。其中<font color="red">**将redo log从内存持久化到磁盘的这个过程就是"顺序IO写"**</font>。redo log只是按顺序记录了每一个操作记录，因此刷盘时只需要顺序在redo log file的尾部append添加操作记录。——prepare状态

    - 写数据页：MySQL**后台任务**将内存中的数据页<font color="red">**异步**</font>同步刷到磁盘中，此处也分为两种情况：

      ①使用了change buffer，则不需要“真同步”②没有使用change buffer，则需要将数据页同步到磁盘。——commit状态

🔥综上redo log性能提升的点在于，把**数据页从内存随机写到磁盘**的过程，转化为**将redo log里的更新操作从内存顺序写到磁盘**的过程，从而大大**减少执行更新操作时的响应时间**。最后在后台异步执行数据页的持久化，相当于将这个过程**延后**了。

总结：因此change buffer节省的是“更新操作”下<font color="red">**读磁盘**</font>的IO消耗；而redo log节省的实际上是<font color="red">**写磁盘**</font>的IO响应时间。

## 2.索引选错异常

MySQL在某些情况下受到更新语句和查询语句的影响，导致选错索引从而影响查询性能。

**explain+SQL查询语句**：查看当前语句使用的索引，以及**执行这条SQL语句扫描的行数rows**。

**show index from t**：查看当前表中每个索引的基数。

### 2.1优化器

查询语句时，影响优化器选择索引进行查询的因素有以下几个：

- 扫描行数rows

**基数(cardinality**)：一个索引字段上不同值的个数；基数越大，索引的区分度越好。

**采样统计**：计算N个数据页上的不同值的平均数。

**修正命令**：<font color="red">**analyze table t**</font>;重新统计表的索引信息。

- 回表

当前索引的扫描行数虽然少，但是如果是二级索引还需要进行回表操作，代价更大。

- 排序

当前查询语句包含order by b字段，那么直接使用b作为索引则不需要后续的排序，因为索引b的B+树已经完成了。

### 2.2索引选择异常处理

如果线上出现某个查询速度变慢，索引选择异常导致性能降低，那么可以尝试以下几种方案：

- ✨采用force index在查询时手动指定采用哪个索引进行查询

```sql
select * from t force index(a) where a between 1 and 2000;
```

存在的问题在于变更的及时性。如果优化器选择的索引没有问题，那么需要重新修改语句。

- ✨**修改SQL语句，引导优化器使用正确的索引**

举例来说，如果只使用order by b进行查询并排序，此时会选择索引b。而在不影响最终查询结果的情况下，如果将查询语句的排序条件修改为order by b,a；也就是说将a和b索引在排序上的代价都控制为相同的，那么此时优化器就会选择a，因为它的行数更少。

另外**增加limit的查询数量**，也可以增加该字段的代价。

- ✨**直接删除当前优化器误用的索引**

方法简单暴力有效，在不影响该索引在其它业务查询性能的情况下，可以使用这种方式。

### 2.3事务版本与rows计算

假设有如下场景：

- 事务A当前开启了事务
- 事务B开启了事务
- 事务B删除某张表的所有数据，然后重新恢复生成所有数据。
- 事务B执行查询语句，并调用explain查看该条SQL语句执行情况。
- 事务B关闭，事务A关闭

此时explain后会发现优化器计算得到的当前扫描行数rows**翻了一倍**。具体原因在于，首先事务A没有提交，因此事务B的删除操作无效，也就是**事务A那个版本的所有数据还存在原先索引a上**。此时B再重新创建恢复数据，就会导致优化器认为**索引a有两个版本的数据**。只有事务A提交之后事务版本小于低水位，当前索引才不可见。

而如果对于主键而言，rows的计算值并不会因为存在多版本数据而受到影响。它会直接根据**表的行数**进行估计，使用show table status的值。