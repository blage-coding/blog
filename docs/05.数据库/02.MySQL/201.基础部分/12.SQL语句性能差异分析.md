---
title: SQL语句性能差异分析
date: 2023-06-27 20:06:02
permalink: /pages/ccf743/
categories:
  - 数据库
  - MySQL
  - 基础部分
tags:
  - 数据库
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# SQL语句性能差异分析

## 案例一、条件字段的函数操作

<font color="red">**SQL查询语句中，如果在where条件限制字段时使用了函数，那么可能会导致该字段的索引失效，没有使用上B+树的快速定位功能**</font>。

需求&场景：统计所有记录中七月的交易记录总数。其中t_modified为datetime类型，并且添加了索引。

查询方式①

```sql
select count(*) from tradelog where month(t_modified)=7;
```

查询方式②

```sql
select count(*) from tradelog where
    -> (t_modified >= '2016-7-1' and t_modified<'2016-8-1') or
    -> (t_modified >= '2017-7-1' and t_modified<'2017-8-1') or 
    -> (t_modified >= '2018-7-1' and t_modified<'2018-8-1');
```

对于方式一，因为没有给出限定年份，**搜索时不能走B+树的快速定位**。**但并不代表不走这个索引**，对比发现索引t_modified叶子节点数据比主键索引叶子节点数据更小，所以最后还是走的全索引扫描。

对于方式二，将函数操作改为范围查询，此时可以使用到B+树的快速定位功能。

另外优化器在判断解析where字段时，对于表达式而言**等号左边只含有索引字段才能使用到索引**。具体来说 where id+1=10000和where id=10000-1只有后者会使用到索引。

## 案例二、隐式类型转换

<font color="red">**SQL数据类型隐式转换规则：在表达式中会自动将字符串类型转化成数字，再进行判断和比较**</font>。

需求&场景：tradeid字段为varchar(32)类型，存在索引。

```sql
select * from tradelog where tradeid=110717;
```

这条语句在查询时相当于给tradeid字段添加一个”转换函数“，从而**使tradeid的索引B+树失效**，不能快速定位。

## 案例三、隐式字符编码转换

<font color="red">**SQL字符编码隐式转换规则：在联表查询时，不同表之间字段的表达式进行比较时，会将编码格式为utf8的字段值转换成utf8mb4编码格式。因为utf8mb4时utf8的超集**</font>。

需求&场景：d表中编码格式为utf8，而l表编码格式为utf8mb4。

```sql
select d.* from l, d where d.tradeid=l.tradeid and l.id=2;
```

拿到l表的字段值在d表匹配查询时，**d表的tradeid字段索引树需要转化为utf8mb4格式，因此索引失效**。

两种解决方案：

- 将d表的字段字符集也改成utf8mb4
- 在SQL语句直接修改d.tradeid的字符集编码格式