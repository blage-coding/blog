---
title: MySQL一致性与高可用性
date: 2023-07-03 09:50:28
permalink: /pages/fe5521/
categories:
  - 数据库
  - MySQL
  - 基础部分
tags:
  - 数据库
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# MySQL一致性与高可用性

客户端和主库进行连接，并在主库上进行所有读写操作。然后主库会将所有更新都同步到备库中。

## MySQL一致性

### 备库设置Readonly

一般情况下，备库需要进行设置成readonly只读模式，好处如下：

- 为了减少主库的压力，一些运营类查询语句会**放到备库上查**，设置只读可以设置防止误操作。
- 防止主备切换时出现**双写**bug，导致主备不一致。
- 通过readonly可以区分节点是主库还是存库。

只读模式对于拥有super用户权限的用户是无效的，**用于备库的同步更新的线程就拥有超级权限**。因此备库的更新不会受限于只读模式。

### 主备日志同步流程

主库(A节点)执行事务并更新日志后，<font color="red">**通过dump_thread线程专门用于维护主库和备库的长连接**</font>。

![](https://cdn.staticaly.com/gh/blage-coding/picx-images-hosting@master/20230703/image.1ws6tgq9wuf4.webp)

1. 备库B通过change master命令设置主库A的IP、用户名、密码，**要读取的主库的binlog文件名和位置偏移**。
2. 备库上执行start slave命令后，备库上会启动两个线程：
   - **io-thread：负责与主库进行连接**。拿到主库的binlog日志后会写到本地文件，也就是中转日志(relaylog)
   - **sql-thread：读取中转日志，并解析出日志的SQL命令然后执行**。

### binlog的三种格式

<font style="background: rgb(240, 240, 236)" color="#d94a33">**binlog_format**</font>：设置binlog的格式。可选参数包含以下三种格式。

#### 1.statement

使用以下命令查看binlog日志文件：

```sql
/*查看当前binlog的记录位置*/
show master status;
/*根据日志名称查看指定日志文件*/
show binlog events in 'master.000001';
```

得到的binlog内容如下，其中<font color="red">**begin和commit之间记录的是SQL语句原文**</font>。

![](https://cdn.staticaly.com/gh/blage-coding/picx-images-hosting@master/20230703/image.6sx67yjma200.webp)

- 第三行：首先use 'test'表示先锁定删除数据表t所在的数据库test，然后接着执行删除命令。
- 第四行：XID用于redolog与binlog两者之间的定位和标识。

```sql
delete from t where a>=4 and t_modified<='2018-11-10' limit 1;
```

💣**statement格式存在的问题**：考虑如果客户端要执行以上语句，其中t_modified和a字段都有索引，因为limit 1的缘故，该条删除语句分别使用a索引和t_modified索引，**定位到的可能不是一条行记录**。

也就是说在statement格式下，仅仅根据SQL语句进行备份，**如果主库执行时使用了索引a，而备库执行时使用了t_modified，那么就会导致主备不一致的情况**。MySQL认为这是不安全的。

#### 2.row

借助mysqlbinlog工具解析查看binlog具体内容。其中-vv表示将内容都解析出来，可以看到各个字段的值。

```sql
mysqlbinlog  -vv data/master.000001 --start-position=8900;
```

![](https://cdn.staticaly.com/gh/blage-coding/picx-images-hosting@master/20230703/image.3qswvxwezt40.webp)

row格式下，begin与commit之间记录的是两个event事件：

- <font style="background: rgb(240, 240, 236)" color="#d94a33">**Table_map**</font> ：用于说明SQL语句操作的是哪个库哪个表

- <font style="background: rgb(240, 240, 236)" color="#d94a33">**Delete_rows**</font>：用于定义删除行为。其中根据binlog_row_images不同，记录的信息也存在些许差别：

  - <font style="background: rgb(240, 240, 236)" color="#d94a33">**binlog_row_image**</font> = FULL：记录更新之前的记录，以及更新之后的记录。**增加binlog文件大小，增加磁盘IO，但从数据恢复角度来说更加安全**。

    ```sql
    ### UPDATE `test`.`t2`
    ### WHERE
    ###   @1=1 /* INT meta=0 nullable=0 is_null=0 */
    ###   @2='gz' /* STRING(20) meta=65044 nullable=1 is_null=0 */
    ###   @4=3 /* INT meta=0 nullable=1 is_null=0 */
    ### SET
    ###   @1=1 /* INT meta=0 nullable=0 is_null=0 */
    ###   @2='gz' /* STRING(20) meta=65044 nullable=1 is_null=0 */
    ###   @3=99 /* INT meta=0 nullable=1 is_null=0 */
    ```

  - <font style="background: rgb(240, 240, 236)" color="#d94a33">**binlog_row_image**</font> = MINIMAL：仅记录该行更新的列字段值信息。**相比FULL方式binlog文件更小，但不够安全**。

    ```sql
    ### UPDATE `test`.`t2`
    ### WHERE
    ###   @1=1 /* INT meta=0 nullable=0 is_null=0 */
    ### SET
    ###   @3=100 /* INT meta=0 nullable=1 is_null=0 */
    ```

综上，在row格式下，<font color="red">**binlog记录了具体更新操作行的主键id值**</font>，从而保证无论是主库还是备库，都能够根据主键id**定位到同一行数据**。

#### 3.mixed

对比上面两种格式的binlog，不难分析出存在以下优缺点：

- statement格式的**binlog文件更小**，因为只需要花费几十个字节存储一个SQL语句。但是在备份同步时，可能会出现**主备不一致**的情况。
- row格式的binlog虽然解决了主备不一致的问题，但binlog**文件较大浪费空间，耗费IO资源**。假设一个delete语句删除十万行数据，那么binlog文件中就需要记载十万个行记录的信息(至少包含主键id)。

mixed：这种格式相当于以上两种方案的折中。<font color="red">**对于一条SQL语句，如果不会造成主备不一致，那么就会转化为statement格式；否则就用row格式**</font>。

#### 4.增删改场景下binlog格式选择

结论：一般来说**主要使用row格式**。因为row格式有一个很大的好处：<font color="red">**恢复数据**</font>。

row格式中记载了更新前和更新后行记录的所有信息，因此**删错了就在日志中改为插入；插错了就在日志中改为删除；对于更新操作只需要将event事件更新前后的记录信息对调**即可。

```sql
insert into t values(10,10,now());
```

这条SQL语句需要插入当前时间，因此备库根据binlog的SQL语句同步数据时，肯定会由于存在**时间间隔**而导致主从不一致的情况。因此这种情况下有两种解决方案：

- 使用row格式不会出现主备不一致的情况，直接根据该条行记录的列信息进行同步和备份。

- 使用mixed格式的情况下，**MySQL虽然会选择statenment格式，但是会加上时间戳信息，保证now()返回的是一个设定好的时间**。

  ```sql
  set TIMESTAMP=1546103491;
  insert into t values(10,10,now());
  ```

#### 5.如何根据binlog来恢复数据

statement格式的SQL语句在执行时，有时候**依赖于binlog的上下文命令**。因此使用binlog恢复数据时，需要将解析结果整行整段一起执行。

```sql
mysqlbinlog master.000001  --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;
```

上述命令是指将master.000001文件2738字节到2973字节中间这段内容进行**解析和重放**，然后放到MySQL执行。

### 循环复制问题

实际生产过程中，采用的是**双M结构**(双主节点)。

![](https://cdn.staticaly.com/gh/blage-coding/picx-images-hosting@master/20230703/image.7gksd814k0o0.webp)

- 不存在绝对的主节点或者从节点。**节点之间互为主备关系**。
- 如果客户端在A节点进行更新操作，那么B节点就作为从节点将A节点内容同步到自己节点上。反之在B节点上进行更新，那么A节点就需要同步更新。

<font style="background: rgb(240, 240, 236)" color="#d94a33">**log_slave_updates**</font> ：设置为on，表示备库执行relaylog之后会生成binlog。

::: tip 循环复制问题
A节点执行完更新语句将binlog传给备库B，B节点执行更新语句的同时自身也会生成新的binlog文件，因此这时候A节点相当于”备库“，又轮到A节点同步...这样就会不断循环执行同一条更新语句。

:::

<font color="red">**MySQL对于每条命令，第一次执行时都会在binlog中记下所在的server id，并且将这条日志在传给备库时，备库并不会修改**</font>。而每**个库的server id都是不同的**，所以可以根据server id来中止恶行循环。备库在执行relaylog时，**生成的binlog的server id需要与relaylog的id保持一致**。

整个过程如下：

1. A节点执行更新操作，并生成binlog，通过后台线程传给B节点
2. B节点收到后，执行relaylog，并生成新的binlog，此时该binlog中的更新操作的server id仍然为A节点的id
3. A节点作为B的”从节点“，拿到B传过来的binlog，**发现里面的server id就是自己的server id。因此不再执行该日志的更新操作**。

然而这个方法也还是存在一定的缺点，当节点数大于2时，备库之间发送的binlog日志同样会造成死循环。也就是说**发送binlog进行同步的节点只能由主库发起**，”备库“与”备库“之间不能发起同步。

```sql
stop slave；
CHANGE MASTER TO IGNORE_SERVER_IDS=(server_id_of_B);
start slave;
```

从节点可以执行以上语句，当前从节点受到日志更新后，主节点还是一开始的主节点，从而中止日志传播。

## MySQL高可用性

::: tip 主备延迟
主库A执行完一个事务写入binlog，计为时刻T1；备库B收到更新binlog并执行完这个更新事务，计为时刻T2；

主备延迟就是主库执行完成的时间与备库完成同步的时间之差，也就是T2-T1。在备库中可以通过show slave status命令查看主备延迟<font style="background: rgb(240, 240, 236)" color="#d94a33">**seconds_behind_master**</font> 的值。

:::

在备库执行以下SQL语句查看备库的延迟。忽略网络因素，主备延迟的来源主要是**备库消费relaylog的这段时间**。

```sql
show slave status;
```

### 主备延迟的来源

- **备库所在的机器性能较差**

备库设置”非双1“的模式下，更新操作导致的大量IOPS，因此备库在”烂机器“上抢占CPU和内存资源执行同步更新事务，导致更大的主备延迟。

- **备库压力大**

为了不直接影响业务，个别查询语句往往在备库上执行，而**这些查询语句也会耗费大量CPU资源**，从而影响新进来的同步更新速度。

解决方案：①**一主多从**：一个备库不行那就搞多几个备库，让多个备库分担查询压力。

- **大事务**

一个大事务如果主库执行需要十分钟，那么从库执行时也至少需要十分钟。从而造成较大的主备延迟。

因此需要尽可能避免大事务操作，可以将数据分批处理。

### 可靠性优先策略

当有新的更新操作到来后，整个主备切换流程如下：

1. 首先判断备库B的主备延迟<font style="background: rgb(240, 240, 236)" color="#d94a33">**seconds_behind_master**</font>是否小于设定的阈值，如果不小于则轮询重试这一步。
2. 将主库A设置为**只读模式**。——此时**整个数据库直到步骤5处于短暂的不可用状态**。
3. 判断备库B的<font style="background: rgb(240, 240, 236)" color="#d94a33">**seconds_behind_master**</font>是否等于0，如果不等于0则持续轮询。
4. 将备库B设置为**可读写模式**。
5. 把业务请求切到备库B,完成**主从切换**。

整个过程最耗时的地方是步骤3，因此这就是为什么存在主备延迟double check的原因：

- 第一遍轮询主备延迟原因在于，步骤三耗时比较慢，如果进来时的主备延迟就很大，那么很早就关闭主库A的权限会**导致整个系统不可用的时间大大延长**。
- 第二遍轮询的目的在于保证可靠性，等待**整个备库B执行完所有的事务，完成同步**。

显然<font color="red">**可靠性策略能够保证主备库数据的一致性，但是需要花费较大时间等待备库完成同步**</font>。

### 可用性优先策略

在可用性优先策略中，将上述步骤4、5提前执行。即先切换，后补数据实现同步：

1. 将备库B设置为可读写模式
2. 把所有业务请求切到备库B上，完成主从切换。
3. 同上步骤一到三，备库B执行主库A传过来的更新日志，实现同步。

可用性策略能够保证系统<font color="red">**以较低的时延实现主备切换，速度快，但缺点在于容易出现主备数据不一致**</font>。

### 主库断电场景

场景：主库突然断电或者宕机，并且当前主备延迟是30分钟。

这种情况下显然只能采用可用性优先策略，因为如果不立马将当前备库切换到主库，就会导致整个系统不可用；可即使是切换到了备库B，主备延迟有30分钟那么大，这意味着**30分钟内更新的数据用户是查询不到的**，对个别业务场景而言，这种状态也是不能接受的。

总而言之，在保证**数据可靠性优先**的条件下，MySQL的可用性依赖于**主备延迟**。<font color="red">**延迟越小，主库出故障后恢复服务所需要的时间越短，可用性越高**</font>。