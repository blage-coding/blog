---
title: 临时表
date: 2023-07-10 15:18:45
permalink: /pages/b0d03e/
categories:
  - 数据库
  - MySQL
  - 基础部分
tags:
  - 数据库
author: 
  name: phan
  link: https://gitee.com/blage-coding
---
# 临时表

临时表分两种，一种是用户自己创建的用户临时表。另一种是前面讲到的排序时用到的内部临时表。

## 用户临时表

用户临时表一般指的是用户手动创建的临时表。建表语句create temporary table ...

### 用户临时表特点

用户临时表具有以下特性：

- 临时表写操作会写在磁盘上

- 一个临时表只能被创建它的session访问，**对其它线程不可见**。

- 临时表可以与普通表同名，在这种情况下，<font color="red">**执行show create和增删改查操作会优先选择临时表**</font>

- <font color="red">**线程会话结束后，会自动删除临时表**</font>。执行drop temporary table自动回收。

### 用户临时表重名与可见性

- 物理磁盘上区分

创建临时表时，MySQL会创建一个**frm文件**保存表结构定义(放在临时文件夹目录下，而不是当前数据库目录下)，而**文件名的前缀为”#sql进程id\_线程id\_序列号**“。

因此不同创建的临时表名在磁盘上并不会重名。

- 内存上区分

在内存中每个表都对应一个<font style="background: rgb(240, 240, 236)" color="#d94a33">**table_def_key**</font>。普通表的<font style="background: rgb(240, 240, 236)" color="#d94a33">**table_def_key**</font>是通过”库名+表名“得到；而**临时表的名称会在普通表的基础上添加”server_id+thread_id**“，有了线程id作为区分后，不同线程创建的同名临时表也会被区分。

### 用户临时表的主备复制

<font color="red">**binlog在row格式下，不会记录所有在临时表上的操作日志**</font>。

💣问题一：关于临时表的所有操作记录为什么都需要记录到binlog中？

```sql
insert into t_normal select * from temp_t;
```

上面这条SQL语句中，因为是普通表的更新操作，因此会被记录到binlog中。当它需要在备库中应用binlog恢复时分几种情况：

- 如果当前binlog设置为row格式，该条日志会记录下所有插入的行数据，因此可以直接应用日志进行更新。
- 如果当前binlog设置为statment/mixed时，<font color="red">**binlog就需要同时记录下所有临时表的所有操作**</font>。

反过来说对于删除操作也是如此，对于每个drop table操作(后面可以接多个表)，如果删除的表存在临时表，并且binlog格式为row，那么备库执行日志文件时就会报错。<font color="red">**因此每个drop命令的binlog日志都会进行重写，保证特殊情况下不能有临时表**</font>。

💣问题二：主库上不同线程创建同名的临时表没有问题，那么在备库上有没有问题？

MySQL在记录主库操作时，**会把执行这个语句的线程id页一并记录到binlog中**，这样就可以在备库生成对应的<font style="background: rgb(240, 240, 236)" color="#d94a33">**table_def_key**</font>，因此备库上的临时表不存在临时表重名的问题。

### 临时表应用——分库分表系统跨库查询

假设存在一个大表ht，那么分库分表可以这么做：将表按照字段 f 分成1024个表，然后将它们平均分配在32个MySQL实例上。一般来说会有一个中间层proxy，客户端需要访问数据库需要经过中间层。

![](https://cdn.staticaly.com/gh/blage-coding/picx-images-hosting@master/20230710/image.1cprbobw8vxc.webp)

考虑这样一条SQL语句，需要从大表查询到按照t_modified字段排序后的前100条记录。这种情况下因为每个数据表都是按照字段f进行区分的，所以只能**将大表所有分区的的数据全都取出来，统一order by**。具体有两方案：

①**在proxy层实现排序逻辑**

拿到所有数据后，直接在内存进行计算。这种方案的缺点在于，当表数据量大并且SQL操作复杂时，会给proxy的CPU和内存造成很大的压力。

②**汇总实例上建立用户临时表**

本质上有点类似于归并算法。

1. 创建一个新的MySQL实例来进行数据汇总
2. 在汇总库上创建一个临时表temp。
3. 在**每个分库的分表**上执行select语句，根据t_modified字段排序取出前100条记录。
4. 把分库的结果都插入到临时表中。
5. 最后在临时表执行select limit 100语句。

💡实际场景下，计算量往往都是不饱和，因此可以直接在其中一个分库上进行临时表的汇总和计算。

## 内部临时表

### 场景一、union执行流程

考虑SQL语句：Query1 union Query2；执行过程如下：

1. 创建一个内存临时表。执行第一个查询Query1，并将所有结果存入临时表。
2. 执行第二个子查询：
   - 如果某行记录插入内存临时表时，表中已经存在相同数据，违反了唯一性约束插入失败。
   - 插入成功。
3. 从临时表中取出数据，并返回结果，删除临时表。

这里临时表起到了”**数据暂存**“的功能。

另外如果使用了**union all**则表示结果不进行去重，因此**不会使用到临时表**，直接执行子查询发给客户端。

### 场景二、group by

假设t1表中a字段存在索引，以下SQL语句按照id%10进行分组统计，并按照m的结果排序后输出。explain后可以发现Extra字段存在using index：temporary：filesort，并且使用上了a字段覆盖索引。

```sql
select id%10 as m,count(*) as c from t1 group by m;
```

1. 首先创建临时表，表中存在两个字段m和c，其中m字段作为主键(因为group by的是m)
2. 扫描t1表上a索引字段(覆盖索引)B+树叶子节点，拿到id：
   - 如果id%10得到的结果在m字段下还没有这一条记录，那么插入新的记录(id%10,1)
   - 如果已经存在，则该行记录c字段值加1
3. 遍历完后，根据字段m进行排序。根据前面的内容，内存临时表会将数据一行一行放入<font style="background: rgb(240, 240, 236)" color="#d94a33">**sort_buffer**</font>，<font style="background: rgb(240, 240, 236)" color="#d94a33">**sort_buffer**</font>中包括排序字段+位置信息，排序完后从内存临时表按序取数据返回结果集。

如果group by不需要这个排序过程，那么可以直接在后面加上**order by null**。

<font style="background: rgb(240, 240, 236)" color="#d94a33">**tmp_table_size**</font>：表示内存临时表的大小，如果group by执行时内存临时表放不下所有数据，那么就会**转化为磁盘临时表**。因此可以通过调大这个值<font color="red">**避免**</font>使用磁盘临时表。

#### group by优化——索引

原理：使用内存临时表的原因在于，需要一个临时表保存中间结果，如果当前计算id%10=6时，下一行记录id%10=1则需要回头更新数量。所以如果表内所有的行数据的id%10(也就是<font color="red">**排序字段值)本身就是有序**</font>的，在统计的过程中，遇到第一个id%10=2，那么说明id%10=1的行数为**当前的计数器值**。

**索引就可以保证这个排序字段有序的条件**，也就是说只需要创建一个排序字段的索引值，那么就可以**省略内存临时表temporary+整个排序过程filesort**

如果排序字段是某个函数映射时，可以通过给表t1创建一个新的列，并在该排序字段列上建立索引，SQL如下：

```sql
alter table t1 add column z int generated always as (id%10),add index(z);
```

#### group by优化——直接排序

数据量很大的情况下，先放到临时内存表，插入一部分数据后才发现空间不够,再放入磁盘临时表。显然如果直接放入磁盘临时表，性能上可以提高不少。

可以在SQL加入<font style="background: rgb(240, 240, 236)" color="#d94a33">**SQL_BIG_RESULT**</font>告诉优化器**直接使用**<font style="background: rgb(240, 240, 236)" color="#d94a33">**sort_buffer**</font>排序后的结果进行统计。

```sql
select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;
```

![](https://cdn.staticaly.com/gh/blage-coding/picx-images-hosting@master/20230710/image.kqo38zyvrow.webp)

1. 扫描t1表a字段索引树，计算id%100的值并放入<font style="background: rgb(240, 240, 236)" color="#d94a33">**sort_buffer**</font>当中，此时<font style="background: rgb(240, 240, 236)" color="#d94a33">**sort_buffer**</font>仅有一个m字段
2. 全部计算并放入完后，对<font style="background: rgb(240, 240, 236)" color="#d94a33">**sort_buffer**</font>中的m字段值进行排序。
3. 这样就得到一个有序m字段的有序数组。之后**直接统计有序数组内出现的字段值和次数**即可。

**整个过程不需要内存临时表，但还是需要进行排序**。explain后Extra字段using index；filesort。

#### group by优化——总结

无论是哪一种优化方式，假设group by 字段A，<font color="red">**本质上都是要得到一个按照A字段排序后的表结构**</font>，这样就可以直接读一次这个“有序”表返回结果集，不需要临时表。

✨**如果explain没有using filesort和temporary，则说明使用上了group by字段的索引**。

### 总结

什么情况下MySQL会使用内存临时表？

1. 语句执行过程可以**只读一遍表就得到结果**(可以是原表索引，也可以是内存sort_buffer)，那么就不需要中间表。否则就需要临时表保存中间结果。
2. 临时表是二维结构，如果需要用到二维表结构，**一个group by作为主键，另一个字段作为其它统计的映射函数**，则优先考虑临时表。
